/*
Deployment script for sputnik

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar tempdb "tempdb"
:setvar DatabaseName "sputnik"
:setvar DefaultFilePrefix "sputnik"
:setvar DefaultDataPath "C:\Users\ivanov.a\AppData\Local\Microsoft\Microsoft SQL Server Local DB\Instances\MSSQLLocalDB\"
:setvar DefaultLogPath "C:\Users\ivanov.a\AppData\Local\Microsoft\Microsoft SQL Server Local DB\Instances\MSSQLLocalDB\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [master];


GO

IF (DB_ID(N'$(DatabaseName)') IS NOT NULL) 
BEGIN
    ALTER DATABASE [$(DatabaseName)]
    SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
    DROP DATABASE [$(DatabaseName)];
END

GO
PRINT N'Creating database $(DatabaseName)...'
GO
CREATE DATABASE [$(DatabaseName)]
    ON 
    PRIMARY(NAME = [$(DatabaseName)], FILENAME = N'$(DefaultDataPath)$(DefaultFilePrefix)_Primary.mdf')
    LOG ON (NAME = [$(DatabaseName)_log], FILENAME = N'$(DefaultLogPath)$(DefaultFilePrefix)_Primary.ldf') COLLATE Cyrillic_General_CI_AS
GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_CLOSE OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
USE [$(DatabaseName)];


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ANSI_NULLS ON,
                ANSI_PADDING ON,
                ANSI_WARNINGS ON,
                ARITHABORT ON,
                CONCAT_NULL_YIELDS_NULL ON,
                NUMERIC_ROUNDABORT OFF,
                QUOTED_IDENTIFIER ON,
                ANSI_NULL_DEFAULT ON,
                CURSOR_DEFAULT LOCAL,
                CURSOR_CLOSE_ON_COMMIT OFF,
                AUTO_CREATE_STATISTICS ON,
                AUTO_SHRINK OFF,
                AUTO_UPDATE_STATISTICS ON,
                RECURSIVE_TRIGGERS OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ALLOW_SNAPSHOT_ISOLATION OFF;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET READ_COMMITTED_SNAPSHOT OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_UPDATE_STATISTICS_ASYNC OFF,
                PAGE_VERIFY NONE,
                DATE_CORRELATION_OPTIMIZATION OFF,
                DISABLE_BROKER,
                PARAMETERIZATION SIMPLE,
                SUPPLEMENTAL_LOGGING OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET TRUSTWORTHY OFF,
        DB_CHAINING OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET HONOR_BROKER_PRIORITY OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
ALTER DATABASE [$(DatabaseName)]
    SET TARGET_RECOVERY_TIME = 0 SECONDS 
    WITH ROLLBACK IMMEDIATE;


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET FILESTREAM(NON_TRANSACTED_ACCESS = OFF),
                CONTAINMENT = NONE 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_CREATE_STATISTICS ON(INCREMENTAL = OFF),
                MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT = OFF,
                DELAYED_DURABILITY = DISABLED 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET QUERY_STORE (QUERY_CAPTURE_MODE = ALL, DATA_FLUSH_INTERVAL_SECONDS = 900, INTERVAL_LENGTH_MINUTES = 60, MAX_PLANS_PER_QUERY = 200, CLEANUP_POLICY = (STALE_QUERY_THRESHOLD_DAYS = 367), MAX_STORAGE_SIZE_MB = 100) 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET QUERY_STORE = OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE SCOPED CONFIGURATION SET MAXDOP = 0;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET MAXDOP = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET LEGACY_CARDINALITY_ESTIMATION = OFF;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET LEGACY_CARDINALITY_ESTIMATION = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET PARAMETER_SNIFFING = ON;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET PARAMETER_SNIFFING = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET QUERY_OPTIMIZER_HOTFIXES = OFF;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET QUERY_OPTIMIZER_HOTFIXES = PRIMARY;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET TEMPORAL_HISTORY_RETENTION ON 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF fulltextserviceproperty(N'IsFulltextInstalled') = 1
    EXECUTE sp_fulltext_database 'enable';


GO
PRINT N'Creating Role [audit_writer]...';


GO
CREATE ROLE [audit_writer]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Role [zabbix]...';


GO
CREATE ROLE [zabbix]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Schema [adt]...';


GO
CREATE SCHEMA [adt]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Schema [anz]...';


GO
CREATE SCHEMA [anz]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Schema [awr]...';


GO
CREATE SCHEMA [awr]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Schema [backups]...';


GO
CREATE SCHEMA [backups]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Schema [config]...';


GO
CREATE SCHEMA [config]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Schema [db_maintenance]...';


GO
CREATE SCHEMA [db_maintenance]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Schema [info]...';


GO
CREATE SCHEMA [info]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Schema [lse]...';


GO
CREATE SCHEMA [lse]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Schema [pp]...';


GO
CREATE SCHEMA [pp]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Table [adt].[jlogon]...';


GO
CREATE TABLE [adt].[jlogon] (
    [tt]          DATETIME2 (3)  NOT NULL,
    [LoginName]   [sysname]      NOT NULL,
    [spid]        SMALLINT       NULL,
    [Host]        NVARCHAR (75)  NULL,
    [HostName]    NVARCHAR (100) NULL,
    [Host_pid]    INT            NULL,
    [ProgramName] NVARCHAR (200) NULL
);


GO
PRINT N'Creating Index [adt].[jlogon].[ci_tt]...';


GO
CREATE CLUSTERED INDEX [ci_tt]
    ON [adt].[jlogon]([tt] ASC);


GO
PRINT N'Creating Table [adt].[jconfigure]...';


GO
CREATE TABLE [adt].[jconfigure] (
    [tt]          DATETIME2 (3)  NOT NULL,
    [PName]       NVARCHAR (50)  NOT NULL,
    [POldValue]   INT            NOT NULL,
    [PNewValue]   INT            NOT NULL,
    [LoginName]   [sysname]      NOT NULL,
    [spid]        SMALLINT       NOT NULL,
    [Host]        NVARCHAR (75)  NOT NULL,
    [HostName]    NVARCHAR (100) NULL,
    [Host_pid]    INT            NULL,
    [ProgramName] NVARCHAR (200) NULL
);


GO
PRINT N'Creating Index [adt].[jconfigure].[ci_tt]...';


GO
CREATE CLUSTERED INDEX [ci_tt]
    ON [adt].[jconfigure]([tt] ASC);


GO
PRINT N'Creating Table [adt].[jsecurity]...';


GO
CREATE TABLE [adt].[jsecurity] (
    [tt]          DATETIME2 (3)  NOT NULL,
    [EventType]   NVARCHAR (100) NOT NULL,
    [ObjectType]  NVARCHAR (100) NULL,
    [ObjectName]  NVARCHAR (300) NULL,
    [CmdText]     XML            NOT NULL,
    [LoginName]   [sysname]      NOT NULL,
    [spid]        SMALLINT       NOT NULL,
    [Host]        NVARCHAR (75)  NOT NULL,
    [HostName]    NVARCHAR (100) NULL,
    [Host_pid]    INT            NULL,
    [ProgramName] NVARCHAR (200) NULL
);


GO
PRINT N'Creating Index [adt].[jsecurity].[ci_tt]...';


GO
CREATE CLUSTERED INDEX [ci_tt]
    ON [adt].[jsecurity]([tt] ASC);


GO
PRINT N'Creating Table [adt].[instance_hs]...';


GO
CREATE TABLE [adt].[instance_hs] (
    [tt]         DATETIME2 (2)   NOT NULL,
    [event_type] NVARCHAR (128)  NOT NULL,
    [db]         NVARCHAR (2000) NULL,
    [spid]       SMALLINT        NULL,
    [login]      NVARCHAR (128)  NULL,
    [host]       NVARCHAR (128)  NULL,
    [program]    NVARCHAR (128)  NULL,
    [sqltext]    NVARCHAR (MAX)  NULL,
    [textdata]   NVARCHAR (2000) NULL
);


GO
PRINT N'Creating Index [adt].[instance_hs].[cix01]...';


GO
CREATE CLUSTERED INDEX [cix01]
    ON [adt].[instance_hs]([tt] ASC, [event_type] ASC);


GO
PRINT N'Creating Table [awr].[pfc_handle]...';


GO
CREATE TABLE [awr].[pfc_handle] (
    [id]            SMALLINT       NOT NULL,
    [object_name]   NVARCHAR (300) NOT NULL,
    [counter_name]  NVARCHAR (300) NOT NULL,
    [instance_name] NVARCHAR (300) NOT NULL,
    [counter_type]  INT            NULL,
    PRIMARY KEY CLUSTERED ([id] ASC)
);


GO
PRINT N'Creating Table [awr].[pfc_data]...';


GO
CREATE TABLE [awr].[pfc_data] (
    [tt]     DATETIME        NOT NULL,
    [pfc_id] SMALLINT        NOT NULL,
    [value]  NUMERIC (19, 2) NOT NULL,
    PRIMARY KEY CLUSTERED ([pfc_id] ASC, [tt] ASC)
);


GO
PRINT N'Creating Index [awr].[pfc_data].[nci_tt]...';


GO
CREATE NONCLUSTERED INDEX [nci_tt]
    ON [awr].[pfc_data]([tt] ASC) WITH (ALLOW_PAGE_LOCKS = OFF);


GO
PRINT N'Creating Table [awr].[sql_handle_collect]...';


GO
CREATE TABLE [awr].[sql_handle_collect] (
    [tt]                        DATETIME        NOT NULL,
    [Host]                      NVARCHAR (150)  NULL,
    [Program]                   NVARCHAR (150)  NULL,
    [Login]                     NVARCHAR (200)  NOT NULL,
    [login_time]                DATETIME        NOT NULL,
    [Open_Tran]                 INT             NULL,
    [SPID]                      SMALLINT        NOT NULL,
    [DB]                        NVARCHAR (300)  NULL,
    [start_time]                DATETIME        NULL,
    [status]                    NVARCHAR (30)   NOT NULL,
    [command]                   NVARCHAR (32)   NULL,
    [Blk_By]                    SMALLINT        NULL,
    [perc_complete]             REAL            NULL,
    [wait_type]                 NVARCHAR (60)   NULL,
    [wait_time]                 INT             NULL,
    [wait_resource]             NVARCHAR (256)  NULL,
    [RunTime_sec]               DECIMAL (15, 3) NOT NULL,
    [CPU_sec]                   DECIMAL (15, 3) NOT NULL,
    [MemoryMb]                  DECIMAL (14, 2) NOT NULL,
    [IO_Reads]                  BIGINT          NOT NULL,
    [IO_Writes]                 BIGINT          NOT NULL,
    [Logical_Reads]             BIGINT          NOT NULL,
    [RowCount]                  BIGINT          NOT NULL,
    [SQLHandle]                 VARBINARY (64)  NOT NULL,
    [statement_start]           INT             NULL,
    [statement_end]             INT             NULL,
    [tempdb_current_query]      BIGINT          NULL,
    [tempdb_allocation_query]   BIGINT          NULL,
    [tempdb_current_session]    BIGINT          NULL,
    [tempdb_allocation_session] BIGINT          NULL
);


GO
PRINT N'Creating Index [awr].[sql_handle_collect].[NCIX_tt_sqlhandle]...';


GO
CREATE NONCLUSTERED INDEX [NCIX_tt_sqlhandle]
    ON [awr].[sql_handle_collect]([tt] DESC, [SQLHandle] ASC);


GO
PRINT N'Creating Table [awr].[sql_text_collect]...';


GO
CREATE TABLE [awr].[sql_text_collect] (
    [tt]        DATETIME       NOT NULL,
    [SQLHandle] VARBINARY (64) NOT NULL,
    [SQLText]   NVARCHAR (MAX) NOT NULL,
    [NumRuns]   BIGINT         NOT NULL,
    [NumLocks]  BIGINT         NOT NULL
);


GO
PRINT N'Creating Index [awr].[sql_text_collect].[NCIX_sqlhandle]...';


GO
CREATE NONCLUSTERED INDEX [NCIX_sqlhandle]
    ON [awr].[sql_text_collect]([SQLHandle] ASC);


GO
PRINT N'Creating Table [awr].[pfc_handle_dyn]...';


GO
CREATE TABLE [awr].[pfc_handle_dyn] (
    [id]            SMALLINT       IDENTITY (1, 1) NOT NULL,
    [pfc_id]        SMALLINT       NOT NULL,
    [instance_name] NVARCHAR (300) NOT NULL,
    PRIMARY KEY CLUSTERED ([id] ASC)
);


GO
PRINT N'Creating Table [awr].[pfc_data_dyn]...';


GO
CREATE TABLE [awr].[pfc_data_dyn] (
    [tt]         DATETIME        NOT NULL,
    [pfc_dyn_id] SMALLINT        NOT NULL,
    [value]      NUMERIC (19, 2) NOT NULL,
    PRIMARY KEY CLUSTERED ([pfc_dyn_id] ASC, [tt] ASC)
);


GO
PRINT N'Creating Index [awr].[pfc_data_dyn].[nci_tt]...';


GO
CREATE NONCLUSTERED INDEX [nci_tt]
    ON [awr].[pfc_data_dyn]([tt] ASC) WITH (ALLOW_PAGE_LOCKS = OFF);


GO
PRINT N'Creating Table [awr].[tempusing]...';


GO
CREATE TABLE [awr].[tempusing] (
    [tt]              DATETIME2 (2) NOT NULL,
    [spid]            SMALLINT      NOT NULL,
    [login_time]      DATETIME      NOT NULL,
    [rq_start_time]   DATETIME      NULL,
    [user_mb]         NUMERIC (9)   NULL,
    [internal_mb]     NUMERIC (9)   NULL,
    [sleep_status]    BIT           NOT NULL,
    [rq_elapsed_sec]  NUMERIC (9)   NULL,
    [rowver_tran_sec] NUMERIC (9)   NULL,
    [open_tran_flag]  BIT           NOT NULL,
    [kill_flag]       BIT           NOT NULL,
    PRIMARY KEY CLUSTERED ([tt] ASC, [spid] ASC)
);


GO
PRINT N'Creating Index [awr].[tempusing].[ixkill1]...';


GO
CREATE NONCLUSTERED INDEX [ixkill1]
    ON [awr].[tempusing]([login_time] ASC, [spid] ASC, [kill_flag] ASC, [rq_start_time] ASC) WHERE ([kill_flag]=(1));


GO
PRINT N'Creating Table [awr].[blk_handle_collect]...';


GO
CREATE TABLE [awr].[blk_handle_collect] (
    [tt]              DATETIME       NOT NULL,
    [spid]            SMALLINT       NOT NULL,
    [command]         NVARCHAR (32)  NULL,
    [status]          NVARCHAR (30)  NOT NULL,
    [start_time]      DATETIME2 (3)  NULL,
    [BlkBy]           SMALLINT       NULL,
    [wait_type]       NVARCHAR (60)  NULL,
    [wait_time]       INT            NULL,
    [wait_resource]   NVARCHAR (256) NULL,
    [trn_iso_lvl]     TINYINT        NULL,
    [SQLHandle]       VARBINARY (64) NOT NULL,
    [DB]              NVARCHAR (300) NULL,
    [Host]            NVARCHAR (150) NULL,
    [Login]           NVARCHAR (200) NULL,
    [Program]         NVARCHAR (150) NULL,
    [Host_pid]        INT            NULL,
    [statement_start] INT            NULL,
    [statement_end]   INT            NULL
);


GO
PRINT N'Creating Index [awr].[blk_handle_collect].[NCIX_tt_sqlhandle]...';


GO
CREATE NONCLUSTERED INDEX [NCIX_tt_sqlhandle]
    ON [awr].[blk_handle_collect]([tt] DESC, [SQLHandle] ASC);


GO
PRINT N'Creating Table [awr].[db_cpu_usage]...';


GO
CREATE TABLE [awr].[db_cpu_usage] (
    [tt]           DATETIME        NULL,
    [db]           NVARCHAR (1000) NULL,
    [CPU_Time_sec] DECIMAL (19)    NULL,
    [CPU_Percent]  DECIMAL (6, 3)  NULL
);


GO
PRINT N'Creating Table [awr].[db_memory_usage]...';


GO
CREATE TABLE [awr].[db_memory_usage] (
    [tt]                DATETIME        NULL,
    [db]                NVARCHAR (1000) NULL,
    [db_buffer_MB]      DECIMAL (10)    NULL,
    [db_buffer_percent] DECIMAL (6, 3)  NULL
);


GO
PRINT N'Creating Table [awr].[db_usage_stats]...';


GO
CREATE TABLE [awr].[db_usage_stats] (
    [tt]         DATETIME2 (2)   NOT NULL,
    [startup]    DATETIME2 (2)   NOT NULL,
    [db]         NVARCHAR (1000) NOT NULL,
    [dbid]       INT             NOT NULL,
    [createdate] DATETIME2 (2)   NOT NULL,
    [LastUsed]   DATETIME2 (2)   NULL,
    [cntcalls]   NUMERIC (19)    NULL
);


GO
PRINT N'Creating Table [backups].[BackConf]...';


GO
CREATE TABLE [backups].[BackConf] (
    [DBName]      NVARCHAR (300)  NULL,
    [FG]          NVARCHAR (1000) NULL,
    [LocalDir]    NVARCHAR (200)  NULL,
    [NetDir]      NVARCHAR (200)  NULL,
    [LocalDays]   INT             NULL,
    [NetDays]     INT             NULL,
    [Kind]        NVARCHAR (50)   NULL,
    [LocalPolicy] TINYINT         NOT NULL,
    [NetPolicy]   TINYINT         NOT NULL
);


GO
PRINT N'Creating Table [backups].[BackConfWeekly]...';


GO
CREATE TABLE [backups].[BackConfWeekly] (
    [DBName]            NVARCHAR (300)  NULL,
    [FG]                NVARCHAR (1000) NULL,
    [LocalDir]          NVARCHAR (200)  NULL,
    [NetDir]            NVARCHAR (200)  NULL,
    [LocalDays]         INT             NULL,
    [NetDays]           INT             NULL,
    [Kind]              NVARCHAR (50)   NULL,
    [WeekDay]           TINYINT         NULL,
    [MonthDay]          TINYINT         NULL,
    [Policy_CountFiles] BIT             NOT NULL,
    [LocalPolicy]       TINYINT         NOT NULL,
    [NetPolicy]         TINYINT         NOT NULL
);


GO
PRINT N'Creating Table [backups].[Config]...';


GO
CREATE TABLE [backups].[Config] (
    [DateConfig] DATETIME2 (3) NULL,
    [pp]         BIT           NULL
);


GO
PRINT N'Creating Table [backups].[BackupHistory]...';


GO
CREATE TABLE [backups].[BackupHistory] (
    [id]                    INT             IDENTITY (1, 1) NOT NULL,
    [DB_Name]               NVARCHAR (300)  NULL,
    [FG]                    NVARCHAR (1000) NULL,
    [Backup_Type]           VARCHAR (4)     NULL,
    [Backup_File]           NVARCHAR (260)  NULL,
    [backup_start_date]     DATETIME        NULL,
    [backup_finish_date]    DATETIME        NULL,
    [first_LSN]             NUMERIC (25)    NULL,
    [last_LSN]              NUMERIC (25)    NULL,
    [database_backup_LSN]   NUMERIC (25)    NULL,
    [diff_base_LSN]         NUMERIC (25)    NULL,
    [backup_size_Mb]        NUMERIC (19, 3) NULL,
    [backup_compress_ratio] NUMERIC (5, 2)  NULL,
    CONSTRAINT [PK] PRIMARY KEY CLUSTERED ([id] ASC)
);


GO
PRINT N'Creating Table [backups].[NoBackupList]...';


GO
CREATE TABLE [backups].[NoBackupList] (
    [DBName]     VARCHAR (1000) NOT NULL,
    [TypeBackup] VARCHAR (4)    NULL,
    [ExpDate]    DATE           NULL
);


GO
PRINT N'Creating Table [config].[cleanup_hs]...';


GO
CREATE TABLE [config].[cleanup_hs] (
    [SchemaName]    NVARCHAR (300) NULL,
    [TableName]     NVARCHAR (300) NULL,
    [Column_filter] NVARCHAR (300) NULL,
    [interval_type] VARCHAR (30)   NULL,
    [interval]      VARCHAR (10)   NULL
);


GO
PRINT N'Creating Table [config].[params]...';


GO
CREATE TABLE [config].[params] (
    [Obj] NVARCHAR (1000) NULL,
    [Pr]  NVARCHAR (1000) NULL,
    [Vl]  NVARCHAR (1000) NULL
);


GO
PRINT N'Creating Table [db_maintenance].[mw]...';


GO
CREATE TABLE [db_maintenance].[mw] (
    [UniqueName] NVARCHAR (200) NOT NULL,
    [WeekDays]   VARCHAR (100)  NULL,
    [TimeOpen]   TIME (7)       NULL,
    [TimeClose]  TIME (7)       NULL,
    [DateOpen]   DATETIME2 (2)  NULL,
    [DateClose]  DATETIME2 (2)  NULL,
    PRIMARY KEY CLUSTERED ([UniqueName] ASC)
);


GO
PRINT N'Creating Table [db_maintenance].[StopLists]...';


GO
CREATE TABLE [db_maintenance].[StopLists] (
    [UniqueName]   NVARCHAR (200) NOT NULL,
    [StopList_str] NVARCHAR (MAX) NOT NULL,
    PRIMARY KEY CLUSTERED ([UniqueName] ASC)
);


GO
PRINT N'Creating Table [db_maintenance].[RecomputeStatsConf]...';


GO
CREATE TABLE [db_maintenance].[RecomputeStatsConf] (
    [DBName]                NVARCHAR (500)  NULL,
    [UniqueName_MW]         NVARCHAR (200)  NOT NULL,
    [UniqueName_SL]         NVARCHAR (200)  NULL,
    [RowLimit]              SMALLINT        NOT NULL,
    [timeout_sec]           INT             NULL,
    [delayperiod]           CHAR (12)       NOT NULL,
    [filter_rows_min]       INT             NULL,
    [filter_rows_max]       INT             NULL,
    [filter_DataUsedMb_min] NUMERIC (9, 1)  NULL,
    [filter_DataUsedMb_max] NUMERIC (9, 1)  NULL,
    [filter_perc_min]       DECIMAL (18, 2) NOT NULL,
    [filter_perc_max]       DECIMAL (18, 2) NULL,
    [filter_old_hours]      TINYINT         NOT NULL,
    [policy_scan]           VARCHAR (100)   NULL,
    [PauseMirroring]        BIT             NOT NULL,
    [DeadLck_PR]            SMALLINT        NOT NULL,
    [Lck_Timeout]           INT             NOT NULL
);


GO
PRINT N'Creating Table [db_maintenance].[HS]...';


GO
CREATE TABLE [db_maintenance].[HS] (
    [DB_ID]             INT            NOT NULL,
    [Object_ID]         INT            NULL,
    [Index_Stat_ID]     INT            NULL,
    [Index_Stat_Type]   BIT            NULL,
    [Command_Type]      TINYINT        NOT NULL,
    [Command_Text_1000] VARCHAR (1000) NOT NULL,
    [tt_start]          DATETIME2 (2)  NOT NULL,
    [tt_end]            DATETIME2 (2)  NOT NULL,
    [Status]            BIT            NOT NULL,
    [Error_Text_1000]   VARCHAR (1000) NULL
);


GO
PRINT N'Creating Index [db_maintenance].[HS].[cix_HS_01]...';


GO
CREATE CLUSTERED INDEX [cix_HS_01]
    ON [db_maintenance].[HS]([tt_end] DESC, [Command_Type] ASC);


GO
PRINT N'Creating Table [db_maintenance].[CommandTypes]...';


GO
CREATE TABLE [db_maintenance].[CommandTypes] (
    [ID]      TINYINT        NOT NULL,
    [Command] VARCHAR (1000) NOT NULL,
    PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating Table [db_maintenance].[TabList_US]...';


GO
CREATE TABLE [db_maintenance].[TabList_US] (
    [Tab]        NVARCHAR (1000) NOT NULL,
    [Stat]       NVARCHAR (1000) NULL,
    [PolicyScan] NVARCHAR (100)  NULL
);


GO
PRINT N'Creating Table [db_maintenance].[ReindexData]...';


GO
CREATE TABLE [db_maintenance].[ReindexData] (
    [DBName]            NVARCHAR (300) NULL,
    [SchemaName]        NVARCHAR (300) NULL,
    [TableName]         NVARCHAR (300) NULL,
    [IndexName]         NVARCHAR (300) NULL,
    [TableID]           INT            NULL,
    [IndexID]           INT            NULL,
    [IndexType]         TINYINT        NULL,
    [SetFillFactor]     TINYINT        NULL,
    [TableCreateDate]   DATETIME2 (2)  NULL,
    [TableModifyDate]   DATETIME2 (2)  NULL,
    [PrepareDate]       DATETIME2 (2)  NULL,
    [PageCount]         BIGINT         NULL,
    [AVG_Fragm_percent] TINYINT        NULL,
    [~PageUsed_perc]    TINYINT        NULL,
    [~Row_cnt]          BIGINT         NULL,
    [~RowSize_Kb]       NUMERIC (9, 3) NULL,
    [LastUpdateStats]   DATETIME2 (2)  NULL,
    [LastCommand]       NVARCHAR (500) NULL,
    [LastRunDate]       DATETIME2 (2)  NULL,
    [ReindexCount]      INT            NULL,
    [NotRunOnline]      BIT            NULL
);


GO
PRINT N'Creating Table [db_maintenance].[FreeProcCache]...';


GO
CREATE TABLE [db_maintenance].[FreeProcCache] (
    [WeekDay]     TINYINT       NULL,
    [PeriodHours] TINYINT       NULL,
    [LastRunDate] DATETIME2 (2) NULL
);


GO
PRINT N'Creating Table [db_maintenance].[ReindexConf]...';


GO
CREATE TABLE [db_maintenance].[ReindexConf] (
    [DBName]           NVARCHAR (500) NULL,
    [UniqueName_MW]    NVARCHAR (200) NOT NULL,
    [UniqueName_SL]    NVARCHAR (200) NULL,
    [RowLimit]         SMALLINT       NOT NULL,
    [delayperiod]      CHAR (12)      NOT NULL,
    [filter_pages_min] INT            NOT NULL,
    [filter_pages_max] INT            NULL,
    [filter_fragm_min] TINYINT        NOT NULL,
    [filter_fragm_max] TINYINT        NULL,
    [filter_old_hours] TINYINT        NOT NULL,
    [fragm_tresh]      TINYINT        NOT NULL,
    [set_fillfactor]   TINYINT        NOT NULL,
    [set_compression]  CHAR (4)       NOT NULL,
    [set_online]       CHAR (3)       NOT NULL,
    [set_sortintempdb] CHAR (3)       NOT NULL,
    [PauseMirroring]   BIT            NOT NULL,
    [DeadLck_PR]       SMALLINT       NOT NULL,
    [Lck_Timeout]      INT            NOT NULL,
    [timeout_sec]      INT            NULL
);


GO
PRINT N'Creating Table [lse].[TargetConfig]...';


GO
CREATE TABLE [lse].[TargetConfig] (
    [id]               SMALLINT       IDENTITY (1, 1) NOT NULL,
    [ServerSource]     NVARCHAR (300) NOT NULL,
    [DBNameSource]     NVARCHAR (500) NOT NULL,
    [DBNameTarget]     NVARCHAR (500) NOT NULL,
    [FromCopy]         BIT            NOT NULL,
    [Suspend]          BIT            NOT NULL,
    [InitDate]         DATETIME2 (2)  NULL,
    [InitBackupHS_id]  INT            NULL,
    [CatalogFilesDB]   NVARCHAR (800) NOT NULL,
    [CatalogLogFiles]  NVARCHAR (800) NULL,
    [StandBy_File]     NVARCHAR (600) NULL,
    [UseFreshDiffBack] BIT            NULL,
    PRIMARY KEY CLUSTERED ([id] ASC)
);


GO
PRINT N'Creating Table [lse].[SourceConfig]...';


GO
CREATE TABLE [lse].[SourceConfig] (
    [id]           SMALLINT       IDENTITY (1, 1) NOT NULL,
    [ServerTarget] NVARCHAR (300) NULL,
    [DBNameSource] NVARCHAR (500) NULL,
    [DBNameTarget] NVARCHAR (500) NULL,
    PRIMARY KEY CLUSTERED ([id] ASC)
);


GO
PRINT N'Creating Table [lse].[HS]...';


GO
CREATE TABLE [lse].[HS] (
    [config_id]       SMALLINT      NOT NULL,
    [BackupHS_id]     INT           NOT NULL,
    [StartRestore]    DATETIME2 (2) NULL,
    [CompleteRestore] DATETIME2 (2) NULL
);


GO
PRINT N'Creating Default Constraint unnamed constraint on [awr].[pfc_handle]...';


GO
ALTER TABLE [awr].[pfc_handle]
    ADD DEFAULT ('') FOR [instance_name];


GO
PRINT N'Creating Default Constraint unnamed constraint on [awr].[pfc_data]...';


GO
ALTER TABLE [awr].[pfc_data]
    ADD DEFAULT (getdate()) FOR [tt];


GO
PRINT N'Creating Default Constraint unnamed constraint on [awr].[sql_text_collect]...';


GO
ALTER TABLE [awr].[sql_text_collect]
    ADD DEFAULT ((0)) FOR [NumRuns];


GO
PRINT N'Creating Default Constraint unnamed constraint on [awr].[sql_text_collect]...';


GO
ALTER TABLE [awr].[sql_text_collect]
    ADD DEFAULT ((0)) FOR [NumLocks];


GO
PRINT N'Creating Default Constraint unnamed constraint on [awr].[pfc_data_dyn]...';


GO
ALTER TABLE [awr].[pfc_data_dyn]
    ADD DEFAULT (getdate()) FOR [tt];


GO
PRINT N'Creating Default Constraint unnamed constraint on [backups].[BackConf]...';


GO
ALTER TABLE [backups].[BackConf]
    ADD DEFAULT ((0)) FOR [LocalPolicy];


GO
PRINT N'Creating Default Constraint unnamed constraint on [backups].[BackConf]...';


GO
ALTER TABLE [backups].[BackConf]
    ADD DEFAULT ((0)) FOR [NetPolicy];


GO
PRINT N'Creating Default Constraint unnamed constraint on [backups].[BackConfWeekly]...';


GO
ALTER TABLE [backups].[BackConfWeekly]
    ADD DEFAULT ((0)) FOR [Policy_CountFiles];


GO
PRINT N'Creating Default Constraint unnamed constraint on [backups].[BackConfWeekly]...';


GO
ALTER TABLE [backups].[BackConfWeekly]
    ADD DEFAULT ((0)) FOR [LocalPolicy];


GO
PRINT N'Creating Default Constraint unnamed constraint on [backups].[BackConfWeekly]...';


GO
ALTER TABLE [backups].[BackConfWeekly]
    ADD DEFAULT ((0)) FOR [NetPolicy];


GO
PRINT N'Creating Default Constraint unnamed constraint on [backups].[Config]...';


GO
ALTER TABLE [backups].[Config]
    ADD DEFAULT (sysdatetime()) FOR [DateConfig];


GO
PRINT N'Creating Default Constraint unnamed constraint on [db_maintenance].[RecomputeStatsConf]...';


GO
ALTER TABLE [db_maintenance].[RecomputeStatsConf]
    ADD DEFAULT ((50)) FOR [RowLimit];


GO
PRINT N'Creating Default Constraint unnamed constraint on [db_maintenance].[RecomputeStatsConf]...';


GO
ALTER TABLE [db_maintenance].[RecomputeStatsConf]
    ADD DEFAULT ('00:00:00.200') FOR [delayperiod];


GO
PRINT N'Creating Default Constraint unnamed constraint on [db_maintenance].[RecomputeStatsConf]...';


GO
ALTER TABLE [db_maintenance].[RecomputeStatsConf]
    ADD DEFAULT ((8.00)) FOR [filter_perc_min];


GO
PRINT N'Creating Default Constraint unnamed constraint on [db_maintenance].[RecomputeStatsConf]...';


GO
ALTER TABLE [db_maintenance].[RecomputeStatsConf]
    ADD DEFAULT ((24)) FOR [filter_old_hours];


GO
PRINT N'Creating Default Constraint unnamed constraint on [db_maintenance].[RecomputeStatsConf]...';


GO
ALTER TABLE [db_maintenance].[RecomputeStatsConf]
    ADD DEFAULT ((0)) FOR [PauseMirroring];


GO
PRINT N'Creating Default Constraint unnamed constraint on [db_maintenance].[RecomputeStatsConf]...';


GO
ALTER TABLE [db_maintenance].[RecomputeStatsConf]
    ADD DEFAULT ((0)) FOR [DeadLck_PR];


GO
PRINT N'Creating Default Constraint unnamed constraint on [db_maintenance].[RecomputeStatsConf]...';


GO
ALTER TABLE [db_maintenance].[RecomputeStatsConf]
    ADD DEFAULT ((20000)) FOR [Lck_Timeout];


GO
PRINT N'Creating Default Constraint unnamed constraint on [db_maintenance].[ReindexData]...';


GO
ALTER TABLE [db_maintenance].[ReindexData]
    ADD DEFAULT ((0)) FOR [ReindexCount];


GO
PRINT N'Creating Default Constraint unnamed constraint on [db_maintenance].[ReindexData]...';


GO
ALTER TABLE [db_maintenance].[ReindexData]
    ADD DEFAULT ((0)) FOR [NotRunOnline];


GO
PRINT N'Creating Default Constraint unnamed constraint on [db_maintenance].[FreeProcCache]...';


GO
ALTER TABLE [db_maintenance].[FreeProcCache]
    ADD DEFAULT ((6)) FOR [PeriodHours];


GO
PRINT N'Creating Default Constraint unnamed constraint on [db_maintenance].[ReindexConf]...';


GO
ALTER TABLE [db_maintenance].[ReindexConf]
    ADD DEFAULT ((10)) FOR [RowLimit];


GO
PRINT N'Creating Default Constraint unnamed constraint on [db_maintenance].[ReindexConf]...';


GO
ALTER TABLE [db_maintenance].[ReindexConf]
    ADD DEFAULT ('00:00:00.100') FOR [delayperiod];


GO
PRINT N'Creating Default Constraint unnamed constraint on [db_maintenance].[ReindexConf]...';


GO
ALTER TABLE [db_maintenance].[ReindexConf]
    ADD DEFAULT ((12)) FOR [filter_pages_min];


GO
PRINT N'Creating Default Constraint unnamed constraint on [db_maintenance].[ReindexConf]...';


GO
ALTER TABLE [db_maintenance].[ReindexConf]
    ADD DEFAULT ((10)) FOR [filter_fragm_min];


GO
PRINT N'Creating Default Constraint unnamed constraint on [db_maintenance].[ReindexConf]...';


GO
ALTER TABLE [db_maintenance].[ReindexConf]
    ADD DEFAULT ((24)) FOR [filter_old_hours];


GO
PRINT N'Creating Default Constraint unnamed constraint on [db_maintenance].[ReindexConf]...';


GO
ALTER TABLE [db_maintenance].[ReindexConf]
    ADD DEFAULT ((30)) FOR [fragm_tresh];


GO
PRINT N'Creating Default Constraint unnamed constraint on [db_maintenance].[ReindexConf]...';


GO
ALTER TABLE [db_maintenance].[ReindexConf]
    ADD DEFAULT ((100)) FOR [set_fillfactor];


GO
PRINT N'Creating Default Constraint unnamed constraint on [db_maintenance].[ReindexConf]...';


GO
ALTER TABLE [db_maintenance].[ReindexConf]
    ADD DEFAULT ('NONE') FOR [set_compression];


GO
PRINT N'Creating Default Constraint unnamed constraint on [db_maintenance].[ReindexConf]...';


GO
ALTER TABLE [db_maintenance].[ReindexConf]
    ADD DEFAULT ('OFF') FOR [set_online];


GO
PRINT N'Creating Default Constraint unnamed constraint on [db_maintenance].[ReindexConf]...';


GO
ALTER TABLE [db_maintenance].[ReindexConf]
    ADD DEFAULT ('OFF') FOR [set_sortintempdb];


GO
PRINT N'Creating Default Constraint unnamed constraint on [db_maintenance].[ReindexConf]...';


GO
ALTER TABLE [db_maintenance].[ReindexConf]
    ADD DEFAULT ((0)) FOR [PauseMirroring];


GO
PRINT N'Creating Default Constraint unnamed constraint on [db_maintenance].[ReindexConf]...';


GO
ALTER TABLE [db_maintenance].[ReindexConf]
    ADD DEFAULT ((0)) FOR [DeadLck_PR];


GO
PRINT N'Creating Default Constraint unnamed constraint on [db_maintenance].[ReindexConf]...';


GO
ALTER TABLE [db_maintenance].[ReindexConf]
    ADD DEFAULT ((20000)) FOR [Lck_Timeout];


GO
PRINT N'Creating Default Constraint unnamed constraint on [lse].[TargetConfig]...';


GO
ALTER TABLE [lse].[TargetConfig]
    ADD DEFAULT ((0)) FOR [FromCopy];


GO
PRINT N'Creating Default Constraint unnamed constraint on [lse].[TargetConfig]...';


GO
ALTER TABLE [lse].[TargetConfig]
    ADD DEFAULT ((0)) FOR [Suspend];


GO
PRINT N'Creating Default Constraint unnamed constraint on [lse].[TargetConfig]...';


GO
ALTER TABLE [lse].[TargetConfig]
    ADD DEFAULT (NULL) FOR [InitDate];


GO
PRINT N'Creating Default Constraint unnamed constraint on [lse].[TargetConfig]...';


GO
ALTER TABLE [lse].[TargetConfig]
    ADD DEFAULT (NULL) FOR [InitBackupHS_id];


GO
PRINT N'Creating Foreign Key unnamed constraint on [awr].[pfc_data]...';


GO
ALTER TABLE [awr].[pfc_data]
    ADD FOREIGN KEY ([pfc_id]) REFERENCES [awr].[pfc_handle] ([id]);


GO
PRINT N'Creating Foreign Key unnamed constraint on [awr].[pfc_handle_dyn]...';


GO
ALTER TABLE [awr].[pfc_handle_dyn]
    ADD FOREIGN KEY ([pfc_id]) REFERENCES [awr].[pfc_handle] ([id]);


GO
PRINT N'Creating Foreign Key unnamed constraint on [awr].[pfc_data_dyn]...';


GO
ALTER TABLE [awr].[pfc_data_dyn]
    ADD FOREIGN KEY ([pfc_dyn_id]) REFERENCES [awr].[pfc_handle_dyn] ([id]);


GO
PRINT N'Creating Message Type [pp_back_Reply]...';


GO
CREATE MESSAGE TYPE [pp_back_Reply]
    AUTHORIZATION [dbo]
    VALIDATION = WELL_FORMED_XML;


GO
PRINT N'Creating Message Type [pp_back_Request]...';


GO
CREATE MESSAGE TYPE [pp_back_Request]
    AUTHORIZATION [dbo]
    VALIDATION = WELL_FORMED_XML;


GO
PRINT N'Creating Message Type [pp_lse_Reply]...';


GO
CREATE MESSAGE TYPE [pp_lse_Reply]
    AUTHORIZATION [dbo]
    VALIDATION = WELL_FORMED_XML;


GO
PRINT N'Creating Message Type [pp_lse_Request]...';


GO
CREATE MESSAGE TYPE [pp_lse_Request]
    AUTHORIZATION [dbo]
    VALIDATION = WELL_FORMED_XML;


GO
PRINT N'Creating Contract [pp_back_Contract]...';


GO
CREATE CONTRACT [pp_back_Contract]
    AUTHORIZATION [dbo]
    ([pp_back_Request] SENT BY INITIATOR, [pp_back_Reply] SENT BY TARGET);


GO
PRINT N'Creating Contract [pp_lse_Contract]...';


GO
CREATE CONTRACT [pp_lse_Contract]
    AUTHORIZATION [dbo]
    ([pp_lse_Request] SENT BY INITIATOR, [pp_lse_Reply] SENT BY TARGET);


GO
PRINT N'Creating Broker Priority [pp_back_Priority]...';


GO
CREATE BROKER PRIORITY [pp_back_Priority] FOR CONVERSATION
    SET  (
            CONTRACT_NAME = [pp_back_Contract],
            LOCAL_SERVICE_NAME = ANY,
            REMOTE_SERVICE_NAME = ANY,
            PRIORITY_LEVEL = 8
         );


GO
PRINT N'Creating View [info].[vGetLse]...';


GO

CREATE VIEW info.vGetLse
AS
	select 
		tc.ServerSource,
		tc.DBNameSource, 
		tc.DBNameTarget, 
		case tc.[Suspend]
			when 1 then 'Pause'
			else 'Run'
		end as [Status], 
		tc.InitDate,
		hs.LastSyncTime,
		DATEDIFF(MI,hs.LastSyncTime,sysdatetime()) as LastSyncInMin,
		hs.AvgSyncDurationSec,
		hs.CountRestoredLogBackups,
		hs.LastRestoredBackupId
	from lse.TargetConfig as tc
	left join (
		select distinct
			config_id,
			max(StartRestore) as LastSyncTime,
			avg(datediff(ss,StartRestore,CompleteRestore)) as AvgSyncDurationSec,
			count(*) as CountRestoredLogBackups,
			max(BackupHS_id) as LastRestoredBackupId
		 from lse.HS
		 group by config_id
	) hs
		on tc.id=hs.config_id
GO
PRINT N'Creating View [info].[vtempusing]...';


GO

	CREATE VIEW info.vtempusing
	AS
	--Мониторинг использованного места в TempDB (по файлам)
	-- https://docs.microsoft.com/en-us/sql/relational-databases/system-dynamic-management-views/sys-dm-db-file-space-usage-transact-sql
	with cte01 as(
		select 
			cast(sum(version_store_reserved_page_count)/128 as numeric(19,0)) as rowver_mb,
			cast(sum(user_object_reserved_page_count)/128 as numeric(19,0)) as user_mb,
			cast(sum(internal_object_reserved_page_count)/128 as numeric(19,0)) as internal_mb,
			cast(sum(mixed_extent_page_count)/128 as numeric(19,0)) as mixed_mb
		from tempdb.sys.dm_db_file_space_usage
	),
	cte02 as(
		select 
			*, cast(rowver_mb+user_mb+internal_mb+mixed_mb as numeric(19,0)) as total_mb
		from cte01
	)
		select 
			pr, vl
		from cte02 as src
		unpivot 
		(vl for pr in (rowver_mb,user_mb,internal_mb,mixed_mb,total_mb)) as unpvt;
GO
PRINT N'Creating View [info].[vtempusing_ver]...';


GO

	CREATE VIEW info.vtempusing_ver
	AS
	--Мониторинг длительных транзакций, использующих row-verions store (snapshots) в tempdb:
	SELECT t.session_id as spid, ss.login_time, t.elapsed_time_seconds as tran_active_sec, ss.[status], ss.open_transaction_count as open_tran_cnt
	FROM sys.dm_tran_active_snapshot_database_transactions t
	inner join sys.dm_exec_sessions as ss
		on t.session_id=ss.session_id
	WHERE elapsed_time_seconds>180
GO
PRINT N'Creating View [info].[vtempusing_ss]...';


GO

	CREATE VIEW info.vtempusing_ss
	AS
	--Мониторинг использованного места в TempDB (по запросам):
	-- https://docs.microsoft.com/en-us/sql/relational-databases/system-dynamic-management-views/sys-dm-db-session-space-usage-transact-sql
	with cte01 as(
		SELECT
			ss.session_id as spid, 
			ss.user_objects_alloc_page_count+COALESCE(ts.user_objects_alloc_page_count,0) as user_objects_alloc_page_count,
			ss.user_objects_dealloc_page_count+COALESCE(ts.user_objects_dealloc_page_count,0) as user_objects_dealloc_page_count,
			ss.internal_objects_alloc_page_count+COALESCE(ts.internal_objects_alloc_page_count,0) as internal_objects_alloc_page_count,
			ss.internal_objects_dealloc_page_count+COALESCE(ts.internal_objects_dealloc_page_count,0) as internal_objects_dealloc_page_count
		FROM tempdb.sys.dm_db_session_space_usage ss
		LEFT JOIN tempdb.sys.dm_db_task_space_usage ts
			on ss.session_id=ts.session_id and (ts.user_objects_alloc_page_count>0 or ts.user_objects_dealloc_page_count>0 or ts.internal_objects_alloc_page_count>0 or ts.internal_objects_dealloc_page_count>0)
		WHERE ss.user_objects_alloc_page_count>0 or ss.user_objects_dealloc_page_count>0 or ss.internal_objects_alloc_page_count>0 or ss.internal_objects_dealloc_page_count>0 
	), cte02 as(
		SELECT 
			spid, 
			cast(SUM(user_objects_alloc_page_count)/128 as numeric(9,0)) AS user_alloc_mb,
			cast(SUM(user_objects_dealloc_page_count)/128 as numeric(9,0)) AS user_dealloc_mb,
			cast(SUM(internal_objects_alloc_page_count)/128 as numeric(9,0)) AS internal_alloc_mb,
			cast(SUM(internal_objects_dealloc_page_count)/128 as numeric(9,0)) AS internal_dealloc_mb
		FROM cte01
		GROUP BY spid
	)
	select 
		t.spid,
		ss.login_time,
		ss.last_request_start_time as rq_start_time,
		CASE WHEN t.user_alloc_mb-t.user_dealloc_mb<0 THEN 0 ELSE t.user_alloc_mb-t.user_dealloc_mb END as user_mb,
		CASE WHEN t.internal_alloc_mb-t.internal_dealloc_mb<0 THEN 0 ELSE t.internal_alloc_mb-t.internal_dealloc_mb END as internal_mb,
		ss.[status],
		CASE WHEN ss.[status]='sleeping' THEN datediff(second,ss.last_request_end_time,sysdatetime()) ELSE datediff(second,ss.last_request_start_time,sysdatetime()) END as elapsed_sec,
		ss.open_transaction_count as open_tran_cnt
	from cte02 as t
	inner join sys.dm_exec_sessions as ss
		on t.spid=ss.session_id
	where (ss.[status]<>'sleeping' or ss.open_transaction_count>0)
		and user_alloc_mb+internal_alloc_mb-user_dealloc_mb-internal_dealloc_mb>=300
GO
PRINT N'Creating View [info].[vGetAllBackConf]...';


GO

	CREATE VIEW info.vGetAllBackConf
	AS
		SELECT
			DBName, LocalDir, LocalDays, NetDir, NetDays, Kind, NULL as WeekDay, NULL as MonthDay
			,LocalPolicy, NetPolicy
		FROM backups.BackConf
		WHERE KIND IN ('Full', 'Diff', 'Log')
		UNION
		SELECT
			DBName, LocalDir, LocalDays, NetDir, NetDays, Kind, WeekDay, MonthDay
			,LocalPolicy, NetPolicy
		FROM backups.BackConfWeekly
		WHERE KIND IN ('Full', 'Diff', 'Log');
GO
PRINT N'Creating View [info].[vGetQuickBackConf]...';


GO

	CREATE VIEW info.vGetQuickBackConf
	AS
		SELECT
			D.DB, D.state, D.RecoveryModel,
			CASE
				WHEN BF.Kind is NULL THEN 0
				ELSE 1
			END AS 'Full',
			CASE
				WHEN BD.Kind is NULL THEN 0
				ELSE 1
			END AS 'Diff',
			CASE
				WHEN BL.Kind is NULL THEN 0
				ELSE 1
			END AS 'Log',
			CASE
				WHEN BFW.Kind is NULL THEN 0
				ELSE 1
			END AS 'FullWeekly'
		FROM
		(
			SELECT name as DB, state_desc as state, recovery_model_desc as RecoveryModel
			FROM SYS.DATABASES
			WHERE state=0 AND is_read_only=0 AND name not in (/*'model',*/ 'tempdb')
				AND (name NOT LIKE '201%(%)%' and name NOT LIKE 'S201%(%)%')
		) as D
		LEFT JOIN 
			(SELECT DBNAME, Kind
			 FROM	info.vGetAllBackConf
			 WHERE Kind='Full' AND WeekDay IS NULL
			 GROUP BY DBNAME, Kind) BF
			ON D.DB=BF.DBName
		LEFT JOIN 
			(SELECT DBNAME, Kind
			 FROM	info.vGetAllBackConf
			 WHERE Kind='Full' AND WeekDay IS NOT NULL
			 GROUP BY DBNAME, Kind) BFW
			ON D.DB=BFW.DBName
		LEFT JOIN 
			(SELECT DBNAME, Kind
			 FROM	info.vGetAllBackConf
			 GROUP BY DBNAME, Kind) BD
			ON D.DB=BD.DBName AND BD.Kind='Diff'
		LEFT JOIN 
			(SELECT DBNAME, Kind
			 FROM	info.vGetAllBackConf
			 GROUP BY DBNAME, Kind) BL
			ON D.DB=BL.DBName AND BL.Kind='Log'
GO
PRINT N'Creating Function [db_maintenance].[uf_CheckTabList_US]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO

	/* =============================================
	-- Author:		Ivanov Andrei
	-- Create date: 02.06.2016
	-- Description:	This function gets the PolicyScan for Update Statistics for the specified table and statistics.
				
	-- ============================================= */
	CREATE FUNCTION db_maintenance.uf_CheckTabList_US
	(
		@Tab NVARCHAR(1000), --Table name in []
		@Stat NVARCHAR(1000) --Stat name in []
	)
	RETURNS NVARCHAR(100)
	AS
	BEGIN
		declare @Return NVARCHAR(100);
		select @Return=PolicyScan 
		from db_maintenance.TabList_US
		where Tab=@Tab AND Stat=@Stat;
		IF @Return is null
			select @Return=PolicyScan 
			from db_maintenance.TabList_US
			where Tab=@Tab AND Stat IS NULL;
		return @Return;
	END
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating Function [info].[uf_FormatTime]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 01.12.2017
	-- Description:	Эта функция вернёт форматированную строку (время) в днях, часах, минутах, секунда. Входной параметр число - секунды
				
	-- Update:

	-- ============================================= */
	CREATE FUNCTION info.uf_FormatTime
	(
		@seconds bigint
	)
	RETURNS varchar(20)
	AS
	BEGIN
		declare @Return varchar(20);
		--проверка:
		--select @seconds/(3600*24) as dd,(@seconds%(3600*24))/3600 as hh,((@seconds%(3600*24))%3600) / 60 as mm, @seconds % 60 as ss

		SET @Return=CASE WHEN @seconds is null THEN '' ELSE 
			CASE 
				WHEN @seconds/(3600*24)>=1 THEN
					RIGHT (CONVERT(varchar(6), @seconds/(3600*24)),3)+ 'd:'
				ELSE ''
			END 
			+ RIGHT ('0' + CONVERT(varchar(6), (@seconds%(3600*24))/3600),2)
			+ ':' + RIGHT('0' + CONVERT(varchar(2), ((@seconds%(3600*24))%3600) / 60), 2)
			+ ':' + RIGHT('0' + CONVERT(varchar(2), @seconds % 60), 2)
		END;
	
		return @Return
	END
GO
PRINT N'Creating Function [info].[uf_GetWeekDay]...';


GO

/* =============================================
-- Author:		Андрей Иванов (sqland1c)
-- Create date: 17.02.2014
-- Description:	Эта функция возвращает день недели для заданной даты.
				
-- Update:

-- ============================================= */
CREATE FUNCTION info.uf_GetWeekDay
(
	@date datetime
)
RETURNS int
AS
BEGIN
	declare @Return tinyint=0;
	if @@DATEFIRST=7
	begin
		set @Return = datepart(weekday,@date) - 1;
		if @Return=0
			set @Return=7
	end
	else if @@DATEFIRST=1
		set @Return= datepart(weekday,@date);
	
	return @Return
END
GO
PRINT N'Creating Function [info].[uf_CheckFile]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 04.02.2014
	-- Description:	Эта функция проверяет наличие (существование) указанного файла.
					Возвращает 1, если указанный файл существует
					Параметр @File - полный путь к файлу, который нужно проверить.
					Обычно, эта	функция может использоваться для проверки наличия файлов бэкапов.		
		Update:		11.01.2016 (1.10)
					Алгоритм проверки изменен: теперь используется проверка через xp_cmddhell
					вместо xp_fileexist. И теперь эта функция проверяет наличие не только файла, 
					но и каталога!
					10.02.2017 (1.105)
					Для команды DIR добавлен параметр /b - выводить только имена файлов/каталогов.
					Также путь к файлу(каталогу) теперь указывается в кавычках "" (защита от пробелов).
	-- ============================================= */
	CREATE FUNCTION [info].[uf_CheckFile]
	(
		@File nvarchar(500)
	)
	RETURNS int
	AS
	BEGIN
		declare @Return int=0;
		SET @File='DIR /b "'+@File+'"';
		EXEC @Return = master.dbo.xp_cmdshell @File, NO_OUTPUT
	
		return CASE @Return WHEN 0 THEN 1 ELSE 0 END
	END
GO
PRINT N'Creating Function [info].[uf_GetBackConf]...';


GO

/* =============================================
-- Author:		Андрей Иванов (sqland1c)
-- Create date: 25.04.2014
-- Description:	Эта функция получает наиболее подходящие настройки для Резервного копирования из БД 
				В зависимости от Базы, типа бэкапа и текущей даты это значение может быть различным.
				
-- Update:		31.07.2014 (1.1)
				Добавлен алгоритм, который учитывает, что мог быть сделан Полный бэкап без учёта дня месяца и дня недели (это параметр @OnlyFull в ХП usp_RunBack).

-- ============================================= */
CREATE FUNCTION info.uf_GetBackConf
(
	@DB NVARCHAR(100),	--Database Name
	@BT VARCHAR(4), --BackupType
	@DD DATETIME2(2) --Date of Backup
)
RETURNS @ReturnTable TABLE (
	LocalDir NVARCHAR(300), 
	NetDir NVARCHAR(300),
	LocalDays int,
	NetDays int
)
AS
BEGIN
	DECLARE @WeekDay TINYINT, @MonthDay TINYINT;
	DECLARE @T TABLE (LocalDir NVARCHAR(300), NetDir NVARCHAR(300), LocalDays INT, NetDays INT, Ord tinyint);

	SET @WeekDay=info.uf_GetWeekDay(@DD);
	SET @MonthDay=DATEPART ( DAY , @DD );

	INSERT INTO @T (LocalDir, NetDir, LocalDays, NetDays, Ord)
	SELECT TOP 1 LocalDir, NetDir, LocalDays, NetDays, 1 as Ord
	FROM backups.BackConfWeekly
	WHERE Kind=@BT and DBName=@DB and MonthDay=@MonthDay
	UNION ALL
	SELECT TOP 1 LocalDir, NetDir, LocalDays, NetDays, 2 as Ord
	FROM backups.BackConfWeekly
	WHERE Kind=@BT and DBName=@DB and WeekDay=@WeekDay
	UNION ALL
	SELECT	TOP 1 LocalDir, NetDir, LocalDays, NetDays, 3 as Ord
	FROM	backups.BackConf
	WHERE	DBName = @DB AND Kind = @BT;

	--Новый алгоритм (только для Полных бэкапов!): если использован параметр @OnlyFull в ХП usp_RunBack и стандартные настройки бэкапов не были найдены
	--тогда нужно найти подходящие настройки для Full из таблицы BackConfWeekly без учета дня месяца и дня недели!
	IF NOT EXISTS (SELECT LocalDir FROM  @T WHERE LocalDir IS NOT NULL) AND @BT='Full'
	BEGIN
		INSERT INTO @T (LocalDir, NetDir, LocalDays, NetDays, Ord)
		SELECT TOP 1 LocalDir, NetDir, LocalDays, NetDays, 1 AS Ord
		FROM backups.BackConfWeekly
		WHERE Kind='Full' and DBName=@DB and MonthDay BETWEEN 1 AND 31
		UNION ALL
		SELECT TOP 1 LocalDir, NetDir, LocalDays, NetDays, 2 AS Ord
		FROM backups.BackConfWeekly
		WHERE Kind='Full' and DBName=@DB and WeekDay BETWEEN 1 AND 7;
	END;

	INSERT @ReturnTable (LocalDir, NetDir, LocalDays, NetDays)
	SELECT LocalDir, NetDir, LocalDays, NetDays
	FROM @T
	WHERE Ord=(SELECT MIN(Ord) FROM @T) ;

	RETURN;
END
GO
PRINT N'Creating Procedure [adt].[usp_mail_newdb]...';


GO
/* =============================================
-- Author:		Андрей Иванов (sqland1c)
-- Create date: 27.04.2014 (1.000)
-- Description: 
-- Update:		Эта процедура используется для уведомлений по эл.почте при создании новой базы данных!
				
				
-- ============================================= */
create procedure [adt].[usp_mail_newdb]
	@dbname nvarchar(2000),
	@tt datetime2(2),
	@login nvarchar(600),
	@hostname nvarchar(300)=null,
	@program nvarchar(300)=null,
	@sqlcommand nvarchar(max)=''
as
begin
	set nocount on;
	declare @strsubject varchar(100),@dbowner nvarchar(200),@StrErr NVARCHAR(3000);
	
	begin try
		select @strsubject='New database detected on ' + @@SERVERNAME;
		select @dbowner=suser_sname(owner_sid) from sys.databases where name=@dbname;

		declare @tableHTML  nvarchar(max);
		set @tableHTML =
			N'<H1>Create new database on - ' + @@SERVERNAME +'</H1>' +
			N'<table border="1">' +
			N'<tr><th>Create date&nbsp;&nbsp;&nbsp;</th>'+
			N'<th>DB Name&nbsp;&nbsp;&nbsp;</th><th>Creator&nbsp;&nbsp;&nbsp;</th>' +
			N'<th>Owner&nbsp;&nbsp;&nbsp;</th>' +
			N'<th>Hostname&nbsp;&nbsp;&nbsp;</th>' +
			N'<th>Program&nbsp;&nbsp;&nbsp;</th>' +
			N'<th>SQL command&nbsp;&nbsp;&nbsp;</th></tr>' +
			CAST ( ( SELECT td = @tt, '',
							td = @dbname, '',
							td = @login, '',
							td = coalesce(@dbowner,''), '',
							td = coalesce(@hostname,''), '',
							td = coalesce(@program,''), '',
							td = coalesce(@sqlcommand,'') 
						FOR XML PATH('tr'), TYPE 
			) AS NVARCHAR(MAX) ) +
			N'</table>' ;

			EXEC msdb.dbo.sp_send_dbmail
			--@from_address='test@test.com',
			@recipients='dba-info@ntsmail.ru',
			@subject = @strsubject,
			@body = @tableHTML,
			@body_format = 'HTML' ,
			@profile_name='sql-info'
	end try
	begin catch
		SET @StrErr=N'Ошибка при отправке уведомления через e-mail, процедура [adt].[usp_mail_newdb]. Имя БД: ['+@dbname+']; создатель: ['+@login+'], время события(tt): ['+convert(varchar(30),@tt,120)+']; текущий suser_name: ['+cast(suser_name() as nvarchar(500))+/*']; текущий suser_Sname: ['+cast(suser_sname() as nvarchar(500))+*/']. Текст ошибки: '+ERROR_MESSAGE();
				--В этом случае не будем заканчивать Диалог принудительно, чтобы другие бэкапы были выполнены до конца!
				--Просто пишем ошибку с подробностями в журнал SQL Server (через print) и заканчиваем выполнения (break):
		PRINT(@StrErr);
	end catch
end
GO
PRINT N'Creating Procedure [adt].[usp_mail_eventdb]...';


GO
/* =============================================
-- Author:		Андрей Иванов (sqland1c)
-- Create date: 14.11.2018 (1.000)
-- Description: 
-- Update:		Эта процедура используется для уведомлений по эл.почте при создании новой базы данных и при удалении БД!
				
				
-- ============================================= */
create procedure [adt].[usp_mail_eventdb]
	@dbname nvarchar(2000),
	@tt datetime2(2),
	@login nvarchar(600),
	@hostname nvarchar(300)=null,
	@program nvarchar(300)=null,
	@sqlcommand nvarchar(max)='',
	@dropdb bit = 0
as
begin
	set nocount on;
	declare @strsubject varchar(100),@dbowner nvarchar(200),@StrErr NVARCHAR(3000);
	
	begin try
		select @strsubject=case when @dropdb=0 then 'New' else 'DROP' end +' database detected on ' + @@SERVERNAME;
		select @dbowner=suser_sname(owner_sid) from sys.databases where name=@dbname;

		declare @tableHTML  nvarchar(max);
		set @tableHTML =
			N'<H1>'+case when @dropdb=0 then 'Create new' else 'Drop' end + ' database on - ' + @@SERVERNAME +'</H1>' +
			N'<table border="1">' +
			N'<tr><th>Create date&nbsp;&nbsp;&nbsp;</th>'+
			N'<th>DB Name&nbsp;&nbsp;&nbsp;</th><th>Creator&nbsp;&nbsp;&nbsp;</th>' +
			N'<th>Owner&nbsp;&nbsp;&nbsp;</th>' +
			N'<th>Hostname&nbsp;&nbsp;&nbsp;</th>' +
			N'<th>Program&nbsp;&nbsp;&nbsp;</th>' +
			N'<th>SQL command&nbsp;&nbsp;&nbsp;</th></tr>' +
			CAST ( ( SELECT td = @tt, '',
							td = @dbname, '',
							td = @login, '',
							td = coalesce(@dbowner,''), '',
							td = coalesce(@hostname,''), '',
							td = coalesce(@program,''), '',
							td = coalesce(@sqlcommand,'') 
						FOR XML PATH('tr'), TYPE 
			) AS NVARCHAR(MAX) ) +
			N'</table>' ;

			EXEC msdb.dbo.sp_send_dbmail
			--@from_address='test@test.com',
			@recipients='dba-info@ntsmail.ru',
			@subject = @strsubject,
			@body = @tableHTML,
			@body_format = 'HTML' ,
			@profile_name='sql-info'
	end try
	begin catch
		SET @StrErr=N'Ошибка при отправке уведомления через e-mail, процедура [adt].[usp_mail_eventdb]. Имя БД: ['+@dbname+']; создатель: ['+@login+'], время события(tt): ['+convert(varchar(30),@tt,120)+']; текущий suser_name: ['+cast(suser_name() as nvarchar(500))+/*']; текущий suser_Sname: ['+cast(suser_sname() as nvarchar(500))+*/']. Текст ошибки: '+ERROR_MESSAGE();
				--В этом случае не будем заканчивать Диалог принудительно, чтобы другие бэкапы были выполнены до конца!
				--Просто пишем ошибку с подробностями в журнал SQL Server (через print) и заканчиваем выполнения (break):
		PRINT(@StrErr);
	end catch
end
GO
PRINT N'Creating Procedure [anz].[usp_retab_step1]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 22.02.2017 (1.0)
	-- Description:	Эта процедура нужна для проведения подмены боевых таблиц на пустые в процессе обновления базы!
					Реализует первый шаг:
					Шаг 1: "До обновления" - подмена боевых таблиц на пустые.
					Вместо боевой таблицы создается пустая (без индексов).
					Боевая таблица переименуется в *_prod.

	-- Update:		
	-- ============================================= */
	CREATE PROCEDURE anz.usp_retab_step1
		@DB_Name nvarchar(600),	
		@table1c nvarchar(1000),
		@debug bit = 0
	AS
	BEGIN
		--ЧАСТЬ 1 ДО ОБНОВЛЕНИЯ!
		--**********************************************
		--ВНИМАНИЕ! ДО ВЫПОЛНЕНИЯ ЭТОГО СКРИПТА ДОЛЖНЫ БЫТЬ ОСТАНОВЛЕНЫ СЛУЖБЫ 1С (Бой и Фон)!!!
		--**********************************************

		SET NOCOUNT ON;

		--Вывод на экран,Начало процедуры
		declare @spid varchar(30), @login_time varchar(30), @host varchar(100), @host_ip varchar(100),
		@host_Pid varchar(30), @login nvarchar(400), @program nvarchar(600);
	
		select top 1 
			@spid=cast(a.session_id as varchar(30)), 
			@login_time=convert(varchar(30),a.login_time,126), 
			@host=a.host_name, 
			@host_pid=a.host_process_id, 
			@host_ip=b.client_net_address,
			@login=a.login_name,
			@program=a.program_name
		from sys.dm_exec_sessions a , sys.dm_exec_connections b 
		where a.session_id=b.session_id and a.session_id=@@SPID;

		PRINT(' <<< Запуск процедуры anz.usp_retab_step1. tt='+convert(varchar(30),sysdatetime(),126));

		PRINT('Информации о сессии: SPID='+@spid+'; Login=['+@login+']; LoginTime='+@login_time+'; HostName='+@host+'; HostIP='+@host_ip+'; HostProcessID='+@host_pid+'; Program=['+@program+'];');

		--Проверка БД:
		IF DB_ID(@DB_Name) IS NULL
		BEGIN
			PRINT('НЕ НАЙДЕНА БАЗА ДАННЫХ : '+@DB_Name);
			PRINT ('Укажите верное имя БД в параметре @DB_Name');
			PRINT(' >>> Завершение процедуры anz.usp_retab_step1. tt='+convert(varchar(30),sysdatetime(),126));
			RETURN -1;
		END

		declare @tt datetime2(2),@tt_end datetime2(2),@elapsed_format varchar(20);
		declare @tablesql nvarchar(600);
		declare @StrErr nvarchar(2000);
		declare @tt_str varchar(60);
		declare @sqlstr nvarchar(4000),@paramsstr nvarchar(800);
		set @tt=sysdatetime();
		set @tt_str=replace(convert(varchar(60),@tt,126),' ','_');
		set @tt_str=replace(@tt_str,'-','');
		set @tt_str=replace(@tt_str,':','');
		--print @tt_str;

		set @sqlstr=N'use ['+@DB_Name+']; select @tablesql_OUT=TABLE_NAME from INFORMATION_SCHEMA.VIEW_TABLE_USAGE WHERE VIEW_NAME = @table1c_IN ;';
		set @paramsstr='@table1c_IN nvarchar(1000), @tablesql_OUT nvarchar(600) OUT';
		exec sp_executesql
			@stmt=@sqlstr,
			@params=@paramsstr,
			@table1c_IN=@table1c,
			@tablesql_OUT=@tablesql OUT;

		IF @tablesql is not null
		BEGIN
			--Проверка: существует ли таблица *_prod.
			--Если существует проверим сколько в ней строк и индексов...
			declare @Tname_prod nvarchar(800);
			set @Tname_prod=QUOTENAME(@DB_Name)+'.[dbo].'+QUOTENAME(@tablesql+CASE WHEN @tablesql LIKE '%#_prod' ESCAPE '#' THEN '' ELSE '_prod' END);
			IF OBJECT_ID(@Tname_prod) IS NOT NULL
			BEGIN
				declare @prod_cnt bigint;
				set @sqlstr=N'select @prod_cnt_OUT=count_big(*) from '+@Tname_prod;
				set @paramsstr='@prod_cnt_OUT bigint OUT';
				exec sp_executesql
					@stmt=@sqlstr,
					@params=@paramsstr,
					@prod_cnt_OUT=@prod_cnt OUT;
				IF @prod_cnt>0 
				BEGIN
					PRINT('Таблица '+@Tname_prod+' уже существует. Количество_строк: '+cast(@prod_cnt as varchar(36)));
					PRINT('Возможные варианты: для таблицы 1С ['+@table1c+'] уже выполнили эту процедуру! Теперь нужно выполнить процедуру anz.usp_retab_step2 для обратной замены таблиц! Обратитесь к администратору БД, если возникли трудности!');
					PRINT(' >>> Завершение процедуры anz.usp_retab_step1. tt='+convert(varchar(30),sysdatetime(),126));
					RETURN -2;
				END
			END
			--Переименуем боевую таблицу в _prod
			set @sqlstr='use ['+@DB_Name+'];
				if object_id(''[dbo].['+@tablesql+'_prod]'') is not null
					exec sp_rename @objname = '''+@tablesql+'_prod'' ,  @newname =  '''+@tablesql+'_archive_prod_'+@tt_str+''' ,
					@objtype = ''object'' ;
				exec sp_rename @objname = '''+@tablesql+''' ,  @newname =  '''+@tablesql+'_prod'' ,
					@objtype = ''object'' ;
			'
			IF @debug=1
			BEGIN
				PRINT '/* Переименуем боевую таблицу в _prod */';
				print @sqlstr;
			END
			ELSE
			BEGIN TRY
				set @tt=SYSDATETIME() ;
				PRINT 'Попытка: меняем имя боевой таблицы ['+@tablesql+'] >>> ['+@tablesql+'_prod]';
				EXEC (@sqlstr);
				set @tt_end=SYSDATETIME() ;
				set @elapsed_format=CAST(DATEADD(second,(datediff(second,@tt,@tt_end)), CAST('00:00:00' AS TIME(0))) as VARCHAR(20));
				PRINT 'Выполнено ['+@elapsed_format+']: изменено имя боевой таблицы ['+@tablesql+'_prod]';
			END TRY
			BEGIN CATCH
				set @StrErr='Ошибка при изменении имени боевой таблицы через процедуру [sp_rename]! Текст ошибки: '+COALESCE(ERROR_MESSAGE(),'null *Error message is not defined');
				RAISERROR(@StrErr,11,1) WITH LOG
			END CATCH

			--Создаём пустую копию боевой таблицы (и называем её как боевая)
			set @sqlstr='use ['+@DB_Name+'];
				SELECT *
				INTO [dbo].['+@tablesql+']
				FROM [dbo].['+@tablesql+'_prod]
				WHERE 1=0;
			';
			IF @debug=1
			BEGIN
				PRINT '/* Создаём пустую копию боевой таблицы (и называем её как боевая) */';
				print @sqlstr;
			END
			ELSE
			BEGIN
				BEGIN TRY
					set @tt=SYSDATETIME() ;
					PRINT 'Попытка: создаём пустую копию ['+@tablesql+'] ';
					EXEC (@sqlstr);
					set @tt_end=SYSDATETIME() ;
					set @elapsed_format=CAST(DATEADD(second,(datediff(second,@tt,@tt_end)), CAST('00:00:00' AS TIME(0))) as VARCHAR(20));
					PRINT 'Выполнено ['+@elapsed_format+']: создана пустая копия ['+@tablesql+']';
				END TRY
				BEGIN CATCH
					set @StrErr='Ошибка при создании пустой копии боевой таблицы (select * from ... where 1=0)! Текст ошибки: '+COALESCE(ERROR_MESSAGE(),'null *Error message is not defined');
					RAISERROR(@StrErr,11,1) WITH LOG
				END CATCH
			END
		END;
		ELSE
		BEGIN
			PRINT ('ТАБЛИЦА ['+@table1c+'] В SQL НЕ НАЙДЕНА!!!');
			PRINT ('Укажите верное имя таблицы в параметре @Table1C');
		END
		PRINT(' >>> Завершение процедуры anz.usp_retab_step1. tt='+convert(varchar(30),sysdatetime(),126));
	END
GO
PRINT N'Creating Procedure [anz].[usp_retab_step2]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 22.02.2017 (1.0)
	-- Description:	Эта процедура нужна для обратной подмены боевых таблиц в процессе обновления базы!
					Реализует второй шаг:
					Шаг 2: "После обновления" - возврат боевых таблиц в бой. Перенос изменений в столбцах.
					Переносятся новые столбцы на боевую таблицу.
					Пустая таблица (с именем боевой) переименуется в *_empty
					Боевая таблица (*_prod) возвращается в бой.
					Переносятся новые индексы на боевую таблицу.
	-- Update:		
	-- ============================================= */
	CREATE PROCEDURE anz.usp_retab_step2
		@DB_Name nvarchar(600),	
		@table1c nvarchar(1000),
		@debug bit = 0
	AS
	BEGIN

		--ЧАСТЬ 2 - ПОСЛЕ Обновления
		--**********************************************
		--ВНИМАНИЕ! Этот скрипт нужно выполнить после завершения обновления в 1С И ДО запуска служб 1С (фон и бой)!!!
		--**********************************************

		SET NOCOUNT ON;

			--Вывод на экран,Начало процедуры
		declare @spid varchar(30), @login_time varchar(30), @host varchar(100), @host_ip varchar(100),
		@host_Pid varchar(30), @login nvarchar(400), @program nvarchar(600);
	
		select top 1 
			@spid=cast(a.session_id as varchar(30)), 
			@login_time=convert(varchar(30),a.login_time,126), 
			@host=a.host_name, 
			@host_pid=a.host_process_id, 
			@host_ip=b.client_net_address,
			@login=a.login_name,
			@program=a.program_name
		from sys.dm_exec_sessions a , sys.dm_exec_connections b 
		where a.session_id=b.session_id and a.session_id=@@SPID;

		PRINT(' <<< Запуск процедуры anz.usp_retab_step2. tt='+convert(varchar(30),sysdatetime(),126));

		PRINT('Информации о сессии: SPID='+@spid+'; Login=['+@login+']; LoginTime='+@login_time+'; HostName='+@host+'; HostIP='+@host_ip+'; HostProcessID='+@host_pid+'; Program=['+@program+'];');


		--Проверка БД:
		IF DB_ID(@DB_Name) IS NULL
		BEGIN
			PRINT('НЕ НАЙДЕНА БАЗА ДАННЫХ : '+@DB_Name);
			PRINT ('Укажите верное имя БД в параметре @DB_Name');
			PRINT(' >>> Завершение процедуры anz.usp_retab_step2. tt='+convert(varchar(30),sysdatetime(),126));
			RETURN -1;
		END

		declare @StrErr nvarchar(2000);
		declare @sqlstr nvarchar(max),@sqlstr2 nvarchar(max);
		declare @tt datetime2(2),@tt_end datetime2(2),@elapsed_format varchar(20), @tt_str varchar(60);
		set @tt=sysdatetime();
		set @tt_str=replace(convert(varchar(60),@tt,120),' ','_');
		set @tt_str=replace(@tt_str,'-','');
		set @tt_str=replace(@tt_str,':','');
		--print @tt_str;

		declare @Tname nvarchar(600), @paramsstr nvarchar(800);
	
		set @sqlstr='use ['+@DB_Name+']; select @tablesql_OUT=REPLACE(TABLE_NAME,''_prod'','''') from INFORMATION_SCHEMA.VIEW_TABLE_USAGE WHERE VIEW_NAME = @table1c_IN ;';
		set @paramsstr='@table1c_IN nvarchar(1000), @tablesql_OUT nvarchar(600) OUT';
		exec sp_executesql
			@stmt=@sqlstr,
			@params=@paramsstr,
			@table1c_IN=@table1c,
			@tablesql_OUT=@Tname OUT;


		IF @Tname IS NOT NULL
		BEGIN
			--Проверка: существует ли таблица *_prod:
			declare @Tname_prod nvarchar(800);
			set @Tname_prod=QUOTENAME(@DB_Name)+'.[dbo].'+QUOTENAME(@Tname+'_prod');
			IF OBJECT_ID(@Tname_prod) IS NULL
			BEGIN
				PRINT('НЕ НАЙДЕНА ТАБЛИЦА : '+@Tname_prod);
				PRINT('Возможные варианты: неправильно указано имя таблицы 1С, не выполнена процедура anz.usp_retab_step1, или процедура anz.usp_retab_step2 запущена повторно. Обратитесь к Администратору БД, если возникли трудности!');
				PRINT(' >>> Завершение процедуры anz.usp_retab_step2. tt='+convert(varchar(30),sysdatetime(),126));
				RETURN -2;
			END	

			--ИЗМЕНЕНИЯ В СТОЛБЦАХ
			--в таблицу *_prod добавить новый столбец из *
			--также учитываем изменения в типах

			if object_id('tempdb.dbo.#tmp_clmns') is not null
				drop table #tmp_clmns;
			create table #tmp_clmns(ColumnName nvarchar(600), cmd_SQL nvarchar(max));
			SET @sqlstr='use ['+@DB_Name+'];
			INSERT INTO #tmp_clmns(ColumnName,cmd_SQL)
			SELECT c_new.name as ColumnName,
				CASE 
					WHEN c_prod.column_id IS NULL THEN ''ALTER TABLE [dbo].['+@Tname+'_prod] ADD [''+c_new.name+''] ''+c_new.type+c_new.type_length+c_new.ColNull+c_new.ColDef+'';''
					ELSE ''ALTER TABLE [dbo].['+@Tname+'_prod] ALTER COLUMN [''+c_new.name+''] ''+c_new.type+c_new.type_length+c_prod.ColNull+'';''
				END as cmd_SQL
			FROM
				(select c.name,c.column_id,ct.name as type,
					CASE 
							WHEN ct.name like ''n%char'' THEN ''(''+CAST(c.max_length/2 as varchar(30))+'')''
							WHEN ct.name IN (''char'',''varchar'',''binary'') THEN ''(''+CAST(c.max_length as varchar(30))+'')''
							WHEN ct.name like ''numeric'' THEN ''(''+CAST(c.precision as varchar(30))+'',''+CAST(c.scale as varchar(30))+'')''
							ELSE ''''
						END AS type_length,
					CASE 
						WHEN c.is_nullable=0 THEN '' NOT NULL ''
						ELSE '' NULL ''
					END AS ColNull
				 from sys.columns c inner join sys.types ct on c.user_type_id=ct.user_type_id  where object_id=OBJECT_ID('''+@Tname+'_prod'')) c_prod
			FULL OUTER JOIN 
				(select c.name,c.column_id, ct.name as type, 
					CASE 
						WHEN ct.name like ''n%char'' THEN ''(''+CAST(c.max_length/2 as varchar(30))+'')''
						WHEN ct.name IN (''char'',''varchar'',''binary'') THEN ''(''+CAST(c.max_length as varchar(30))+'')''
						WHEN ct.name like ''numeric'' THEN ''(''+CAST(c.precision as varchar(30))+'',''+CAST(c.scale as varchar(30))+'')''
						ELSE ''''
					END AS type_length,
					CASE 
							WHEN c.is_nullable=1 THEN ''''
							WHEN ct.name like ''date%'' THEN '' default ''''1753-01-01 00:00:00.000'''' ''
							WHEN ct.name like ''binary'' THEN '' default 0x0 ''
							WHEN ct.name like ''%char'' THEN '' default '''''''' ''
							WHEN ct.name like ''%int'' OR ct.name in (''numeric'', ''bit'') THEN '' default 0 ''
							ELSE ''''
					END AS ColDef,
					CASE 
						WHEN c.is_nullable=0 THEN '' NOT NULL ''
						ELSE '' NULL ''
					END AS ColNull
						from sys.columns c
						inner join sys.types ct
						on c.user_type_id=ct.user_type_id
					where object_id=OBJECT_ID('''+@Tname+''')
			)c_new
				ON c_prod.name=c_new.name
			WHERE
				(c_prod.column_id IS NULL OR (c_prod.type<>c_new.type or c_prod.type_length<>c_new.type_length))
				AND OBJECT_ID('''+@Tname+''') IS NOT NULL;
			';
			EXEC(@sqlstr);

			IF EXISTS (select top 1 * from #tmp_clmns)
			BEGIN
				IF @debug=1
				BEGIN
					PRINT '/* ИЗМЕНЕНИЯ В СТОЛБЦАХ ::*/';
				END
			
					declare @c_name nvarchar(200), @c_sqlcmd nvarchar(2000);
					declare C CURSOR FOR
					select * from #tmp_clmns;
					OPEN C;
					FETCH NEXT FROM C INTO @c_name, @c_sqlcmd;
					WHILE @@FETCH_STATUS=0
					BEGIN
						set @c_sqlcmd='use ['+@DB_Name+'];
						'+@c_sqlcmd;

						IF @debug=1
						BEGIN 
							PRINT @c_sqlcmd;
						END
						ELSE 
						BEGIN
							BEGIN TRY
								set @tt=SYSDATETIME() ;
								PRINT 'Попытка: обновляем столбец ['+@c_name+'] на боевой таблице ['+@Tname+'_prod]';
								EXEC(@c_sqlcmd);
								set @tt_end=SYSDATETIME() ;
								set @elapsed_format=CAST(DATEADD(second,(datediff(second,@tt,@tt_end)), CAST('00:00:00' AS TIME(0))) as VARCHAR(20));
								PRINT 'Выполнено ['+@elapsed_format+']: обновлён столбец ['+@c_name+'] на боевой таблице ['+@Tname+'_prod]';
							END TRY
							BEGIN CATCH
								set @StrErr='Ошибка при обновлении столбца ['+@c_name+'] на боевой таблице ['+@Tname+'_prod]! Текст ошибки: '+COALESCE(ERROR_MESSAGE(),'null *Error message is not defined');
								RAISERROR(@StrErr,11,1) WITH LOG
								set @StrErr='Возникла критическая ошибка! Сохраните весь Вывод в текстовый файл и срочно обратитесь к Администратору БД!';
								RAISERROR(@StrErr,11,1) WITH LOG
								PRINT(' >>> Завершение процедуры anz.usp_retab_step2. tt='+convert(varchar(30),sysdatetime(),126));
								RETURN -3;
							END CATCH
						END
						FETCH NEXT FROM C INTO @c_name, @c_sqlcmd;
					END
					CLOSE C;
					DEALLOCATE C;
			
			END
			ELSE
			BEGIN
				PRINT ('Изменений в столбцах не обнаружено!');
			END

				--Перенос новых НЕкластерных индексов в бой!:
			if object_id('tempdb.dbo.#tmp_idxs') is not null
				drop table #tmp_idxs;
			create table #tmp_idxs(DB nvarchar(400), TableName nvarchar(600), index_create_statement nvarchar(max), index_id int, index_name nvarchar(600));
			SET @sqlstr='use ['+@DB_Name+'];
			declare @t1 nvarchar(600), @t2 nvarchar(600);
			select @t1='''+@Tname+'_prod'', @t2='''+@Tname+''';
		
			;with src1 as(
				select OBJECT_NAME(object_id) as TableName, count(*) over (partition by object_id) as Index_cnt, name as IndexName, index_id as IndexID, type as IndexType
				from sys.indexes 
				where object_id=OBJECT_ID(@t1) 
					and index_id>1 
					and name not like ''_Add%''
				--order by name;
			),
			src2 as(
				select OBJECT_NAME(object_id) as TableName, count(*) over (partition by object_id) as Index_cnt, name as IndexName, index_id as IndexID, type as IndexType
				from sys.indexes 
				where object_id=OBJECT_ID(@t2) 
					and index_id>1 
					and name not like ''_Add%''
				--order by name;
			)
			INSERT INTO #tmp_idxs (DB, TableName, index_create_statement,index_id,index_name)
			SELECT 
				DB_NAME() AS DB,
				sc.name + ''.'' + @t1 AS TableName,
				CASE si.index_id WHEN 0 THEN ''/* No create statement (Heap) */''
				ELSE 
					CASE is_primary_key WHEN 1 THEN
						''ALTER TABLE '' + QUOTENAME(sc.name) + ''.'' + QUOTENAME(@t1) + '' ADD CONSTRAINT '' + QUOTENAME(si.name) + '' PRIMARY KEY '' +
							CASE WHEN si.index_id > 1 THEN ''NON'' ELSE '''' END + ''CLUSTERED ''
						ELSE ''CREATE '' + 
							CASE WHEN si.is_unique = 1 then ''UNIQUE '' ELSE '''' END +
							CASE WHEN si.index_id > 1 THEN ''NON'' ELSE '''' END + ''CLUSTERED '' +
							''INDEX '' + QUOTENAME(si.name) + '' ON '' + QUOTENAME(sc.name) + ''.'' + QUOTENAME(@t1) + '' ''
					END +
					/* key def */ ''('' + key_definition + '')'' +
					/* includes */ CASE WHEN include_definition IS NOT NULL THEN 
						'' INCLUDE ('' + include_definition + '')''
						ELSE ''''
					END +
					/* filters */ CASE WHEN filter_definition IS NOT NULL THEN 
						'' WHERE '' + filter_definition ELSE ''''
					END +
					/* with clause - compression goes here */
					CASE WHEN row_compression_partition_list IS NOT NULL OR page_compression_partition_list IS NOT NULL 
						THEN '' WITH ('' +
							CASE WHEN row_compression_partition_list IS NOT NULL THEN
								''DATA_COMPRESSION = ROW '' + CASE WHEN psc.name IS NULL THEN '''' ELSE + '' ON PARTITIONS ('' + row_compression_partition_list + '')'' END
							ELSE '''' END +
							CASE WHEN row_compression_partition_list IS NOT NULL AND page_compression_partition_list IS NOT NULL THEN '', '' ELSE '''' END +
							CASE WHEN page_compression_partition_list IS NOT NULL THEN
								''DATA_COMPRESSION = PAGE '' + CASE WHEN psc.name IS NULL THEN '''' ELSE + '' ON PARTITIONS ('' + page_compression_partition_list + '')'' END
							ELSE '''' END
						+ '')''
						ELSE ''''
					END +
					/* ON where? filegroup? partition scheme? */
					'' ON '' + CASE WHEN psc.name is null 
						THEN ISNULL(QUOTENAME(fg.name),'''')
						ELSE psc.name + '' ('' + partitioning_column.column_name + '')'' 
						END
					+ '';''
				END AS index_create_statement,
				si.index_id,
				si.name AS index_name
			FROM 
			(
				select s2.TableName, s2.IndexName, s2.IndexID, s2.IndexType
					--, s1.IndexID as IndexID_old
				from src2 as s2
				left join src1 as s1
					on s2.IndexName=s1.IndexName
				where
					s1.IndexName IS NULL
					--OR s2.IndexID<>s1.IndexID
			) src_fin';
			set @sqlstr2='
			INNER JOIN sys.indexes AS si
				ON src_fin.IndexID=si.index_id AND src_fin.TableName=OBJECT_NAME(si.object_id)
			JOIN sys.tables AS t ON si.object_id=t.object_id
			JOIN sys.schemas AS sc ON t.schema_id=sc.schema_id
			LEFT JOIN sys.dm_db_index_usage_stats AS stat ON 
				stat.database_id = DB_ID() 
				and si.object_id=stat.object_id 
				and si.index_id=stat.index_id
			LEFT JOIN sys.partition_schemes AS psc ON si.data_space_id=psc.data_space_id
			LEFT JOIN sys.partition_functions AS pf ON psc.function_id=pf.function_id
			LEFT JOIN sys.filegroups AS fg ON si.data_space_id=fg.data_space_id
			/* Key list */ OUTER APPLY ( SELECT STUFF (
				(SELECT '', '' + QUOTENAME(c.name) +
					CASE ic.is_descending_key WHEN 1 then '' DESC'' ELSE '''' END
				FROM sys.index_columns AS ic 
				JOIN sys.columns AS c ON 
					ic.column_id=c.column_id  
					and ic.object_id=c.object_id
				WHERE ic.object_id = si.object_id
					and ic.index_id=si.index_id
					and ic.key_ordinal > 0
				ORDER BY ic.key_ordinal FOR XML PATH(''''), TYPE).value(''.'', ''NVARCHAR(MAX)''),1,2,'''')) AS keys ( key_definition )
			/* Partitioning Ordinal */ OUTER APPLY (
				SELECT MAX(QUOTENAME(c.name)) AS column_name
				FROM sys.index_columns AS ic 
				JOIN sys.columns AS c ON 
					ic.column_id=c.column_id  
					and ic.object_id=c.object_id
				WHERE ic.object_id = si.object_id
					and ic.index_id=si.index_id
					and ic.partition_ordinal = 1) AS partitioning_column
			/* Include list */ OUTER APPLY ( SELECT STUFF (
				(SELECT '', '' + QUOTENAME(c.name)
				FROM sys.index_columns AS ic 
				JOIN sys.columns AS c ON 
					ic.column_id=c.column_id  
					and ic.object_id=c.object_id
				WHERE ic.object_id = si.object_id
					and ic.index_id=si.index_id
					and ic.is_included_column = 1
				ORDER BY c.name FOR XML PATH(''''), TYPE).value(''.'', ''NVARCHAR(MAX)''),1,2,'''')) AS includes ( include_definition )
			/* Partitions */ OUTER APPLY ( 
				SELECT 
					COUNT(*) AS partition_count,
					CAST(SUM(ps.in_row_reserved_page_count)*8./1024./1024. AS NUMERIC(32,1)) AS reserved_in_row_GB,
					CAST(SUM(ps.lob_reserved_page_count)*8./1024./1024. AS NUMERIC(32,1)) AS reserved_LOB_GB,
					SUM(ps.row_count) AS row_count
				FROM sys.partitions AS p
				JOIN sys.dm_db_partition_stats AS ps ON
					p.partition_id=ps.partition_id
				WHERE p.object_id = si.object_id
					and p.index_id=si.index_id
				) AS partition_sums
			/* row compression list by partition */ OUTER APPLY ( SELECT STUFF (
				(SELECT '', '' + CAST(p.partition_number AS VARCHAR(32))
				FROM sys.partitions AS p
				WHERE p.object_id = si.object_id
					and p.index_id=si.index_id
					and p.data_compression = 1
				ORDER BY p.partition_number FOR XML PATH(''''), TYPE).value(''.'', ''NVARCHAR(MAX)''),1,2,'''')) AS row_compression_clause ( row_compression_partition_list )
			/* data compression list by partition */ OUTER APPLY ( SELECT STUFF (
				(SELECT '', '' + CAST(p.partition_number AS VARCHAR(32))
				FROM sys.partitions AS p
				WHERE p.object_id = si.object_id
					and p.index_id=si.index_id
					and p.data_compression = 2
				ORDER BY p.partition_number FOR XML PATH(''''), TYPE).value(''.'', ''NVARCHAR(MAX)''),1,2,'''')) AS page_compression_clause ( page_compression_partition_list )
			WHERE 
				si.type IN (/*0,1,*/2) /* heap, clustered, nonclustered */
			OPTION (RECOMPILE);';
			--SELECT(@sqlstr+@sqlstr2);
			EXEC(@sqlstr+@sqlstr2);
			IF NOT EXISTS(select top 1 * from #tmp_idxs)
			BEGIN
				PRINT ('Изменений в индексах не обнаружено!');
			END
			ELSE
			BEGIN
				IF @debug=1
				BEGIN
					PRINT '/* ИЗМЕНЕНИЯ В ИНДЕКСАХ ::*/';
				END
				DECLARE @TableName nvarchar(600),@index_name nvarchar(600), @index_cmd nvarchar(max);
				DECLARE ix CURSOR FOR
				SELECT DISTINCT 
					TableName,index_name, index_create_statement
				FROM #tmp_idxs;
				OPEN ix;
				FETCH NEXT FROM ix INTO @TableName,@index_name, @index_cmd;
				WHILE @@FETCH_STATUS=0
				BEGIN
					set @index_cmd='use ['+@DB_Name+'];
					'+@index_cmd;
					IF @debug=1
					BEGIN
						PRINT('--Перенос индекса '+QUOTENAME(@index_name)+' для таблицы '+QUOTENAME(@TableName));
						PRINT(@index_cmd);
					END
					ELSE
					BEGIN
						BEGIN TRY
							set @tt=SYSDATETIME() ;
							PRINT 'Попытка: добавляем индекс '+QUOTENAME(@index_name)+' на боевую таблицу '+QUOTENAME(@TableName);
							EXEC(@index_cmd);
							set @tt_end=SYSDATETIME() ;
							set @elapsed_format=CAST(DATEADD(second,(datediff(second,@tt,@tt_end)), CAST('00:00:00' AS TIME(0))) as VARCHAR(20));
							PRINT 'Выполнено ['+@elapsed_format+']: добавлен индекс '+QUOTENAME(@index_name)+' на боевую таблицу '+QUOTENAME(@TableName);
						END TRY
						BEGIN CATCH
							set @StrErr='Ошибка при добавлении индекса '+QUOTENAME(@index_name)+' на боевую таблицу '+QUOTENAME(@TableName)+'! Текст ошибки: '+COALESCE(ERROR_MESSAGE(),'null *Error message is not defined');
							RAISERROR(@StrErr,11,1) WITH LOG
							set @StrErr='Возникла критическая ошибка! Сохраните весь Вывод в текстовый файл и срочно обратитесь к Администратору БД!';
								RAISERROR(@StrErr,11,1) WITH LOG
								PRINT(' >>> Завершение процедуры anz.usp_retab_step2. tt='+convert(varchar(30),sysdatetime(),126));
								RETURN -4;
						END CATCH
					END
					FETCH NEXT FROM ix INTO @TableName,@index_name, @index_cmd;
				END
				CLOSE ix;
				DEALLOCATE ix;
			END

			IF @debug=1
			BEGIN
				PRINT ' ';
				PRINT '/* УБИРАЕМ ПУСТУЮ ТАБЛИЦУ В АРХИВ */';
			END
			--Убираем пустые таблицы, они больше не нужны!
			SET @sqlstr='use ['+@DB_Name+'];
					if object_id(''[dbo].['+@Tname+'_empty]'') is not null
						exec sp_rename @objname = '''+@Tname+'_empty'' ,  @newname =  '''+@Tname+'_archive_empty_'+@tt_str+''',
						@objtype = ''object'' ;
					exec sp_rename @objname = '''+@Tname+''' ,  @newname =  '''+@Tname+'_empty'',
						@objtype = ''object'' ;
				';
			IF @debug=1
			BEGIN
				PRINT @sqlstr;
				PRINT ' ';
				PRINT '/* ВЕРНУТЬ ТАБЛИЦЫ В БОЙ */';
			END
			ELSE
			BEGIN 
				BEGIN TRY
					set @tt=SYSDATETIME() ;
					PRINT 'Попытка: меняем имя пустой копии '+QUOTENAME(@Tname)+' >>> ['+@Tname+'_empty]';
					EXEC(@sqlstr);
					set @tt_end=SYSDATETIME() ;
					set @elapsed_format=CAST(DATEADD(second,(datediff(second,@tt,@tt_end)), CAST('00:00:00' AS TIME(0))) as VARCHAR(20));
					PRINT 'Выполнено ['+@elapsed_format+']: изменено имя пустой копии ['+@Tname+'_empty]';
				END TRY
				BEGIN CATCH
					set @StrErr='Ошибка при изменении имени пустой копии через процедуру [sp_rename]! Текст ошибки: '+COALESCE(ERROR_MESSAGE(),'null *Error message is not defined');
					RAISERROR(@StrErr,11,1) WITH LOG
					set @StrErr='Возникла критическая ошибка! Сохраните весь Вывод в текстовый файл и срочно обратитесь к Администратору БД!';
					RAISERROR(@StrErr,11,1) WITH LOG
					PRINT(' >>> Завершение процедуры anz.usp_retab_step2. tt='+convert(varchar(30),sysdatetime(),126));
					RETURN -5;
				END CATCH
			END
			
			--Вернуть таблицы в БОЙ: переименовать *_prod в *
			SET @sqlstr='use ['+@DB_Name+'];
				IF OBJECT_ID('''+@Tname+'_prod'') IS NOT NULL
					exec sp_rename @objname = '''+@Tname+'_prod'' ,  @newname =  '''+@Tname+''' ,
						@objtype = ''object'' ;
			';
			IF @debug=1
			BEGIN
				PRINT @sqlstr;
			END
			ELSE
			BEGIN 
				BEGIN TRY
					set @tt=SYSDATETIME() ;
					PRINT 'Попытка: меняем имя боевой таблицы (обратно) ['+@Tname+'_prod] >>> '+QUOTENAME(@Tname);
					EXEC(@sqlstr);
					set @tt_end=SYSDATETIME() ;
					set @elapsed_format=CAST(DATEADD(second,(datediff(second,@tt,@tt_end)), CAST('00:00:00' AS TIME(0))) as VARCHAR(20));
					PRINT 'Выполнено ['+@elapsed_format+']: изменено имя боевой таблицы (обратно) '+QUOTENAME(@Tname);
				END TRY
				BEGIN CATCH
					set @StrErr='Ошибка при изменении имени боевой таблицы (обратно) через процедуру [sp_rename]! Текст ошибки: '+COALESCE(ERROR_MESSAGE(),'null *Error message is not defined');
					RAISERROR(@StrErr,11,1) WITH LOG
					set @StrErr='Возникла критическая ошибка! Сохраните весь Вывод в текстовый файл и срочно обратитесь к Администратору БД!';
					RAISERROR(@StrErr,11,1) WITH LOG
					PRINT(' >>> Завершение процедуры anz.usp_retab_step2. tt='+convert(varchar(30),sysdatetime(),126));
					RETURN -5;
				END CATCH
			END
		END
		ELSE
		BEGIN
			PRINT ('ТАБЛИЦА ['+@table1c+'] В SQL НЕ НАЙДЕНА!!!');
			PRINT ('Укажите верное имя таблицы в параметре @Table1C');
		END
		PRINT(' >>> Завершение процедуры anz.usp_retab_step2. tt='+convert(varchar(30),sysdatetime(),126));
	END
GO
PRINT N'Creating Procedure [anz].[usp_dyn_check]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 23.10.2017 (1.0)
	-- Description:	Эта процедура нужна для проверки и очистки служебной таблицы dbo.Config в базе 1С!
					Небходима для оказания помощи в обновлении 1С.
					При запуске нужно обязательно указать имя БД в которой проводим обновление.
	-- Update:		
	-- ============================================= */
	CREATE PROCEDURE [anz].[usp_dyn_check]
		@DB_Name nvarchar(600),	
		@debug bit = 0
	AS
	BEGIN

		--**********************************************
		--ВНИМАНИЕ! Этот скрипт нужно выполнять только по согласованию с 1С специалистами, когда они производят обновления 1С!!!
		--**********************************************

		SET NOCOUNT ON;

			--Вывод на экран,Начало процедуры
		declare @spid varchar(30), @login_time varchar(30), @host varchar(100), @host_ip varchar(100),
		@host_Pid varchar(30), @login nvarchar(400), @program nvarchar(600);
	
		select top 1 
			@spid=cast(a.session_id as varchar(30)), 
			@login_time=convert(varchar(30),a.login_time,126), 
			@host=a.host_name, 
			@host_pid=a.host_process_id, 
			@host_ip=b.client_net_address,
			@login=a.login_name,
			@program=a.program_name
		from sys.dm_exec_sessions a , sys.dm_exec_connections b 
		where a.session_id=b.session_id and a.session_id=@@SPID;

		PRINT(' <<< Запуск процедуры [anz].[usp_dyn_check]. tt='+convert(varchar(30),sysdatetime(),126));

		PRINT('Информации о сессии: SPID='+@spid+'; Login=['+@login+']; LoginTime='+@login_time+'; HostName='+@host+'; HostIP='+@host_ip+'; HostProcessID='+@host_pid+'; Program=['+@program+'];');


		--Проверка БД:
		IF DB_ID(@DB_Name) IS NULL
		BEGIN
			PRINT('НЕ НАЙДЕНА БАЗА ДАННЫХ : '+@DB_Name);
			PRINT ('Укажите верное имя БД в параметре @DB_Name');
			PRINT(' >>> Завершение процедуры [anz].[usp_dyn_check]. tt='+convert(varchar(30),sysdatetime(),126));
			RETURN -1;
		END

		declare @StrErr nvarchar(2000);
		declare @sqlstr nvarchar(max),@sqlstr2 nvarchar(max);
		declare @tt datetime2(2),@tt_end datetime2(2),@elapsed_format varchar(20), @tt_str varchar(60);
		set @tt=sysdatetime();
		set @tt_str=replace(convert(varchar(60),@tt,120),' ','_');
		set @tt_str=replace(@tt_str,'-','');
		set @tt_str=replace(@tt_str,':','');
		--print @tt_str;

		set @sqlstr='use ['+@DB_Name+']; 
		IF NOT EXISTS (SELECT TOP 1 [FileName] FROM [dbo].[Config] WHERE [FileName] = ''DynamicallyUpdated'')
		BEGIN
			IF OBJECT_ID(''dbo.Config_cleaned'') IS NOT NULL
				DROP TABLE dbo.Config_cleaned;
			SELECT * INTO dbo.Config_cleaned FROM dbo.Config; 
			IF EXISTS (SELECT TOP 1 [FileName] FROM [dbo].[Config] WHERE [FileName] LIKE ''%dyn%'')
			BEGIN
				DELETE FROM dbo.Config WHERE [FileName] LIKE ''%dyn%'';
				PRINT(''--Очистка таблицы dbo.Config успешно выполнена.'');
			END
			ELSE
			BEGIN
				PRINT(''--Очистка таблицы dbo.Config пропущена по причине: '');
				PRINT(''---Записей "%dyn%" нет в таблице dbo.Config, база: ['+@DB_Name+']'');
			END
		END
		ELSE
		BEGIN
			PRINT(''--Очистка таблицы dbo.Config пропущена по причине: '');
			PRINT(''---Обнаружена запись "DynamicallyUpdated" в таблице dbo.Config, база: ['+@DB_Name+']'');
		END
		';

		IF @debug=1
		BEGIN 
			PRINT @sqlstr;
		END
		ELSE 
		BEGIN
			BEGIN TRY
				EXEC(@sqlstr);
			END TRY
			BEGIN CATCH
				set @StrErr='Ошибка при очистке таблица dbo.Config в базе ['+@DB_Name+']. Текст ошибки: '+COALESCE(ERROR_MESSAGE(),'null *Error message is not defined');
				RAISERROR(@StrErr,11,1) WITH LOG
				set @StrErr='Возникла критическая ошибка! Сохраните весь Вывод в текстовый файл и срочно обратитесь к Администратору БД!';
				RAISERROR(@StrErr,11,1) WITH LOG
				PRINT(' >>> Завершение процедуры [anz].[usp_dyn_check]. tt='+convert(varchar(30),sysdatetime(),126));
				RETURN -2;
			END CATCH
		END
		PRINT(' >>> Завершение процедуры [anz].[usp_dyn_check]. tt='+convert(varchar(30),sysdatetime(),126));
	END
GO
PRINT N'Creating Procedure [awr].[usp_tempusing_do]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 23.03.2018 (1.0)
	-- Description: Процедура для сбора и сохранения в базе sputnik данных по использованию базы TempDB. 
					А также прибивание самых долгих и тяжёлых сессий, которые больше всех используют TempDB.
					Все параметры для прибивания сессий берутся из таблицы config.params в БД sputnik.
	-- Update:		30.03.2018 (1.005)
					Изменён алгоритм определения для прибивания тяжёлых сессий:
					максимум общего использования tempdb это параметр @tempusing_total_gb	
					общее использование tempdb(когда open_tran=0) это параметр @Kill_opentran0_tempusing_gb	
	*/
	CREATE PROCEDURE awr.usp_tempusing_do
	AS
	BEGIN
		set nocount on;
		set QUOTED_IDENTIFIER ON;
		declare @tt datetime2(2)=SYSDATETIME(), @spid smallint,@cmd nvarchar(100);
		declare @kill_enabled bit, @Kill_tempusing_gb numeric(9,0), @Kill_opentran0_tempusing_gb numeric(9,0), @kill_rq_elapsed_sec numeric(9,0), @kill_userinternalusing_gb numeric(9,0),@kill_rowver_tranactive_sec numeric(9,0);
		select @kill_enabled=cast(vl as bit)
		from config.params where obj='awr.tempusing' and pr='kill: enabled';
		select @Kill_tempusing_gb=cast(vl as numeric(9,0))
		from config.params where obj='awr.tempusing' and pr='kill: total tempdb using(Gb)>';
		select @Kill_opentran0_tempusing_gb=cast(vl as numeric(9,0))
		from config.params where obj='awr.tempusing' and pr='kill: opentran=0/total tempdb using(Gb)>';
		select @kill_rq_elapsed_sec=cast(vl as numeric(9,0))
		from config.params where obj='awr.tempusing' and pr='kill: query elapsed(sec)>';
		select @kill_userinternalusing_gb=cast(vl as numeric(9,0))
		from config.params where obj='awr.tempusing' and pr='kill: user+internal using(gb)>';
		select @kill_rowver_tranactive_sec=cast(vl as numeric(9,0))
		from config.params where obj='awr.tempusing' and pr='kill: row-verions tran active (sec)>';
		if object_id('tempdb..#tmp01') is not null
			drop table #tmp01;
		create table #tmp01(
				tt datetime2(2),
				[spid] smallint not null,
				[login_time] datetime not null,
				rq_start_time datetime null,
				user_mb numeric(9,0) null,
				internal_mb numeric(9,0) null,
				sleep_status bit not null,
				rq_elapsed_sec numeric(9,0) null,
				rowver_tran_sec numeric(9,0) null,
				open_tran_flag bit not null,
				kill_flag bit not null
		)
		;with cte01 as (
		select 
			@tt as tt, 
			ss.[spid],ss.[login_time],ss.[rq_start_time],
			ss.[user_mb],ss.[internal_mb], 
			case when ss.[status]='sleeping' then 1 else 0 end as sleep_status,
			ss.[elapsed_sec] as rq_elapsed_sec,
			ver.[tran_active_sec] as [rowver_tran_sec],
			case when ss.[open_tran_cnt]>0 then 1 else 0 end as [open_tran_flag],
			0 as kill_flag
		from info.vtempusing_ss as ss
		left join info.vtempusing_ver as ver
			on ss.spid=ver.spid and ss.[login_time]=ver.[login_time] and ver.[tran_active_sec]>300
		where ss.elapsed_sec>150)
		,cte02 as(
		select 
			@tt as tt, 
			ver.[spid],ver.[login_time],null as [rq_start_time],
			null as [user_mb], null as [internal_mb],
			case when [status]='sleeping' then 1 else 0 end as sleep_status,
			null as rq_elapsed_sec,
			ver.[tran_active_sec] as [rowver_tran_sec],
			case when [open_tran_cnt]>0 then 1 else 0 end as [open_tran_flag],
			0 as kill_flag
		from info.vtempusing_ver as ver
		left join cte01 
			on ver.spid=cte01.spid and ver.[login_time]=cte01.[login_time]
		where [tran_active_sec]>300 and cte01.spid is null
		)
		insert into #tmp01(tt,[spid], [login_time], [rq_start_time],[user_mb],[internal_mb],sleep_status, rq_elapsed_sec, [rowver_tran_sec], open_tran_flag,kill_flag)
		select tt,[spid], [login_time], [rq_start_time],[user_mb],[internal_mb],sleep_status, rq_elapsed_sec, [rowver_tran_sec], open_tran_flag,kill_flag from cte01
		union all
		select tt,[spid], [login_time], [rq_start_time],[user_mb],[internal_mb],sleep_status, rq_elapsed_sec, [rowver_tran_sec], open_tran_flag,kill_flag from cte02;
		declare @tempusing_total_gb numeric(9,0);
		select top 1 @tempusing_total_gb=cast((vl/1024) as numeric(9,0)) from info.vtempusing where pr='total_mb';
		if @kill_enabled=1
		begin
			declare kl cursor for
				select spid 
				from #tmp01
				where 
					(
						(open_tran_flag=0 and @tempusing_total_gb>@Kill_opentran0_tempusing_gb) or @tempusing_total_gb>@Kill_tempusing_gb
					)
					and (
						(rq_elapsed_sec>@kill_rq_elapsed_sec and [user_mb]+[internal_mb]>@kill_userinternalusing_gb*1024)
						or ([rowver_tran_sec]>@kill_rowver_tranactive_sec)
					);
			open kl;
			fetch next from kl into @spid;
			while @@fetch_status=0
			begin
				set @cmd='kill '+cast(@spid as varchar(7));
				exec(@cmd);
				update #tmp01
				set kill_flag=1
				where spid=@spid and kill_flag=0;
				fetch next from kl into @spid;
			end
			close kl;
			deallocate kl;
		end
		insert into awr.tempusing (tt,[spid], [login_time], [rq_start_time],[user_mb],[internal_mb],sleep_status, rq_elapsed_sec, [rowver_tran_sec], open_tran_flag,kill_flag)
		select tt,[spid], [login_time], [rq_start_time],[user_mb],[internal_mb],sleep_status, rq_elapsed_sec, [rowver_tran_sec], open_tran_flag,kill_flag
		from #tmp01;
		if object_id('tempdb..#tmp01') is not null
			drop table #tmp01;	
	END
GO
PRINT N'Creating Procedure [awr].[usp_db_usage_collect]...';


GO

CREATE procedure [awr].[usp_db_usage_collect]
	@dbfilter nvarchar(1000)=null
as
begin
	SET NOCOUNT ON;
	IF OBJECT_ID('Tempdb..#T') IS NOT NULL
		DROP TABLE #T;
	CREATE TABLE #T
		(DB nvarchar(300), CreateDate datetime2(2), 
			UsedType varchar(4), LastUsed datetime2(2), Cnt numeric(19,0));

	declare @DB nvarchar(300);

	declare DB cursor for
	select distinct
		d.[name] AS DB
	from
		sys.databases d
	where
		d.database_id>4
		and d.name<>'sputnik'
		and d.[state]=0
		and (d.name like @dbfilter or @dbfilter is null)
	;

	open DB;
	fetch next from DB into @DB;
	while @@FETCH_STATUS=0
	BEGIN
		INSERT INTO #T (DB, CreateDate , UsedType , LastUsed , Cnt )
		EXEC(N'
			SET NOCOUNT ON;
			USE ['+@DB+'];

			--Затем получаем информацию об обращаениях к таблицам БД!
			IF OBJECT_ID(''tempdb..#T_LastUsed'') IS NOT NULL
				DROP TABLE #T_LastUsed;
			SELECT DISTINCT
				max(coalesce(last_user_seek,''19000101 00:00:00'')) over() as Seek,
				max(coalesce(last_user_scan,''19000101 00:00:00'')) over() as Scan,
				max(coalesce(last_user_lookup,''19000101 00:00:00'')) over() as Lkp,
				max(coalesce(last_user_update,''19000101 00:00:00'')) over() as Upd,
				sum(coalesce(user_seeks,0)) over () as Seek_cnt,
				sum(coalesce(user_scans,0)) over () as Scan_cnt,
				sum(coalesce(user_lookups,0)) over () as Lkp_cnt,
				sum(coalesce(user_updates,0)) over () as Upd_cnt
			INTO #T_LastUsed
			FROM 
				sys.dm_db_index_usage_stats AS stat 
				INNER JOIN sys.objects AS o
			ON stat.[object_id] = o.[object_id]
			WHERE [database_id] = DB_ID()
			AND [type]=''U'';

			-- select * from #T_LastUsed

	
			;WITH cte_1 AS (
				SELECT
					'''+@DB+''' AS DB, 
					UsedType,
					LastUsed,
					Cnt
				FROM #T_LastUsed
				UNPIVOT (
						LastUsed FOR UsedType IN ([Seek], [Scan], [Lkp], [Upd])
					) unpvt_1
				UNPIVOT (
						Cnt FOR UsedType_cnt IN ([Seek_cnt], [Scan_cnt], [Lkp_cnt], [Upd_cnt])
					) unpvt_2
				WHERE UsedType+''_cnt''=UsedType_cnt
			)
			SELECT 
				d.name as DB,
				d.create_date as CreateDate,
				c.UsedType,
				case when c.LastUsed is null then ''19000101 00:00:00'' else c.LastUsed end as LastUsed,
				case when c.Cnt is null then 0 else c.Cnt end as cnt
			FROM sys.databases d 
			LEFT JOIN cte_1 c
				ON d.name=c.DB
			WHERE d.name='''+@DB+''';
		');
		fetch next from DB into @DB;
	END
	close DB;
	deallocate DB;
	declare @tt datetime2(2)=getdate();
	;MERGE [awr].[db_usage_stats] as target
	USING (
		SELECT DISTINCT 
			@tt as tt,
			(select cast(create_date as datetime2(2)) from sys.databases where name='tempdb') as StartUp,
			DB,
			db_id(DB) as [dbid],
			CreateDate,
			max(LastUsed) over (partition by DB) as LastUsed,
			sum(Cnt) over (partition by DB) as cntcalls
		FROM #T
	) as source (tt, StartUp, DB, [dbid], CreateDate, LastUsed, cntcalls)
	ON (target.StartUp=source.StartUp and target.[dbid]=source.[dbid] and target.CreateDate=source.CreateDate)
	WHEN MATCHED THEN 
		UPDATE SET LastUsed=source.LastUsed, cntcalls=source.cntcalls, tt=source.tt
	WHEN NOT MATCHED BY TARGET THEN
		INSERT (tt, StartUp, DB, [dbid], CreateDate, LastUsed, cntcalls)
		VALUES (source.tt, source.StartUp, source.DB, source.[dbid], source.CreateDate, source.LastUsed, source.cntcalls)
	;
end
GO
PRINT N'Creating Procedure [backups].[usp_RM2]...';


GO

	/* =============================================
	-- Author:		Иванов Андрей (sql1c)
	-- Create date: 05.08.2014 (2.0)
	-- Description:	usp_RM - REPAIR MIRROR - настройка/ремонт Зеркалирования для указанной БД.
					В основе алгоритма - backup/restore базы с помощью функционала sputnik.
	   Update:
					05.08.2014 (2.0)
					Совершенно новая версия ХП usp_RM! Теперь используется новая ХП usp_GC2 для поднятия копии БД на Зеркальном сервере!
					А также добавлены дополнительные проверки! Кроме этого, важные операции завернуты в блок try...catch!
				
					06.10.2014 (2.01)
					Добавлен новый параметр @DisableMirroring. Теперь можно через эту процедуру отключить Зеркалирование для указанной БД.

					06.05.2015 (2.05)
					Для учета именованных экземпляров SQL Server изменен алгоритм определения имени серверов. 
					Теперь в параметры @ServerProd и @ServerMirror нужно передавать имена серверов SQL Server
					без указания полного доменного имени (например, pecom.local не нужно)!
					Также оптимизирован механизм определения имени локального сервера SQL Server.

					20.11.2015 (2.07)
					Добавлены новые параметры @MoveFilesTo и @MoveLogFilesTo для указания, где будут размещены 
					файлы зеркальной БД. Если не задано, тогда автоматом будет выбран диск, где больше всего
					свободного места.

					10.11.2017 (2.080)
					Добавлен новый параметр @UseFreshDiffBack - определяет возможность использования свежих
					Дифф. бэкапов при восстановлении зеркальной БД, а также разрешает создавать новые
					Дифф. бэкапы (может повлиять на производительность основного сервера).
					По умолчанию включен.
	-- ============================================= */
	CREATE PROCEDURE backups.usp_RM2
		@ServerProd NVARCHAR(200),
		@ServerMirror NVARCHAR(200),
		@DB NVARCHAR(300),
		@ForceRM bit = 0,
		@DisableMirroring bit = 0,
		@MoveFilesTo nvarchar(500)=NULL,
		@MoveLogFilesTo nvarchar(500)=NULL,
		@UseFreshDiffBack bit = 1
	AS
	BEGIN
		SET NOCOUNT ON;
		--Выполнять алгоритм от имени [sa], так как Linked Server должен быть привязан на этот логин.
		EXECUTE AS LOGIN = 'sa';
		DECLARE @StrErr NVARCHAR(900);
		--Сначала производим дополнительную проверку: если состояние зеркалирования в норме, тогда НИЧЕГО НЕ ДЕЛАЕМ!
		--Если задан параметр @ForceRM=1, тогда Зеркалирование будет принудительно перенастроено!
		DECLARE @MirrorState VARCHAR(30);
		select @MirrorState=mirroring_state_desc
		from sys.database_mirroring
		where DB_NAME(database_id) =@DB
			and mirroring_guid is not null;
		IF @MirrorState IN ('SYNCHRONIZING','SYNCHRONIZED') AND @ForceRM=0 AND @DisableMirroring=0
		begin
			set @StrErr=N'Выполнение ХП backups.usp_RM2 прервано, т.к. для БД ['+@DB+'] состояние Зеркалирования в норме ('+@MirrorState+').
						  При необходимости, запустите ХП backups.usp_RM2 с параметром @ForceRM=1';
			PRINT(@StrErr);
			return 0;
		end

		--Также дополнительно проверим, что для БД установлен Full Recovery Model!
		DECLARE @RecMod varchar(25);
		SELECT @RecMod=recovery_model_desc
		FROM sys.databases
		WHERE name = @DB
		IF @RecMod<>'FULL' AND @DisableMirroring=0
		begin
			set @StrErr=N'Выполнение ХП backups.usp_RM2 прервано, т.к. для БД ['+@DB+'] режим восстановления <> "FULL" ('+@MirrorState+').
						  Сначала нужно установить Recovery Model=FULL!';
			PRINT(@StrErr);
			return 0;
		end
	
		DECLARE @LocalServer NVARCHAR(600);
		SELECT @LocalServer=CAST(SERVERPROPERTY('MachineName') AS NVARCHAR(300))+COALESCE('\'+CAST(SERVERPROPERTY('InstanceName') AS NVARCHAR(300)),'');
	
		--Отключаем Зеркалирование на 1-м и 2-м серверах;
		EXEC('
				EXEC
				(''IF EXISTS(SELECT database_id FROM sys.database_mirroring WHERE mirroring_guid IS NOT NULL AND database_id=DB_ID('''''+@DB+'''''))
						ALTER DATABASE ['+@DB+'] SET PARTNER OFF;
				'')
				AT ['+@ServerMirror+']
			');

		EXEC('
			IF EXISTS(SELECT database_id FROM sys.database_mirroring WHERE mirroring_guid IS NOT NULL AND database_id=DB_ID('''+@DB+'''))
					ALTER DATABASE ['+@DB+'] SET PARTNER OFF;
			');
		IF @DisableMirroring=1
			return 0;

		--Проверяем настройки для бэкапа LOg - если их Нет, то добавить!
		IF NOT EXISTS(SELECT [DBName] FROM sputnik.backups.BackConf WHERE Kind IN ('Log','XLog') AND DBName=@DB)
		BEGIN
			INSERT INTO sputnik.backups.BackConf ([DBName], LocalDir, NetDir, LocalDays, NetDays, Kind)
			SELECT TOP 1
				[DBName], LocalDir+'LOG\', NetDir+'LOG\', 2, 2, 'Log' AS Kind
			FROM sputnik.backups.BackConf
			WHERE DBName=@DB
		END;

		--Отключаем Бэкапы Лога для базы на Боевом сервере на время поднятия Копии БД на Зеркальном сервере и настройки Зеркала!
		UPDATE [sputnik].[backups].[BackConf]
			SET [Kind]='XLog'
			WHERE [DBName]=@DB AND [Kind]='Log';
	
		--Восстанавливаем Копию БД на зеркальном сервере с помощью новой ХП usp_GC2
		declare @MoveFilesTo_str nvarchar(500), @MoveLogFilesTo_str nvarchar(500);
		select
			@MoveFilesTo_str=
			CASE 
				WHEN @MoveFilesTo IS NULL THEN ''
				ELSE ', @MoveFilesTo=N'''''+@MoveFilesTo+''''''
			END,
			@MoveLogFilesTo_str=
			CASE 
				WHEN @MoveLogFilesTo IS NOT NULL AND @MoveFilesTo IS NOT NULL THEN ', @MoveLogFilesTo=N'''''+@MoveLogFilesTo+''''''
				ELSE ''
			END;

		DECLARE @UseFreshDiffBack_char CHAR(1);
		SET @UseFreshDiffBack_char=CASE @UseFreshDiffBack WHEN 1 THEN '1' ELSE '0' END;
		begin try
			EXEC('
				EXEC
				(''exec sputnik.backups.usp_GC2 @ServerSource=N'''''+@LocalServer+''''', @DBNameSource=N'''''+@DB+''''', @DBNameTarget=N'''''+@DB+''''',
												@FromCopy=1, @NoRecovery=1, @RunNewBackIfNeed=1, @FreshBack='+@UseFreshDiffBack_char+', @RM=1'+@MoveFilesTo_str+@MoveLogFilesTo_str+',@RunNewDiffBackIfNeed='+@UseFreshDiffBack_char+';
				'')
				AT ['+@ServerMirror+']
			');
		end try
		begin catch
			SET @StrErr=N'Ошибка при выполнении ХП [usp_GC2] для восстановлении копии базы данных на зеркальном сервере! Текст ошибки: '+ERROR_MESSAGE();
			RAISERROR(@StrErr,11,1) WITH LOG
		end catch

		--Создаём EndPoint для Зеркалирования (если его нет) на 1-м и 2-м серверах.
		EXEC('
				IF NOT EXISTS (SELECT endpoint_id FROM sys.endpoints WHERE name = ''EndPoint_Mirroring'')
					CREATE ENDPOINT [EndPoint_Mirroring]
						STATE=started
						AS TCP (listener_port=5022, listener_ip=all)
						FOR database_mirroring (role=partner, authentication=windows negotiate, encryption=required algorithm AES);
			');
		EXEC('
				EXEC(''
					IF NOT EXISTS (SELECT endpoint_id FROM sys.endpoints WHERE name = ''''EndPoint_Mirroring'''')
						CREATE ENDPOINT [EndPoint_Mirroring]
							STATE=started
							AS TCP (listener_port=5022, listener_ip=all)
							FOR database_mirroring (role=partner, authentication=windows negotiate, encryption=required algorithm AES);
					'')
				AT ['+@ServerMirror+'];
			');

		--Включаем Зеркалирование сначала на зеркальном сервере, а затем на боевом:
		begin try
			--Имя конечной точки формируется с учетом имени компьютера (сервера),
			--а имя компьютера формируется из имени SQL Server переданных в параметрах
			--отбрасывается имя экземпляра SQL Server (если оно есть).
			DECLARE @MachineName nvarchar(300);
			SET @MachineName=SUBSTRING(@ServerProd,0,CASE CHARINDEX('\',@ServerProd) WHEN 0 THEN LEN(@ServerProd)+1 ELSE CHARINDEX('\',@ServerProd) END)
			EXEC('
					EXEC
					(''
						ALTER DATABASE ['+@DB+'] SET PARTNER = N''''TCP://'+@MachineName+'.PECOM.LOCAL:5022'''';
					'')
					AT ['+@ServerMirror+']
			');
			SET @MachineName=SUBSTRING(@ServerMirror,0,CASE CHARINDEX('\',@ServerMirror) WHEN 0 THEN LEN(@ServerMirror)+1 ELSE CHARINDEX('\',@ServerMirror) END)
			EXEC
				('
					ALTER DATABASE ['+@DB+'] SET PARTNER = N''TCP://'+@MachineName+'.PECOM.LOCAL:5022'';
				');
		end try
		begin catch
			SET @StrErr=N'Ошибка в ХП [usp_RM2] при попытке включить Зеркалирование! Текст ошибки: '+ERROR_MESSAGE();
			RAISERROR(@StrErr,11,1) WITH LOG
		end catch 

		--Включаем Бэкапы Лога для боевой базы на 2-м сервере!
		UPDATE [sputnik].[backups].[BackConf]
			SET [Kind]='Log'
			WHERE [DBName]=@DB AND [Kind]='XLog';

	END
GO
PRINT N'Creating Procedure [backups].[usp_WriteBackuphistory]...';


GO

	create proc backups.usp_WriteBackuphistory 
		@db_name nvarchar(300),
		@fg nvarchar(1000)=null,
		@backup_type varchar(4),
		@backup_file nvarchar(260),
		@backup_file_fullname nvarchar(260)
	as
	begin
		set nocount on;
		insert into sputnik.backups.BackupHistory (DB_Name,FG,Backup_Type,Backup_File,backup_start_date,backup_finish_date,first_LSN,last_LSN,database_backup_LSN,diff_base_LSN,backup_size_Mb,backup_compress_ratio)
		select 
			@db_name, case when @fg='' then NULL else @fg end as FG, @backup_type, @backup_file, 
			BS.backup_start_date,BS.backup_finish_date,BS.first_LSN,BS.last_lsn,BS.database_backup_LSN,BS.differential_base_lsn,
			CASE 
				WHEN BS.compressed_backup_size IS NULL 
					THEN cast(BS.backup_size/(1024*1024) as decimal(19,3))
				ELSE cast(BS.compressed_backup_size/(1024*1024) as decimal(19,3)) 
			END backup_size_Mb,
			CASE 
				WHEN BS.compressed_backup_size IS NULL 
					THEN 0
				ELSE cast(round(BS.backup_size/BS.compressed_backup_size,2) as decimal(5,2)) 
			END as backup_compress_ratio
		from
			msdb.dbo.backupmediafamily BMF
		inner join msdb.dbo.backupset BS
			on BMF.media_set_id=BS.media_set_id
		where
			physical_device_name=@backup_file_fullname
	end
GO
PRINT N'Creating Procedure [backups].[usp_CleaningBack]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 11.12.2013 (1.0)
	-- Description: Эта процедура производит очистку от старых бэкапов на серверах c расширением заданным в параметре @rez (по умолчанию bak)
					Производится формирование скрипта PowerShell и в конце производится запуск этого сценария.
	-- Update:		25.12.2013 (1.1)
					Так как теперь есть таблица BackConfWeekly для недельных бэкапов, необходимо получать из неё информацию для очистки!
					09.01.2014 (1.15)
					Для переменных (текстовых), хранящих информацию о каталогах бэкапов и команды, увеличен размер на 1000 знаков.
					09.01.2014 (1.2)
					При формировании файла PowerShell-скрипта применяется кодировка 650001 (UTF-8).
					12.02.2014 (1.3)
					Улучшен алгоритм Ротации - теперь для Удаления будут отбираться файлы не только по расширению и старше определённой Даты, но и содержащие в Имени файла нужные Имя Базы и Тип Бэкапа.
						Это позволит избежать неправильного удаления, когда бэкапы разных баз или разных типов сохраняются в одном каталоге.
					Также оптимизирован алгоритм PS скрипта - фильтрация данных WHERE теперь происходит в одном месте конвеера с использованием оператора AND.
					17.03.2014 (1.35)
					Исправлен алгоритм Ротации - поиск старых файлов бэкапов! Условие Меньше Или Равно (-le) изменено на Меньше (-lt)!
					То есть теперь, удаляться будут файлы, которые именно Старше заданного количества дней!
					21.03.2014 (1.37)
					Внесены исправления: кодировка для файла изменена с 65001(UTF8) на 1251(ANSI-Кириллица). Увеличены размеры всех строковых переменных. Для всех строковых литералов добавлен
						символ N'' (поддержка UNICODE символов).
					21.11.2014 (1.39)
					Добавлен новый алгоритм зачистки старых файлов скриптов PowerShell, сформированных из модуля usp_CopyBack (копирование файлов бэкапов).
					23.06.2015 (1.40)
					Добавлен новый алгоритм формирования имени файлов скриптов, теперь в имени файлов будет имя экземпляра, тип бэкапов, время. Всё это нужно
					чтобы избежать пересечения файлов скриптов (данный алгоритм аналогичен алгоритму из процедуры usp_CopyBack.
					Также добавлен алгоритм зачистки старых файлов скриптов PowerShell, сформированных из модуля [usp_CleaningBack]
					12.02.2016 (2.00)
					Новый алгоритм реализущий очень нужную возможность - ротацию бэкапов по количеству файлов (а не по возрасту файлов).
					Но и старый способ ротации также остается.
					Причем для каждого бэкапа можно сделать выбор (поле [Policy_CountFiles]) - какую политику ротации использовать!
					Вся логика реализована на Powershell!
					12.02.2016 (2.01)
					Доработка нового алгоритма ротации. Теперь доступны 3 режима: классический(0), по количествоу файлов(1) и гибридный(2).
					Причем можно задавать разные режимы для бэкапов и для копий бэкапов! 
					22.12.2017 (2.020)
					Добавлен алгоритм экранирования спец.символов при поиске каталогов.
					01.02.2018 (2.021)
					Доработан алгоритм экранирования: чтобы работало нужно использовать одинарные кавычки вместо двойных.
					23.03.2018 (2.025)
					Изменена политика ротаций: классический(0) - теперь хранит x-дней + 3-файла, гибридный(2) - теперь хранит x-дней + x-файлов.
					13.04.2018 (2.027)
					Доработан поиск бэкапов для удаления по имени файла. 
					19.04.2018 (2.028)
					Добавлена проверка при отборе бэкапов - только для существующих online баз!
	-- ============================================= */
	create PROCEDURE backups.[usp_CleaningBack]  
		@type varchar(4) =null --тип бэкапа Log или Full.
		,@DBFilter nvarchar(100) = null
		,@rez nvarchar(10) = 'bak'
	AS
	BEGIN
		SET NOCOUNT ON;
		declare @PS_command nvarchar(4000), @CMD nvarchar(4000),@rc bit, @LocalDir nvarchar(1600), @NetDir nvarchar(1600), @LocalDays int, @NetDays int;
		declare @Kind varchar(4),@DBName nvarchar(400), @InstanceName nvarchar(128),@PSFile nvarchar(300),@ErrMsg nvarchar(900), @LocalPolicy tinyint, @NetPolicy tinyint, @PS_Filter_Policy nvarchar(4000);
		declare C cursor for
		select bc.LocalDir, bc.NetDir, bc.LocalDays, bc.NetDays, bc.DBName, bc.Kind, bc.[LocalPolicy], bc.[NetPolicy]
		from sputnik.backups.BackConf bc
		inner join sys.databases sdb on bc.DBName=sdb.[name] and sdb.state_desc='ONLINE'
		where
			(@DBFilter is null or bc.DBName=@DBFilter)
			and (@type is null or bc.Kind=@type)
			and (bc.Kind in ('Full','Diff','Log')) --на всякий случай ограничение. Удалять только файлы полных копий, дифф. копий и Лога.
		UNION
		select bc.LocalDir, bc.NetDir, bc.LocalDays, bc.NetDays, bc.DBName, bc.Kind, bc.[LocalPolicy], bc.[NetPolicy]
		from sputnik.backups.BackConfWeekly bc
		inner join sys.databases sdb on bc.DBName=sdb.[name] and sdb.state_desc='ONLINE'
		where
			(@DBFilter is null or bc.DBName=@DBFilter)
			and (@type is null or bc.Kind=@type)
			and (bc.Kind in ('Full','Diff','Log')) --на всякий случай ограничение. Удалять только файлы полных копий, дифф. копий и Лога.
	
		--формируем Имя файла скрипта.
		--Добавляем текущее время к имени файла. Также добавляется тип бэкапов, которые будут ротироваться или ALL
		--ещё учитывается имя экземпляра SQL Server и добавляется в имя файла.
		SELECT @InstanceName=COALESCE('_'+CAST(SERVERPROPERTY('InstanceName') as nvarchar(128)),'');
		set @PSFile='usp_CleaningBack'+@InstanceName;
		if @type is not null
			set @PSFile=@PSFile+'_'+@type;
		else
			set @PSFile=@PSFile+'_ALL';
		set @PSFile=@PSFile+'_'+REPLACE(REPLACE(SUBSTRING(CONVERT(NVARCHAR(23),GETDATE(),126),1,23),'T','_'),':','.');
		set @PSFile=@PSFile+'.ps1';

		--1. Формируем файл скрипта PowerShell
		set @CMD = N'cmd /k chcp 1251 && echo | echo #PowerShell-Script for cleaning old backups. Created by Job on local SQL Server. Date: '+convert(varchar(20),getdate(),120)+ '> %temp%\'+@PSFile;
		EXEC @rc=xp_cmdshell @CMD , no_output
		if @rc=1
		begin
			SET @ErrMsg=N'Ошибка при записи файла (PowerShell скрипт) %temp%\'+@PSFile;
			RAISERROR(@ErrMsg,11,1) WITH LOG
		end
		open C
		fetch next from C
		into @LocalDir, @NetDir, @LocalDays, @NetDays, @DBName, @Kind, @LocalPolicy, @NetPolicy
		while @@FETCH_STATUS=0
		begin
			--Экранируем символы [ и ], чтобы PowerShell смог обнаружить каталоги (если такие символы использованы):
			IF CHARINDEX('[', @LocalDir)>0
				SET @LocalDir=REPLACE(@LocalDir,'[','``[');
			IF CHARINDEX(']', @LocalDir)>0
				SET @LocalDir=REPLACE(@LocalDir,']','``]');
			IF CHARINDEX(']', @NetDir)>0
				SET @NetDir=REPLACE(@NetDir,']','``]');
			IF CHARINDEX(']', @NetDir)>0
				SET @NetDir=REPLACE(@NetDir,']','``]');

			--Определяем политику ротации - все это средствами Powershell!
			if @LocalPolicy=1 --Режим ротации по количеству файлов! 
				set @PS_Filter_Policy= N' ^^^| Sort-Object -property lastwritetime -descending ^^^| Select-Object -skip '+cast(@LocalDays as varchar(5));
			else if @LocalPolicy=0 --Режим ротации классический (по возрасту файлов)! + теперь оставляем 3 файла, чтобы гарантировано сохранить бэкапы!
				set @PS_Filter_Policy= N' ^^^| Sort-Object -property lastwritetime -descending ^^^| Select-Object -skip 3 ^^^| where {$_.lastwritetime -lt ((get-date).AddDays(-'+cast(@LocalDays as varchar(5))+N'))}';
			else if @LocalPolicy=2 --Режим ротации гибридный (всегда оставляем x-файлов и удаляем по возрасту файлов старше x-дней )!
				set @PS_Filter_Policy= N' ^^^| Sort-Object -property lastwritetime -descending ^^^| Select-Object -skip '+cast(@LocalDays as varchar(5))+' ^^^| where {$_.lastwritetime -lt ((get-date).AddDays(-'+cast(@LocalDays as varchar(5))+N'))}';
			set @PS_command=N'get-childitem -path '''+@LocalDir+N''' ^^^| where {$_.extension -eq ''.'+@rez+N''' -and $_.Name -like '''+@DBName+'_'+@Kind+'_*''} '+@PS_Filter_Policy+N' ^^^| remove-item';
			set @CMD = N'cmd /k chcp 1251 && echo | echo '+@PS_command+N' >> %temp%\'+@PSFile;
			--для отладки:
			--PRINT @CMD;
			EXEC @rc=xp_cmdshell @CMD , no_output
			if @rc=1
			begin
				SET @ErrMsg=N'Ошибка при записи файла (PowerShell скрипт) %temp%\'+@PSFile;
				RAISERROR(@ErrMsg,11,1) WITH LOG
			end
			--Определяем политику ротации - все это средствами Powershell!
			if @NetPolicy=1 --Режим ротации по количеству файлов! 
				set @PS_Filter_Policy= N' ^^^| Sort-Object -property lastwritetime -descending ^^^| Select-Object -skip '+cast(@NetDays as varchar(5));
			else if @NetPolicy=0 --Режим ротации классический (по возрасту файлов)! + теперь оставляем 3 файла, чтобы гарантировано сохранить бэкапы!
				set @PS_Filter_Policy= N' ^^^| Sort-Object -property lastwritetime -descending ^^^| Select-Object -skip 3 ^^^| where {$_.lastwritetime -lt ((get-date).AddDays(-'+cast(@NetDays as varchar(5))+N'))}';
			else if @NetPolicy=2 --Режим ротации гибридный (всегда оставляем x-файлов и удаляем по возрасту файлов старше x-дней )!
				set @PS_Filter_Policy= N' ^^^| Sort-Object -property lastwritetime -descending ^^^| Select-Object -skip '+cast(@NetDays as varchar(5))+' ^^^| where {$_.lastwritetime -lt ((get-date).AddDays(-'+cast(@NetDays as varchar(5))+N'))}';
			set @PS_command=N'get-childitem -path '''+@NetDir+N''' ^^^| where {$_.extension -eq ''.'+@rez+N''' -and $_.Name -like '''+@DBName+'_'+@Kind+'_*''} '+@PS_Filter_Policy+N' ^^^| remove-item';
			set @CMD = N'cmd /k chcp 1251 && echo | echo '+@PS_command+N' >> %temp%\'+@PSFile;
			--для отладки:
			--PRINT @CMD;
			EXEC @rc=xp_cmdshell @CMD , no_output

			if @rc=1
			begin
				SET @ErrMsg=N'Ошибка при записи файла (PowerShell скрипт) %temp%\'+@PSFile;
				RAISERROR(@ErrMsg,11,1) WITH LOG
			end
			fetch next from C
			into @LocalDir, @NetDir, @LocalDays, @NetDays, @DBName, @Kind, @LocalPolicy, @NetPolicy
		end
		close C;
		deallocate C;

		--2.1 Добавляем команды PowerShell для зачистки старых файлов скриптов usp_CopyBack (копирование бэкапов).
		set @PS_command=N'Get-ChildItem -Path $env:TEMP\usp_CopyBack*.ps1 ^^^| where {$_.lastwritetime -lt ((get-date).AddDays(-3))} ^^^| remove-item'
		set @CMD = N'cmd /k chcp 1251 && echo | echo '+@PS_command+N' >> %temp%\'+@PSFile;
		EXEC @rc=xp_cmdshell @CMD , no_output
		if @rc=1
		begin
			SET @ErrMsg=N'Ошибка при записи файла (PowerShell скрипт) %temp%\'+@PSFile;
			RAISERROR(@ErrMsg,11,1) WITH LOG
		end

		--2.2 Добавляем команды PowerShell для зачистки старых файлов скриптов usp_CleaningBack (очистка старых бэкапов).
		set @PS_command=N'Get-ChildItem -Path $env:TEMP\usp_CleaningBack*.ps1 ^^^| where {$_.lastwritetime -lt ((get-date).AddDays(-3))} ^^^| remove-item'
		set @CMD = N'cmd /k chcp 1251 && echo | echo '+@PS_command+N' >> %temp%\'+@PSFile;
		EXEC @rc=xp_cmdshell @CMD , no_output
		if @rc=1
		begin
			SET @ErrMsg=N'Ошибка при записи файла (PowerShell скрипт) %temp%\'+@PSFile;
			RAISERROR(@ErrMsg,11,1) WITH LOG
		end

		--3. Запуск скрипта PowerShell из файла
		set @CMD = 'powershell %temp%\'+@PSFile;
		EXEC @rc=xp_cmdshell @CMD , no_output
		if @rc=1
		begin
			SET @ErrMsg=N'Ошибка при запуске PowerShell-скрипта из файла %temp%\'+@PSFile;
			RAISERROR(@ErrMsg,11,1) WITH LOG
		end
		else
			PRINT N'Команда Очистки старых бэкапов успешно выполнена!';
	end
GO
PRINT N'Creating Procedure [backups].[usp_RestoreDB_simple]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 17.12.2013 (1.0)
	-- Description: Эта процедура позволяет восстанавить указанную базу на локальном сервере из другой базы (и даже с другого сервера).
					Если восстановление происходит из базы другого сервера нужно, чтобы на локальном сервере была настроена связь
					через LinkedServer c удалённым сервером @ServerSource (желательно с привязкой к логину RestoreDB_Link.
					Также необходимо, чтобы файлы резервных копий существовали на том самом месте, куда они создавались!
					В параметре @dbowner нужно указать владельца (это логин на уровне SQL Server) для новой восстанавливаемой БД (для работы из 1С и других приложений)!
					В параметре @MoveFilesTo нужно задать путь для размещения всех файлов БД.
	-- Update:
					09.01.2014 (1.1)
						Новый параметр @ToDate - производит восстановление базы на указанную дату (не позже).
					17.01.2014 (1.2)
						Все текстовые параметры увеличены. Добавлена проверка: если не удалось найти резервную копию для Базы-Источника, то restore не происходит!	
					21.01.2014 (1.25)
						Добавлено создание каталога @MoveFilesTo, если его нет. Через команду xp_cmdshell.
					28.01.2014 (1.27)
						Добавлен новый параметр @NoRecovery - если указан 1, то база данных останется в состояние NoRecovery (для дальнейшего восстановления).
							По умолчанию 0.
						Также в команду восстановления добавлен параметр STATS=10 - показывать ход выполнения каждые 10 %.
					26.02.2014 (1.28)
						Исправлена ошибка - при создании каталога нужно использовать "", чтобы создать каталог с пробелами.
					28.02.2014 (1.4)
						Процедура существенно доработана: оптимизирован алгоритм получения информации о файлах БД (теперь вся информация берётся из бэкапа).
						А также добавлена возможность восстановления из указанного бэкапа - для этого нужно указать полный путь в новом параметре @FromDisk.
					04.03.2014 (1.41)
						В алгоритм определения файлов добавлено определения файла для Каталога Полнотекстового поиска.
					02.04.2014 (1.43)
						Небольшое исправление - замена ONLY на BAK в имени файла бэкапа вынесено наверх (сразу после получения соответствующих переменных).
					06.04.2014 (1.5)
						Теперь большинство параметров можно не задавать! Нужно только задать Имя БД назначения и источник (БД или файл бэкапа).
						При локальном источнике Имя сервера теперь не нужно задавать! Также путь для размещения базы теперь автоматически определяется -
						на диске, где больше всего свободного места создаётся каталог \DATA\Имя БД назначения.
					19.04.2014 (1.6)
						Новый параметр @FromLog - файл бэкапа Журнала транзакций. Соотвественно, теперь есть возможность продолжить восстановление
						из журнала транзакций!
					20.04.2014 (1.61)
						Оптимизирован алгоритм удаления существующей базы в самом начале процедуры.
					22.04.2014 (1.62)
						Добавлен алгоритм выполнения кода от имена sa в случае, если параметр @NoRecovery=1. Чтобы сделать владельцем восстанавливаемой
						базы sa, а не текущего пользователя.
					23.04.2014 (1.65)
						Добавлен параметр @ForceRecovery. Изменён алгоритм перевода базы после восстановления в режим RECOVERY. Добавлен алгоритм
						сжатия файлов Логов после восстановления и перевода базы в RECOVERY. Оптимизирован алгоритм определения пути, где будет лежать
						новая база.
					03.06.2014 (1.7)
						Добавлен параметр @DiffBack. Этот параметр говорит о том, что в параметре @FromDisk дифф. бэкап. Соответственно появилась
						восстановление из Дифф. бэкапа (аналогично восстановлению полного бэкапа).
					05.08.2014 (1.8)
						Новый параметр @NoFileList. Если задан 1, то информация о файлах берётся из уже восстановленной на сервере БД (из 
						представления sys.master_files. Иначе, информация о файлах берётся непосредственно из бэкапа.
						Этот параметр следует применять при повторном накате бэкапов на восстанавливаемую БД, чтобы ускорить процесс восстановления!
					07.08.2014 (1.81)
						Новый параметр @NoStats, если задан тогда в процессе восстановления не будет выводится кол-во выполненных процентов
						(оператор STATS в команде RESTORE).
					24.09.2014 (1.82)
						В блоке удаления существующей БД добавлен алгоритм отключения Зеркалирование с проверкой перед удалением существующей БД. 
						Также в этот же блок изменен блок обработки исключений - теперь будет выводиться ERROR_MESSAGE.
					18.03.2015 (1.85)
						Добавлен новый параметр @StandBy_File - для поддержки режима STANDBY (read-only) для восстанавливаемой БД. Может применяться
						в механизме lse.
					20.03.2015 (1.86)
						Доработан алгоритм восстановления БД в режиме STANDBY (read-only) - теперь перед восстановлением журналов транзакций БД будет
						переведена в режим single_user, чтобы закрыть коннекты с базой и начать восстановление.
					14.08.2015 (1.90)
						Добавлена поддержка FileStream-данных!
						Также добавлена поддержка восстановление БД из разных файловых групп!
						Сначала нужно восстановить полный бэкап или PRIMARY файловую группу с параметром @NoRecovery=1. 
						Затем уже восстановить остальные ФГ с указанием параметра @ContinueRecovery=1. Причем бэкап таких ФГ мог быть создан раньше
						(в случае если это ФГ READONLY!), чем Primary. Затем уже можно восстановить бэкапы журналов транзакций (если необходимо)!
					25.10.2015 (1.92)
						При восстановлении из Log-файлов теперь не формируется команды MoveFilesTo (их не должно быть в команде Restore Log...)
						Также добавлен параметр @MoveLogFilesTo - иногда требуется разместить Log-файлы на другом диске. Если параметр не задан,
						то все файлы будут размещены в месте указанном в параметре @MoveFilesTo
					15.12.2015 (1.93)
						Расширены длина строки для параметров  @tsql и @tsql2 чтобы избежать проблем обрезания строки когда в БД много файлов!
					10.09.2016 (1.94)
						Добавлен новый параметр @NoSetMultiUser!
					05.04.2017 (1.950)
						Добавлен новый параметр @ChangeDBOwner! Если =1, то процедура только поменяет владельца существующей БД, без восстановления. Если в базе уже есть такой пользователь, то ему назначается роль db_owner.
						Также сжатие лог-файла теперь будет до 128Мб (было 512).
					13.04.2017 (1.953)
						Изменён алгоритм получения данных из restore filelistonly. Вместо табличной переменной теперь временная таблица.
						Также здесь добавлена поддержка 2016 версии (появился новый столбец).
					22.02.2018 (1.957)
						Добавлен новый параметр @del_bak_hs - если 1, то будет очистка истории бэкапов для базы (если она есть).
						По умолчанию 0.
				07.08.2019 (1.961)
					Добавлена совместимость со старыми версиями SQL Server (<2012) в самом конце процедуры в алгоритме переопределения владельца БД.
				26.11.2020 (1.962)
					Added new column for FILELISTONLY (for compability with 2019)
-- ============================================= */
CREATE PROCEDURE [backups].[usp_RestoreDB_simple]  
	@DBNameTarget nvarchar(200),
	@DBNameSource nvarchar(200)=null,
	@ServerSource nvarchar(200)=null,
	@dbowner nvarchar(50)='sa',
	@MoveFilesTo nvarchar(500)=NULL,
	@MoveLogFilesTo nvarchar(500)=NULL,
	@ToDate datetime=null,
	@NoRecovery bit = 0,
	@FromDisk nvarchar(600)=null,
	@DiffBack bit = 0,
	@FromLog  nvarchar(600)=null,
	@ForceRecovery bit = 0,
	@NoFileList bit = 0,
	@NoStats bit = 0,
	@StandBy_File nvarchar(500)=null,
	@ContinueRecovery bit = 0,
	@NoSetMultiUser bit=0,
	@ChangeDBOwner bit = 0,
	@del_bak_hs bit = 0
AS
BEGIN
	--Определяем мажорную версию SQL Server
	declare @Ver nvarchar(128), @VerMain numeric(6,3);
	set @Ver=CAST(SERVERPROPERTY('ProductVersion') as nvarchar(128));
	set @VerMain=cast(LEFT(@Ver, CHARINDEX('.',@Ver, CHARINDEX('.', @Ver)+1)-1) as numeric(6,3));
	IF @ChangeDBOwner=0
	BEGIN
		IF @ForceRecovery=0
		BEGIN
			IF @NoRecovery=1
				EXECUTE AS LOGIN = 'sa';
			declare @LASTBACKUP nvarchar(600),@FULLBACKUP nvarchar(600), @tsql nvarchar(4000), @tsql2 nvarchar(4000)='', @type nvarchar(10), @typeF int, @ErrMsg nvarchar(800);
			declare @All smallint, @i smallint,	@File_Id int, @PrevFileID int, @DB_ID int, @FileName nvarchar(70), @NewFileName nvarchar (400),  @tmkdir nvarchar(550);
			declare @Tab TABLE (FileName nvarchar(128), FileID bigint, type tinyint);
			declare @RecoveryState nvarchar(650), @RESTORE VARCHAR(8), @SingleUserMode nvarchar(300)='', @MultiUserMode nvarchar(300)='';
			declare @StrStats NVARCHAR(20)='';
			IF @NoStats=0
				SET @StrStats = N',STATS=10';

			IF @FromLog IS NULL AND @DiffBack=0 AND @ContinueRecovery=0
			BEGIN
				IF DB_ID(@DBNameTarget) IS NOT NULL
				BEGIN
					BEGIN TRY
						IF @del_bak_hs=1
							EXEC msdb.dbo.sp_delete_database_backuphistory @database_name = @DBNameTarget;
						--Отключим зеркалирование (если оно включено) для базы, перед удалением!
						IF EXISTS(SELECT database_id FROM sys.database_mirroring WHERE mirroring_guid IS NOT NULL AND database_id=DB_ID(@DBNameTarget))
						BEGIN
							SET @tsql='ALTER DATABASE ['+@DBNameTarget+'] SET PARTNER OFF';
							EXEC (@tsql);
						END;
						--Перевод базы в режим SINGLE_USER с отключением всех соединений (если база в Online и в Multi_USer).
						IF EXISTS(SELECT database_id FROM SYS.DATABASES WHERE name = @DBNameTarget AND state_desc='ONLINE' AND user_access_desc='MULTI_USER')
						BEGIN
							SET @tsql='ALTER DATABASE ['+@DBNameTarget+'] SET SINGLE_USER WITH ROLLBACK IMMEDIATE';
							EXEC (@tsql);
						END
						SET @tsql='DROP DATABASE ['+@DBNameTarget+']';
						EXEC (@tsql);
					END TRY
					BEGIN CATCH 
						set @ErrMsg='usp_RestoreDB_simple: Ошибка при удалении базы и/или истории резервных копий по базе ! Подробности: '+ERROR_MESSAGE();
						RAISERROR(@ErrMsg,11,1) WITH LOG
					END CATCH
				END
			END

			IF @MoveFilesTo IS NULL AND @FromLog IS NULL
			BEGIN
				--Если путь к базе НЕ указан, определяем диск, где больше всего свободного места.
				DECLARE @MaxDrive CHAR(1);
				IF @FromLog IS NULL AND @DiffBack=0
					exec sputnik.info.usp_GetDrives @GetMaxFree=1, @MaxFreeDrive=@MaxDrive OUTPUT;
				ELSE
					SELECT TOP 1 @MaxDrive=LEFT(physical_name,1)
					FROM SYS.MASTER_FILES
					WHERE database_id = DB_ID(@DBNameTarget);
				SET @MoveFilesTo=@MaxDrive+':\DATA\'+@DBNameTarget+'\';
			END;

		
			if @FromDisk is null AND @FromLog IS NULL
			begin
				set @FULLBACKUP=''; 
	
				if @ToDate is null
					set @ToDate=getdate()

				IF @ServerSource IS NULL
					SET @ServerSource=@@SERVERNAME;

				IF @DBNameSource IS NULL
					SET @DBNameSource=@DBNameTarget;

				set @tsql=N'select @res1=
					ltrim(rtrim(MF.physical_device_name)), @res2=BS.type
				from
				(SELECT top 1
					BS.media_set_id,
					BS.name,
					BS.type
				FROM 
					['+@ServerSource+'].[msdb].[dbo].[backupset] as BS
				where
					BS.database_name = '''+@DBNameSource+'''
					and (BS.type in (''I'',''D''))
					and (BS.backup_finish_date <= '''+convert(nvarchar(23),@ToDate,109)+''')
				order by BS.backup_finish_date desc) as BS
				inner join ['+@ServerSource+'].[msdb].[dbo].[backupmediafamily] as MF on BS.media_set_id=MF.media_set_id';

				exec sp_executesql @tsql, N'@res1 nvarchar(300) OUTPUT,@res2 nvarchar(10) OUTPUT', @res1=@LASTBACKUP OUTPUT,@res2=@type OUTPUT


				IF @type='I'	--Если это Дифференциальная копия, то получить последнюю полную копию!
				BEGIN
					set @tsql=N'select @res1=
						ltrim(rtrim(MF.physical_device_name))
					from
					(SELECT top 1
						BS.media_set_id,
						BS.name
					FROM 
						['+@ServerSource+'].[msdb].[dbo].[backupset] as BS
					where
						BS.database_name = '''+@DBNameSource+'''
						and BS.type = ''D''
					order by BS.backup_finish_date desc) as BS
					inner join ['+@ServerSource+'].[msdb].[dbo].[backupmediafamily] as MF on BS.media_set_id=MF.media_set_id';

					exec sp_executesql @tsql, N'@res1 nvarchar(300) OUTPUT', @res1=@FULLBACKUP OUTPUT
				END
			end
			else
			begin
				IF @FromLog IS NULL
					set @LASTBACKUP=@FromDisk;
				ELSE
					set @LASTBACKUP=@FromLog;
				set @FULLBACKUP='';
			end
			set @LASTBACKUP=replace(@LASTBACKUP,'.only','.BAK');
			IF @FULLBACKUP<>''
				set @FULLBACKUP=replace(@FULLBACKUP,'.only','.BAK');
		
			--Получаем информацию о файлах БД и формируем команды MoveFilesTo только если восстанавливаем НЕ Log файлы
			--т.к. для команды Restore Log команды MoveFilesTo задавать нельзя.
			IF @FromLog IS NULL
			BEGIN 
				--Получить Все имена, ИД и типы файлов и записать их в таблицу @Tab
				if @NoFileList=1 AND EXISTS(select database_id from sys.databases where name=@DBNameTarget and state=1)
				--Если задан параметр @NoFileList=1, тогда информацию о файлах возьмём из представления sys.master_files
				--При этом предполагается, что целевая БД уже существует на сервере в состоянии RESTORING.
					insert into @Tab (FileName,FileID, type)
					select 
						name as FileName,
						file_id as FileID, 
						type
					from sys.master_files
					where database_id=db_id(@DBNameTarget);
				else
				begin	
					--В остальных случаях Данные взять из последнего бэкапа!
					if object_id('tempdb.dbo.#FileList') is not null
						drop table #FileList;
					create table #FileList
						(
							LogicalName nvarchar(128),
							PhysicalName nvarchar(260),
							Type char(1),
							FileGroupName nvarchar(128),
							Size numeric(20,0),
							MaxSize numeric(20,0),
							FileId bigint,
							CreateLSN numeric(25,0),
							DropLSN numeric(25,0) NULL,
							UniqueID  uniqueidentifier,
							ReadOnlyLSN numeric(25,0) NULL,
							ReadWriteLSN  numeric(25,0) NULL,
							BackupSizeInBytes bigint,
							SourceBlockSize int,
							FileGroupId int,
							LogGroupGUID uniqueidentifier NULL, 
							DifferentialBaseLSN  numeric(25,0) NULL,
							DifferentialBaseGUID uniqueidentifier NULL,
							isReadOnly bit,
							isPresent bit,
							TDEThumbrint varbinary(32),
							SnapshotURL nvarchar(360)
						)

					insert into #FileList
					exec(
							'restore filelistonly
							from disk=N'''+@LASTBACKUP+''''
						)
					insert into @Tab (FileName,FileID, type)
					select 
						LogicalName as FileName, 
						FileID, 
						case
							when Type='L' then 1
							when Type='D' then 0
							when Type='F' then 2
							when Type='S' then 3 --FileStream
						end as type
					from #FileList
				end
		
				--Формируем команду для Restore по перемещению файлов БД на новое место.
				declare CF Cursor for
				select FileName,FileID,type from @Tab;
				open CF;
				fetch next from CF into @FileName, @File_Id, @typeF;
				while @@Fetch_Status=0
				begin
					if @File_ID=1
						set @NewFileName=@DBNameTarget++'.MDF';
					else if @typeF=0
						set @NewFileName=@DBNameTarget+cast(@File_Id as nvarchar(10))+'.NDF';
					else if @typeF=1
						set @NewFileName=@DBNameTarget+'_log_'+cast(@File_Id as nvarchar(10))+'.LDF';
					else if @typeF=2
						set @NewFileName=@DBNameTarget+'_FullTextSearchCatalog_'+cast(@File_Id as nvarchar(10))+'.NDF';
					else if @typeF=3
					begin
						set @NewFileName=@DBNameTarget+'_FS_'+@FileName+'\';
						--Создать каталог для FileStream данных (если его не существует).
						set @tmkdir = N'mkdir "' + @MoveFilesTo+@NewFileName + '"';
						exec xp_cmdshell @tmkdir, no_output;
					end
					set @tsql2=@tsql2+N'
								MOVE N'''+@FileName+''' TO N'''+
								CASE 
									WHEN @MoveLogFilesTo IS NOT NULL AND @typeF=1 THEN @MoveLogFilesTo
									ELSE @MoveFilesTo
								END +
								@NewFileName+''',';
					fetch next from CF into @FileName, @File_Id, @typeF;
				end
				close CF;
				deallocate CF;
			END;

			IF @LASTBACKUP IS NOT NULL
			BEGIN
				--Создать каталог @MoveFilesTo (если его не существует).
				set @tmkdir = N'mkdir "' + @MoveFilesTo + '"';
				exec xp_cmdshell @tmkdir, no_output;
				if @MoveLogFilesTo is not null
				begin
					--Создать каталог @@MoveLogFilesTo (если он был задан и он не существует).
					set @tmkdir = N'mkdir "' + @MoveLogFilesTo + '"';
					exec xp_cmdshell @tmkdir, no_output;
				end
				--Формируем все команду для Restore.
				if @NoRecovery=1
					set @RecoveryState='NORECOVERY';
				else
					set @RecoveryState='RECOVERY';
				if @StandBy_File IS NOT NULL AND @FromLog IS NOT NULL
				BEGIN
					set @RecoveryState='STANDBY=N'''+@StandBy_File+'''';
					if exists (select database_id from sys.databases where name=@DBNameTarget and is_in_standby=1 and [state]=0)
					BEGIN
						set @SingleUserMode=' ALTER DATABASE ['+@DBNameTarget+'] SET SINGLE_USER WITH ROLLBACK IMMEDIATE; ';
						if @NoSetMultiUser=0
							set @MultiUserMode=' ALTER DATABASE ['+@DBNameTarget+'] SET MULTI_USER; ';
					END	
				END
				if @FULLBACKUP=''
				begin
					IF @FromLog IS NULL
						SET @RESTORE='DATABASE';
					ELSE
						SET @RESTORE='LOG';

					set @tsql=@SingleUserMode+
					'RESTORE ' +@RESTORE+ ' ['+@DBNameTarget+']
						FROM  DISK = N'''+@LASTBACKUP+''' 
					 WITH  FILE = 1, '+@tsql2+'
					'+@RecoveryState+',NOUNLOAD,  REPLACE'+@StrStats+';'+
					+@MultiUserMode;
				end
				else
				begin
					set @tsql=
					'RESTORE DATABASE ['+@DBNameTarget+']
						FROM  DISK = N'''+@FULLBACKUP+''' 
					 WITH  FILE = 1, '+@tsql2+'
					NORECOVERY, NOUNLOAD,  REPLACE'+@StrStats;
					--print (@tsql);
					exec (@tsql);
					set @tsql=
					'RESTORE DATABASE ['+@DBNameTarget+']
						FROM  DISK = N'''+@LASTBACKUP+''' 
					 WITH  FILE = 1, '+@tsql2+'
					'+@RecoveryState+', NOUNLOAD,  REPLACE'+@StrStats;
				end;
				--print (@tsql);
				exec (@tsql);
			END
			ELSE
				select 'Не удалось найти резервную копию для базы!!!'
		END
		ELSE
		BEGIN
			set @tsql='RESTORE DATABASE ['+@DBNameTarget+']	WITH RECOVERY';
			EXEC (@tsql);	
		END
	END
	ELSE
		set @NoRecovery=0;
	
	IF @NoRecovery=0
	BEGIN
		--после восстановления изменить модель восстановления на простую 
		--и прописать владельца базы (пользователь, под которым идёт обращение из приложения)
		SET @tsql=N'USE [master]
		ALTER DATABASE ['+@DBNameTarget+'] SET RECOVERY SIMPLE WITH NO_WAIT;';
		--print (@tsql);
		EXEC (@tsql);
		SET @tsql=N'USE ['+@DBNameTarget+'];
			IF EXISTS(select principal_id from sys.database_principals where [name]='''+@dbowner+''')'+
			CASE WHEN @VerMain < 11 THEN '
				exec sp_addrolemember ''db_owner'','''+@dbowner+''';' ELSE '
				ALTER ROLE [db_owner] ADD MEMBER ['+@dbowner+'];' END+'
			ELSE
				ALTER AUTHORIZATION ON DATABASE::['+@DBNameTarget+'] TO ['+@dbowner+'];';
		--print (@tsql);
		EXEC (@tsql);

		--Сжатие файлов Логов принудительно для восстановленной БД до 128 Мб.:
		EXEC sputnik.db_maintenance.usp_ShrinkLogFile 
				@db_name=@DBNameTarget, 
				@SetSizeMb=128,
				@FileGrowthMb=64
	END
END
GO
PRINT N'Creating Procedure [backups].[usp_SetupBackConf]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 12.02.2014 (1.0)
	-- Description: Эта процедура устанавливает настройки Резервного копирования в таблице sputnik.backups.BackConf.
					Может установить настройку для конкретных баз данных или для всех баз вообще.
					Перед установкой настроек происходит проверка существующих настроек (по имени БД и по типу бэкапа в столбце Kind).
					Если такая настройка уже есть, тогда новая настройка НЕ устанавливается.
					Но если задан параметр @Replace = 1, тогда настройка переписывается.
					Если в качестве типа бэкапа используется Diff, то производится две настройки: Diff в таблицу sputnik.backups.BackConf
						и Full в таблицу sputnik.backups.BackConfWeekly. Кроме этого, происходит очистка настройки Full в таблице sputnik.backups.BackConf для этих БД.
					В алгоритме используется новейшая инструкция MERGE и обобщённое табличное выражение CTE.
					Параметры:
						@DBNAME_in -имя БД, может быть не задано, тогда для всех БД на сервере;
						@TypeBack - тип бэкапа. Значение должно быть задано. Возможны след. значения: Full, Diff, Log.
						@Replace - если параметр задан = 1, то существующая настройка будет переписываться.
						@LocalDir - Каталог для бэкапов. Должен быть задан. 
						@NetDir - Каталог для копий бэкапов (обычно другой сетевой ресурс). Может быть НЕ задан.
						@LocalDays - сколько дней хранить файлы бэкапов в каталоге @LocalDir
						@NetDays - сколько дней хранить файлы копий бэкапов в каталоге @NetDir.
						@SubDirDBName - Если задан = 1, то к полному пути каталогов @LocalDir и @NetDir будет добавлен каталог с именем Базы 
							(поведение по умолчанию для случая, когда не задан параметр @DBNAME_in).
						@FullBackupDay - день недели для создания Полной копии БД. По умолчанию 7 - воскресенье. В остальные дни должны быть созданы Дифф. копии БД.
							Этот параметр необходим, только если в @TypeBack задан Diff.
		UPDATE:
				08.05.2014 (1.1)
					Добавлены новые параметры:
						@ForceSetWeek - Установка указанных настроек в таблицу BackConfWeek (пока без возможности месячных бэкапов).
						@LocalDaysWeek и @NetDaysWeek - Это настройки задаются в таблицу: сколько хранить бэкапы и копии бэкапов. 
												Нужно чтобы была возможность задать разные настройки для BackConf и BackConfWeek при
												установки Diff бэкапов.
				21.07.2014 (1.15)
					Новый параметр @ForceDelete - Если задан 1, то происходит удаление настроек (отбор по имени БД, типу бэкапа и в зависимости
					от параметров @ForceSetWeek и @ForceSetMonth удаляются настроки либо в BackConf, либо в BackConfWeek).
				22.07.2014 (1.20)
					Новый параметр @OnlyDiff - Если указан, то при установки настроек для Diff бэкапов, настройки для Full не будут
					прописаны в таблицу Weekly.
				27.07.2014 (1.22)
					Оптимизирован алгоритм удаления настроек (когда @ForceDelete=1). Добавлена возможность удаления конкретной настройки (если в @FullBackupDay
					задана эта настройка), или всех соотвествующих настроек (если @FullBackupDay=0).

				09.11.2014 (1.24)
					Изменения в алгоритме установки настроек для Weekly - теперь при установке или изменении настроек для Weekly, настройки Daily не удаляются
					- соответствующий код закомментирован. Т.к. теперь весь процесс контролируется программой Хьюстон.
				11.03.2016 (1.25)
					Обновления - добавлены параметры @LocalPolicy и @NetPolicy для установки политик ротаций в настройки бэкапов!
				25.08.2016 (1.26)
					Обновления - добавлена возможность установки бэкапов для системной базы model!
	-- ============================================= */
	CREATE PROCEDURE [backups].[usp_SetupBackConf] 
		@DBNAME_in nvarchar(300) = null
		,@TypeBack varchar(4)
		,@Replace bit = 0
		,@LocalDir nvarchar(500) = null
		,@NetDir nvarchar(500) = null
		,@LocalDays int = 6
		,@NetDays int = 5
		,@SubDirDBName bit=0
		,@FullBackupDay tinyint = 7
		,@ForceSetWeek bit=0
		,@ForceSetMonth bit=0
		,@LocalDaysWeek int = NULL
		,@NetDaysWeek int = NULL
		,@ForceDelete bit=0
		,@OnlyDiff bit=0 
		,@LocalPolicy smallint=0
		,@NetPolicy smallint=0
	AS
	BEGIN
		set nocount on;
		IF @ForceDelete=1 
		BEGIN
			IF @ForceSetMonth=0
			BEGIN
				IF @ForceSetWeek=0 
					DELETE FROM backups.BackConf
					WHERE DBName=@DBNAME_in AND Kind=@TypeBack
				ELSE
					DELETE FROM backups.BackConfWeekly
					WHERE DBName=@DBNAME_in AND Kind=@TypeBack 
						AND ((WeekDay=@FullBackupDay AND @FullBackupDay BETWEEN 1 AND 7) OR (@FullBackupDay=0 AND WeekDay BETWEEN 1 AND 7))
			END
			ELSE
				DELETE FROM backups.BackConfWeekly
				WHERE DBName=@DBNAME_in AND Kind=@TypeBack
					AND ((MonthDay=@FullBackupDay AND @FullBackupDay BETWEEN 1 AND 31) OR (@FullBackupDay=0 AND MonthDay BETWEEN 1 AND 31))
			return 1;
		END
		IF @LocalDir is null OR @LocalDir='' OR @TypeBack NOT IN ('Full','Diff','Log')
			return 0;
		IF CHARINDEX('\',@LocalDir,LEN(@LocalDir)-1)=0
			set @LocalDir=@LocalDir+'\';
		IF CHARINDEX('\',@NetDir,LEN(@NetDir)-1)=0
			set @NetDir=@NetDir+'\';
		IF @DBNAME_in = ''
			set @DBNAME_in = NULL;
		IF @LocalDaysWeek IS NULL 
			SET @LocalDaysWeek=@LocalDays;
		IF @NetDaysWeek IS NULL 
			SET @NetDaysWeek=@NetDays;

		IF @DBNAME_in is null
			set @SubDirDBName=1;
		IF @ForceSetWeek=0
		BEGIN
			WITH DBs 
			AS
				(
					select name, @TypeBack as Kind from sys.databases
					where (@DBNAME_in is null or name=@DBNAME_in) and (name not in ('tempdb')) and (state=0 and is_read_only=0)
							and (recovery_model_desc<>'SIMPLE' or @TypeBack<>'Log')
				)
			MERGE backups.BackConf AS target
			USING (	select 
						name, Kind,
						case when @SubDirDBName=1 then @LocalDir+name+'\' else @LocalDir end,
						case when @SubDirDBName=1 and @NetDir is not null  then @NetDir+name+'\' else @NetDir end,
						@LocalDays, @NetDays, @LocalPolicy, @NetPolicy from DBs
			) AS source (DBName,Kind,LocalDir,NetDir,LocalDays,NetDays, LocalPolicy, NetPolicy)
				ON (target.DBName=source.DBName and target.Kind=source.Kind)
			WHEN NOT MATCHED THEN
				INSERT (DBName,LocalDir,NetDir,LocalDays,NetDays,Kind, LocalPolicy, NetPolicy)
				VALUES (source.DBName,source.LocalDir,source.NetDir,source.LocalDays,source.NetDays,source.Kind, source.LocalPolicy, source.NetPolicy)
			WHEN MATCHED AND @Replace=1 THEN
				UPDATE SET LocalDir=source.LocalDir, NetDir=source.NetDir, LocalDays=source.LocalDays, NetDays=source.NetDays,
					LocalPolicy=source.LocalPolicy, NetPolicy=source.NetPolicy;
		END
		IF (@TypeBack='Diff' AND @OnlyDiff=0) OR @ForceSetWeek=1
		BEGIN
			WITH DBs 
			AS
				(
					select name, 'Full' as Kind from sys.databases
					where (@DBNAME_in is null or name=@DBNAME_in) and (name not in ('tempdb')) and (state=0 and is_read_only=0)
				)
			MERGE backups.BackConfWeekly AS target
			USING (	select 
						name, Kind,
						case when @SubDirDBName=1 then @LocalDir+name+'\' else @LocalDir end,
						case when @SubDirDBName=1 and @NetDir is not null  then @NetDir+name+'\' else @NetDir end,
						@LocalDaysWeek, @NetDaysWeek, @FullBackupDay, @LocalPolicy, @NetPolicy from DBs
			) AS source (DBName,Kind,LocalDir,NetDir,LocalDays,NetDays, WeekDay, LocalPolicy, NetPolicy)
				ON (target.DBName=source.DBName and target.Kind=source.Kind and target.WeekDay=source.WeekDay)
			WHEN NOT MATCHED THEN
				INSERT (DBName,LocalDir,NetDir,LocalDays,NetDays,Kind,WeekDay, LocalPolicy, NetPolicy)
				VALUES (source.DBName,source.LocalDir,source.NetDir,source.LocalDays,source.NetDays,source.Kind,source.WeekDay,source.LocalPolicy, source.NetPolicy)
			WHEN MATCHED AND @Replace=1 THEN
				UPDATE SET LocalDir=source.LocalDir, NetDir=source.NetDir, LocalDays=source.LocalDays, NetDays=source.NetDays,
					LocalPolicy=source.LocalPolicy, NetPolicy=source.NetPolicy;
		
			/*	При изменении или добавлении настроек в Weekly удалять соответствующие настройки из Daily теперь НЕ НУЖНО!
				Вся настройка производится из программы Хьюстон и полностью её контролируется!
				Поэтому код ниже закоментирован!
					WITH DBs 
					AS
						(
							select name, 'Full' as Kind from sys.databases
							where (@DBNAME_in is null or name=@DBNAME_in) and (name not in ('tempdb','model')) and (state=0 and is_read_only=0)
						)		
					DELETE Del
					FROM backups.BackConf AS Del
					INNER JOIN DBs
						ON Del.DBName=DBs.name and Del.Kind=DBs.Kind
			*/
		END
		return 1;
	END
GO
PRINT N'Creating Procedure [backups].[usp_RM]...';


GO

/* =============================================
-- Author:		Иванов Андрей (sql1c)
-- Create date: 20.04.2014 (1.0)
-- Description:	usp_RM - REPAIR MIRROR - настройка/ремонт Зеркалирования для указанной БД.
				В основе алгоритма - backup/restore базы с помощью функционала sputnik.
   Update:
				03.06.2014 (1.2)
				Переделан алгоритм восстановления зеркальной базы. Теперь используются Дифф. бэкапы, вместо полных.
				Что должно существенно экономить место на дисках обоих серверов и, самое главное, позволяет значительно
				ускорить процесс восстановления! Кроме того, в самом конце

				04.06.2014 (1.22)
				Добавлен алгоритм удаления информации о новом дифф. бэкапе из истории бэкапов! 
				А также в условие очистки добавлена проверка на существование настроек о дифф. бэкапе, которые
				могли остаться с прошлого неудачного запуска этой процедуры.

				10.07.2014 (1.3)
				Существенное изменение алгоритма создания бэкапов/восстановления зеркальной БД из бэкапов:
				Добавлена проверка существования ПОлного бэкапа (причём проверяется возраст: должен быть не старше 7 дней).
				Если полного бэкапа (свежего) нет, тогда он будет создан здесь же. ПРИ ЭТОМ Дифф. бэкап не создаётся!
				Иначе создаётся дифф. бэкап. Также в зависимости от свежести полного бэкапа: восстановление будет из полного 
				либо из полного и дифф. бэкапов.
				
				10.07.2014 (1.32)
				Добавлена проверка настроек Log бэкапов, если их нет, то они добавляются (на основе настроек Full бэкапов).

				31.01.2014 (1.35)
				Изменен алгоритм получения информации о полном бэкапе. Теперь эта информация берётся из новой ХП info.usp_GetLastBackups.
-- ============================================= */
CREATE PROCEDURE backups.usp_RM 
	@ServerProd NVARCHAR(200),
	@ServerMirror NVARCHAR(200),
	@DB NVARCHAR(300)
AS
BEGIN
	SET NOCOUNT ON;
	--Выполнять алгоритм от имени [sa], так как Linked Server должен быть привязан на этот логин.

	EXECUTE AS LOGIN = 'sa';
	
	--Отключаем Зеркалирование на 1-м и 2-м серверах;
	EXEC('
			EXEC
			(''IF EXISTS(SELECT database_id FROM sys.database_mirroring WHERE mirroring_guid IS NOT NULL AND database_id=DB_ID('''''+@DB+'''''))
					ALTER DATABASE ['+@DB+'] SET PARTNER OFF;
			'')
			AT ['+@ServerMirror+'.PECOM.LOCAL]
		');

	EXEC('
		IF EXISTS(SELECT database_id FROM sys.database_mirroring WHERE mirroring_guid IS NOT NULL AND database_id=DB_ID('''+@DB+'''))
				ALTER DATABASE ['+@DB+'] SET PARTNER OFF;
		');
	
	--Проверяем настройки для бэкапа LOg - если их Нет, то добавить!
	IF NOT EXISTS(SELECT [DBName] FROM sputnik.backups.BackConf WHERE Kind='Log' AND DBName=@DB)
	BEGIN
		INSERT INTO sputnik.backups.BackConf ([DBName], LocalDir, NetDir, LocalDays, NetDays, Kind)
		SELECT TOP 1
			[DBName], LocalDir+'LOG\', NetDir+'LOG\', 2, 2, 'Log' AS Kind
		FROM sputnik.backups.BackConf
		WHERE DBName=@DB
	END;

	--Делаем Бэкап Лога Боевой базы на 2-м сервере!
	EXEC	[sputnik].[backups].[usp_StartBackup]
			@type = N'Log',
			@DBFilter = @DB;
	--Сжимаем журнал транзакций сразу после Бэкапа на 2-м сервере:
	EXEC	[sputnik].[db_maintenance].[usp_ShrinkLogFile]
			@db_name = @DB,
			@SetSizeMb = 2048,
			@FileGrowthMb = 128
	--Отключаем Бэкапы Лога для базы на 2-м сервере!
	UPDATE [sputnik].[backups].[BackConf]
		SET [Kind]='XLog'
		WHERE [DBName]=@DB AND [Kind]='Log';

	--Проверяем: есть ли полный бэкап!
	DECLARE @TT TABLE ([DB_name] NVARCHAR(400), Backup_Type VARCHAR(4), BackupFile NVARCHAR(500), ID INT, BackupDate DATETIME2(2), LocalDir NVARCHAR(500), NetDir NVARCHAR(500), CheckLocalFile BIT, CheckNetFile BIT);
	INSERT INTO @TT
		EXEC sputnik.info.usp_GetLastBackups @DBName=@DB, @Backup_type='Full';

	DECLARE @FullBackupNetFile NVARCHAR(800);
	SELECT @FullBackupNetFile=NetDir+BackupFile
	FROM @TT
	WHERE 
		CheckNetFile = 1
		AND DATEDIFF(minute,BackupDate,SYSDATETIME()) < 10081
		
	DECLARE @NewConf bit = 0;
	--Если Полного Бэкапа нет, то создаём его!
	IF @FullBackupNetFile IS NULL
		EXEC	[sputnik].[backups].[usp_StartBackup]
			@type = N'Full',
			@DBFilter = @DB
	ELSE
	BEGIN
		/*	А если полный бэкап УЖЕ ЕСТЬ:
			Тогда вместо полного бэкапа делаем Дифф. Бэкап.
			При этом сначала проверяем и при необходимости создаём новые настройки
			(на основе настроек Full) для Дифф. Бэкапа в базе sputnik
		*/
		IF NOT EXISTS(SELECT [DBName] FROM sputnik.backups.BackConf WHERE Kind='Diff' AND DBName=@DB)
		BEGIN
			INSERT INTO sputnik.backups.BackConf ([DBName], LocalDir, NetDir, LocalDays, NetDays, Kind)
			SELECT [DBName], LocalDir, NetDir, 0, 0, 'Diff' AS Kind
			FROM sputnik.backups.BackConf
			WHERE  Kind='Full' AND DBName=@DB
			SET @NewConf=1;
		END
		--Делаем Дифф. Бэкап Боевой базы на 2-м сервере!
		EXEC	[sputnik].[backups].[usp_StartBackup]
			@type = N'Diff',
			@DBFilter = @DB
	END
	
	--Выполняем восстановление из Полной копии + Дифф. копии на первом сервере 
	--(в зависимости от того, когда был выполнен Полный бэкап: в этой процедуре или ранее!)
	DECLARE @FullDir NVARCHAR(500),@DiffDir NVARCHAR(500), @FullFile NVARCHAR(300), @DiffFile NVARCHAR(300), @CMD NVARCHAR(1100);
	IF @FullBackupNetFile IS NULL 
	BEGIN
		SELECT	@FullDir=NetDir
		FROM	sputnik.backups.BackConf
		WHERE	DBName = @DB AND Kind = 'Full';
		SELECT @FullFile=M.[Backup_File]+'.BAK'      
		FROM [sputnik].[backups].[BackupHistory] M
		INNER JOIN
			(
					SELECT [DB_Name], [Backup_Type], MAX(backup_finish_date) AS [BackupDate]
					FROM [sputnik].[backups].[BackupHistory]
					WHERE [DB_Name]=@DB AND [Backup_Type] = 'Full'
					GROUP BY [DB_Name], [Backup_Type]
			) G
		ON M.[DB_Name]=G.[DB_Name] AND M.Backup_Type=G.Backup_Type AND M.backup_finish_date=G.[BackupDate]
		SET @FullBackupNetFile=@FullDir+@FullFile;
	END
	ELSE
	BEGIN
	--Используем восстановление из Дифф. бэкапа, только если Полный бэкап уже был создан раньше, а не в этой процедуре.
		SELECT	@DiffDir=NetDir
		FROM	sputnik.backups.BackConf
		WHERE	DBName = @DB AND Kind = 'Diff';
		SELECT @DiffFile=M.[Backup_File]+'.BAK'      
		FROM [sputnik].[backups].[BackupHistory] M
		INNER JOIN
			(
					SELECT [DB_Name], [Backup_Type], MAX(backup_finish_date) AS [BackupDate]
					FROM [sputnik].[backups].[BackupHistory]
					WHERE [DB_Name]=@DB AND [Backup_Type] = 'Diff'
					GROUP BY [DB_Name], [Backup_Type]
			) G
		ON M.[DB_Name]=G.[DB_Name] AND M.Backup_Type=G.Backup_Type AND M.backup_finish_date=G.[BackupDate]
	END
	--Восстановление из Полного Бэкапа
	EXEC('
			EXEC
			(''
				EXEC [sputnik].[backups].[usp_RestoreDB_simple] 
				@DBNameTarget=N'''''+@DB+''''', 
				@FromDisk=N'''''+@FullBackupNetFile+''''',
				@NoRecovery=1 	
			'')
			AT ['+@ServerMirror+'.PECOM.LOCAL]
		');
	IF @DiffFile IS NOT NULL
		--Восстановление из Дифф Бэкапа
		EXEC('
				EXEC
				(''
					EXEC [sputnik].[backups].[usp_RestoreDB_simple] 
					@DBNameTarget=N'''''+@DB+''''', 
					@FromDisk=N'''''+@DiffDir+@DiffFile+''''',
					@NoRecovery=1,
					@DiffBack=1 	
				'')
				AT ['+@ServerMirror+'.PECOM.LOCAL]
			');

	--Делаем Бэкап Лога БОЕВОЙ базы на 2-м сервере!
	--Включаем Бэкапы Лога для боевой базы на 2-м сервере!
	UPDATE [sputnik].[backups].[BackConf]
		SET [Kind]='Log'
		WHERE [DBName]=@DB AND [Kind]='XLog';
	EXEC	[sputnik].[backups].[usp_StartBackup]
			@type = N'Log',
			@DBFilter = @DB;
	--Отключаем Бэкапы Лога для базы на 2-м сервере!
	UPDATE [sputnik].[backups].[BackConf]
		SET [Kind]='XLog'
		WHERE [DBName]=@DB AND [Kind]='Log';
	--Восстанавливаем последний Бэкап Лога на первом сервере!
	DECLARE @Dir NVARCHAR(500), @File NVARCHAR(300);
	SELECT
		  @File=[Backup_File]+'.BAK'     
	FROM [sputnik].[backups].[BackupHistory]
	WHERE
		ID = (
				SELECT ID
				FROM [sputnik].[backups].[BackupHistory]
				WHERE
					[DB_Name]=@DB
					AND [Backup_Type]='Log' 
					AND [backup_finish_date] = (SELECT 
													MAX(backup_finish_date)
												FROM [sputnik].[backups].[BackupHistory]
												WHERE
													[DB_Name]=@DB
													AND [Backup_Type]='Log' 
												)
			)
	SELECT	@Dir=NetDir
	FROM	sputnik.backups.BackConf
	WHERE	DBName = @DB AND Kind = 'XLog';
	EXEC('
			EXEC
			(''
				EXEC [sputnik].[backups].[usp_RestoreDB_simple] 
				@DBNameTarget=N'''''+@DB+''''', 
				@FromLog=N'''''+@Dir+@File+''''',
				@NoRecovery=1 	
			'')
			AT ['+@ServerMirror+'.PECOM.LOCAL]
		')
	
	--Создаём  EndPoint для Зеркалирования (если его нет) на 1-м и 2-м серверах.
	EXEC('
			IF NOT EXISTS (SELECT endpoint_id FROM sys.endpoints WHERE name = ''EndPoint_Mirroring'')
				CREATE ENDPOINT [EndPoint_Mirroring]
					STATE=started
					AS TCP (listener_port=5022, listener_ip=all)
					FOR database_mirroring (role=partner, authentication=windows negotiate, encryption=required algorithm AES);
		');
	EXEC('
			EXEC(''
				IF NOT EXISTS (SELECT endpoint_id FROM sys.endpoints WHERE name = ''''EndPoint_Mirroring'''')
					CREATE ENDPOINT [EndPoint_Mirroring]
						STATE=started
						AS TCP (listener_port=5022, listener_ip=all)
						FOR database_mirroring (role=partner, authentication=windows negotiate, encryption=required algorithm AES);
				'')
			AT ['+@ServerMirror+'.PECOM.LOCAL];
		');

	--Включаем Зеркалирование сначала на 1-м сервере, а затем на 2-м (боевом):
	EXEC('
			EXEC
			(''
				ALTER DATABASE ['+@DB+'] SET PARTNER = N''''TCP://'+@ServerProd+'.PECOM.LOCAL:5022'''';
			'')
			AT ['+@ServerMirror+'.PECOM.LOCAL]
	');
	EXEC
		('
			ALTER DATABASE ['+@DB+'] SET PARTNER = N''TCP://'+@ServerMirror+'.PECOM.LOCAL:5022'';
		');

	--Включаем Бэкапы Лога для боевой базы на 2-м сервере!
	UPDATE [sputnik].[backups].[BackConf]
		SET [Kind]='Log'
		WHERE [DBName]=@DB AND [Kind]='XLog';

	--В самом конце делаем очистку от Дифф. бэкапов и удаляем настройки, 
	--только если они были созданы в этой же процедуре ИЛИ существует точно такая же настройка с предыдущего неудачного запуска!

	IF @NewConf=1 OR EXISTS(SELECT DBName FROM sputnik.backups.BackConf WHERE DBName=@DB AND Kind='Diff' AND LocalDays=0 AND NetDays=0 )
	BEGIN
		EXEC sputnik.backups.[usp_CleaningBack] @DBFilter=@DB, @type='Diff';
		
		DELETE 
		FROM sputnik.backups.BackConf
		WHERE DBName=@DB AND Kind='Diff';

		--Дополнительно удаляем из истории Бэкапов информацию о созданном Дифф. бэкапе
		DELETE [sputnik].[backups].[BackupHistory]
		WHERE [ID] = 
		(	SELECT M.[ID]      
			FROM [sputnik].[backups].[BackupHistory] M
			INNER JOIN
			(
					SELECT [DB_Name], [Backup_Type], MAX(backup_finish_date) AS [BackupDate]
					FROM [sputnik].[backups].[BackupHistory]
					WHERE [DB_Name]=@DB AND [Backup_Type] = 'Diff'
					GROUP BY [DB_Name], [Backup_Type]
			) G
			ON M.[DB_Name]=G.[DB_Name] AND M.Backup_Type=G.Backup_Type AND M.backup_finish_date=G.[BackupDate]
		);
	
	END
END
GO
PRINT N'Creating Procedure [backups].[usp_GC]...';


GO

/* =============================================
-- Author:		Андрей Иванов (sqland1c)
-- Create date: 23.04.2014 (1.0)
-- Description: usp_GC - GetCopy. Эта процедура позволяет поднять копию базы на локальном сервере на указанный момент времени.
				В основе - восстановление по процедуре usp_RestoreDB_simple (восстановление из Полного бэкапа и из бэкапов Логов).
				Используется информация из базы sputnik, чтобы определить необходимую цепочку бэкапов для восстановления.
				То есть, для успешного выполнения вся необходимая информация должна быть в базе sputnik.
				Параметры:
					@DBNameSource - обязательный параметр, это имя базы источника (откуда делаем копию данных);
					@DBNameTarget - необязательный параметр, это имя базы назначения (куда загружам данные). Если не задан, то имя будет
					сформировано автоматически по следующими принципу: @DBNameTarget + дата и время последнего загруженого бэкапа.
					@ServerTarget ???
					@ToDate - необязательный параметр. Это дата и время, на которое нужно сделать копию данных. Если не задан, то текущее
					системное время.
-- Update:
				25.04.2014 (1.1)
				Добавлен оптимизированный алгоритм получения наиболее подходящего каталога с бэкапами через новую функцию info.uf_GetBackConf.

-- ============================================= */
CREATE PROCEDURE [backups].[usp_GC]  
	@DBNameSource nvarchar(300),
	@DBNameTarget nvarchar(300)=NULL,
	@ToDate datetime2(2)=NULL
AS
BEGIN
	SET NOCOUNT ON;
	IF @ToDate IS NULL
		SET @ToDate=SYSDATETIME();
	DECLARE @Dir NVARCHAR(500), @File NVARCHAR(300), @FullPath NVARCHAR(800), @BackupID INT, @BackupFinishDate DATETIME2(2), @BackupStartDate DATETIME2(2), @NetDir NVARCHAR(500);
	DECLARE @WeekDay tinyint, @MonthDay tinyint;

	--Получаем каталог и файл полного бэкапа (по информации из базы sputnik на боевом сервере).
	SELECT
		  @File=[Backup_File]+'.BAK', @BackupID=ID, @BackupFinishDate=backup_finish_date, @BackupStartDate=backup_start_date   
	FROM [sputnik].[backups].[BackupHistory]
	WHERE
		ID = (
				SELECT ID
				FROM [sputnik].[backups].[BackupHistory]
				WHERE
					[DB_Name]=@DBNameSource
					AND [Backup_Type]='Full' 
					AND [backup_finish_date] = (SELECT 
													MAX(backup_finish_date)
												FROM [sputnik].[backups].[BackupHistory]
												WHERE
													[DB_Name]=@DBNameSource
													AND [Backup_Type]='Full'
													AND [backup_finish_date] <= @ToDate
												)
			);

	--Получаем наиболее подходящий Каталог с полными бэкапами через новую функцию
	SELECT @Dir=LocalDir, @NetDir=NetDir
	FROM info.uf_GetBackConf (@DBNameSource,'Full', @BackupFinishDate);
	
	SET @FullPath=@Dir+@File;
	
	--Получение цепочки бэкапов Логов для восстановления (опять же из базы sputnik боевого сервера)
	SELECT BACKUP_File, Backup_Finish_Date
	INTO #T_Logs
	FROM [sputnik].[backups].[BackupHistory]
	WHERE
		DB_NAME=@DBNameSource 
		AND database_backup_lsn=(
			SELECT MIN(database_backup_lsn)
			FROM [sputnik].[backups].[BackupHistory]
			WHERE DB_NAME=@DBNameSource
			AND database_backup_lsn>
				(
					SELECT [database_backup_LSN]
					FROM [sputnik].[backups].[BackupHistory]
					WHERE ID=@BackupID
				)
			)
		AND [Backup_Type]='Log'
		AND [Backup_Finish_Date]<=@ToDate
	ORDER BY last_LSN;
	
	--Восстановление. Если Бэкапы Логов не обнаружены, то просто восстанавливаем полный бэкап.
	IF NOT EXISTS(SELECT [Backup_File] FROM #T_Logs)
	BEGIN
		--Формирование имени новой базы (если не задана)
		IF @DBNameTarget IS NULL
			SET @DBNameTarget=@DBNameSource+'_COPY_'+CONVERT(VARCHAR(8), @BackupFinishDate, 112)+'_'+REPLACE(CONVERT(VARCHAR(20), @BackupFinishDate, 108), ':', '');

		EXEC [sputnik].[backups].[usp_RestoreDB_simple] 
			@DBNameTarget=@DBNameTarget, 
			@FromDisk=@FullPath;
	END
	ELSE
	BEGIN
		--Восстановление из полного бэкапа и цепочки бэкапов Логов.
		IF @DBNameTarget IS NULL
		BEGIN
			--Формирование имени новой базы (если не задана)
			SELECT @BackupFinishDate=MAX([Backup_Finish_Date])
			FROM #T_Logs;
			SET @DBNameTarget=@DBNameSource+'_COPY_'+CONVERT(VARCHAR(8), @BackupFinishDate, 112)+'_'+REPLACE(CONVERT(VARCHAR(20), @BackupFinishDate, 108), ':', '');
		END
		PRINT ('********************************
				Восстановление ПОЛНОГО Бэкапа: '+@FullPath);
		EXEC [sputnik].[backups].[usp_RestoreDB_simple] 
			@DBNameTarget=@DBNameTarget, 
			@FromDisk=@FullPath,
			@NoRecovery=1;
			 	
		DECLARE RE CURSOR FOR
			SELECT [Backup_File]+'.BAK' AS [BackupFile],
					[Backup_Finish_Date]
			FROM #T_Logs;
		OPEN RE;
		FETCH NEXT FROM RE 
		INTO @File, @BackupFinishDate;
		WHILE @@FETCH_STATUS=0
		BEGIN
			--Получаем наиболее подходящий Каталог с полными бэкапами через новую функцию
			SELECT @Dir=LocalDir, @NetDir=NetDir
			FROM info.uf_GetBackConf (@DBNameSource,'Log', @BackupFinishDate);

			SET @FullPath=@Dir+@File;

			PRINT ('********************************
					Восстановление Бэкапа Лога: '+@FullPath);

			EXEC [sputnik].[backups].[usp_RestoreDB_simple] 
				@DBNameTarget=@DBNameTarget, 
				@FromLog=@FullPath,
				@NoRecovery=1
			FETCH NEXT FROM RE 
			INTO @File, @BackupFinishDate;
		END
		CLOSE RE;
		DEALLOCATE RE;
		--Перевод базы данных в режим RECOVERY
		PRINT ('********************************
				Перевод новой базы в режим ONLINE');
		EXEC [sputnik].[backups].[usp_RestoreDB_simple] 
			@DBNameTarget=@DBNameTarget, 
			@ForceRecovery=1
	END;
END
GO
PRINT N'Creating Procedure [backups].[usp_GC2]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 04.08.2014 (2.0)
	-- Description: usp_GC2 - GetCopy (Новая!). Эта процедура позволяет поднять копию базы на локальном сервере на указанный момент времени.
					В новой версии появилась возможность поднимать копию Базы с удалённого сервера источника!! Кроме этого, в новой версии теперь используются Дифф. бэкапы!
					При необходимости создается новый бэкап (полный или дифф.) чтобы быстрее получиться копию БД на последний момент времени!

					В основе - восстановление по процедуре usp_RestoreDB_simple (восстановление из Полного бэкапа, Дифф. бэкапа и из бэкапов Логов).
					Используется информация из базы sputnik, чтобы определить необходимую цепочку бэкапов для восстановления.
					То есть, для успешного выполнения вся необходимая информация должна быть в базе sputnik (то есть резервное копирование
					для боевой БД должно быть настроено в базе sputnik).
					Параметры:
						@DBNameSource - обязательный параметр, это имя базы источника (откуда делаем копию данных);
						@DBNameTarget - необязательный параметр, это имя базы назначения (куда загружам данные). Если не задан, то имя будет
						сформировано автоматически по следующими принципу: @DBNameTarget + дата и время последнего загруженого бэкапа.
						@ServerSource - необязательный параметр, это имя сервера, где находится боевая БД, из которой нужно сделать копию!
						Должно быть настроено Linked Server для успешной работы этого механизма! Если этот параметр НЕ задан, предполагается
						что база данных источник и целевая база данных находятся на одном и том же сервере!
						@ToDate - необязательный параметр. Это дата и время, на которое нужно сделать копию данных. Если не задан, то текущее
						системное время.
						@FromCopy - указывает, что нужно использовать каталог с копиями бэкапов (NetDir), а не с самими бэкапами (LocalDir).
						@RunNewBackIfNeed - Необходимость создания новых бэкапов Полный или Дифф. для ускорения восстановления БД на последний
						момент времени.
						@FreshBack - указывает требования к "свежести" Дифф. бэкапа. Если дифф. бэкап был создан более 8 часов назад, то будет создан
						новый дифф. бэкап (если задан разрешающий параметр @RunNewBackIfNeed).
						@lse - специальный параметр, определяет, что вызов этой процедуры произведен из модуля LSE (Log Shipping Easy). В этом случае,
						будет записана информация о последней восстановленном бэкапе!
	-- Update:
						05.08.2014 (2.1)
						Оптимизирован алгоритм восстановления через процедуру usp_RestoreDB_simple. Теперь после восстановления БД из полного бэкапа
						все последующие бэкапы должны восстанавливаться быстрее, т.к. используется новый параметр @NoFileList=1, который говорит
						о том, что все данные о файлах целевой БД будут получены из системного представления sys.master_files, а не из бэкапов.
					
						05.08.2014 (2.12) Добавлен новый параметр @RM для запуска из процедуры Восстановления/Настройки Зеркалирования.
						Если этот параметр задан, тогда дополнительно будет создан (и восстановлен) последний бэкап Лога! При этом настройки
						для бэкапов Логов будут включены и снова отключены!

						05.08.2014 (2.13) Небольшое исправление при формировании информации о Дифф. бэкапе - добавлены дополительные проверки,
						чтобы определить есть ли Дифф. бэкап вообще.

						06.08.2014 (2.15) Изменен алгоритм включения/выключения настройки Бэкапов логов на удалённом сервере, если используется 
						параметр @RM. Теперь SELECT и UPDATE выполняются в двух разных инструкциях OPENQUERY. При этом на время обновления 
						устанавливается параметр XACT_ABORT=ON (нужен для выполнения UPDATE в OPENQUERY).

						07.08.2014 (2.17) Исправлена ошибка при формировании полного бэкапа (если его нет) на удаленном сервере!
						Также добавлен новый параметр @pp - если задан, значит процесс запущен в многопоточном режиме через модуль pp.
						В этом случае нужно выводить как можно меньше сообщений пользователю!

						13.11.2014 (2.18) Во все вызовы модуля [usp_RunBack] добавлен параметр @ForceCopy - чтобы после создания бэкапа
						сразу было произведено его КОПИРОВАНИЕ (теперь через новый модуль).

						18.03.2015 (2.20) Добавлен новый параметр @StandBy_File - для поддержки режима STANDBY (read-only) для восстанавливаемой БД. Может применяться
						в механизме lse.

						20.11.2015 (2.21) Добавлен новый параметр @MoveLogFilesTo, теперь Log-файлы можно расположить на отдельном диске.
						Этот параметр уже поддерживается в процедуре [usp_RestoreDB_simple].

						12.01.2016 (2.22) Небольшое исправление в связи с изменением зависимой процедуры usp_GetLastBackups

						28.02.2017 (2.230) Новый параметр @dbowner - теперь можно указать владельца новой базы (по умолчанию sa).

						10.11.2017 (2.233) Выполнены оптимизации в алгоритмах формирования новых бэкапов:
						Изменены требования к свежести полного и/или дифф. бэкапов: c 2 до 12 часов (полный), с 2 до 8 часов (дифф.)!
						Также внесены исправления в формирование настроек по дифф.бэкапу (если таких настроек ещё нет):
						теперь будет хранится 1 файл (политика ротации 1-по количеству файлов).
						Также сразу после создания Дифф.бэкапа добавлен запуск Ротации по Дифф.бэкапам, чтобы не засорять Дифф.бэкапами весь диск!

						10.11.2017 (2.234) Добавлен новый параметр @RunNewDiffBackIfNeed - разрешение на выполнение Дифф.бэкапа.
						Разрешение на выполнение полного бэкапа даёт уже существующий параметр @RunNewBackIfNeed
	-- ============================================= */
	CREATE PROCEDURE [backups].[usp_GC2]  
		@DBNameSource nvarchar(300),
		@DBNameTarget nvarchar(300)=NULL,
		@ServerSource nvarchar(300)=NULL,
		@ToDate datetime2(2)=NULL,
		@FromCopy bit=0,
		@RunNewBackIfNeed bit=0,
		@FreshBack bit=0,
		@NoRecovery bit=0,
		@MoveFilesTo nvarchar(500)=NULL,
		@MoveLogFilesTo nvarchar(500)=NULL,
		@lse bit=0,
		@RM bit=0,
		@pp bit=0,
		@StandBy_File nvarchar(500)=null,
		@dbowner nvarchar(50)='sa',
		@RunNewDiffBackIfNeed bit=0
	AS
	BEGIN
		SET NOCOUNT ON;
		DECLARE @LocalServer NVARCHAR(500)=CAST(SERVERPROPERTY('ServerName') AS NVARCHAR(500));
		DECLARE @lseInitDate datetime2(2)=sysdatetime();
		DECLARE @Dir NVARCHAR(500), @File NVARCHAR(300), @FullPath NVARCHAR(800),@DiffPath NVARCHAR(800), @BackupFullID INT, @BackupDiffID int, @BackupFullFinishDate DATETIME2(2), @BackupDiffFinishDate DATETIME2(2), @NetDir NVARCHAR(500);
		DECLARE @WeekDay tinyint, @MonthDay tinyint, @NewFB bit=0, @NewConf bit=0, @NewDB bit=0;
		DECLARE @OldBackupHH smallint;
		DECLARE @pToDate NVARCHAR(75);
		DECLARE @StrErr NVARCHAR(900);
		IF @ToDate IS NULL
			SET @pToDate='NULL';
		ELSE
			SET @pToDate=''''''+CONVERT(NVARCHAR(75),@ToDate,121)+'''''';
		--Получаем всю информацию о последних полном и дифф. (если есть) бэкаках (по информации из базы sputnik на боевом сервере).
		DECLARE @TT TABLE ([DB_name] NVARCHAR(400), Backup_Type VARCHAR(4), BackupFile NVARCHAR(500), ID INT, BackupDate DATETIME2(2), LocalDir NVARCHAR(500), NetDir NVARCHAR(500), CheckLocalDir BIT, CheckNetDir BIT, CheckLocalFile BIT, CheckLocalFileOnly BIT, CheckNetFile BIT);
		IF @ServerSource IS NULL OR @ServerSource=@LocalServer
			INSERT INTO @TT
				EXEC sputnik.info.usp_GetLastBackups @DBName=@DBNameSource, @ToDate=@ToDate;
		ELSE
			INSERT INTO @TT
				EXEC ('	SELECT *
						FROM OPENQUERY(['+@ServerSource+'], '' EXEC sputnik.info.usp_GetLastBackups @DBName=N'''''+@DBNameSource+''''', @ToDate='+@pToDate+';'')
					 ');
		SELECT @BackupFullID=ID, @BackupFullFinishDate=BackupDate,  
			@FullPath=case when @FromCopy=0 OR NetDir is null OR NetDir='' then LocalDir+BackupFile else NetDir+BackupFile end
		FROM @TT
		WHERE Backup_Type='Full'
			AND (((@FromCopy=0 OR NetDir is null OR NetDir='') AND CheckLocalFile=1) OR ((@FromCopy=1 AND CheckNetFile=1)));

		--Если полного бэкапа нет, тогда нужно его сделать (если включен разрешающий параметр)!!
		IF @FullPath IS NULL AND @RunNewBackIfNeed=1 AND @ToDate IS NULL
			begin try	
				IF @ServerSource IS NULL OR @ServerSource=@LocalServer
					EXEC sputnik.backups.usp_RunBack @DBName_in=@DBNameSource, @TypeBack='Full', @OnlyFull=1, @ForceCopy=1;
				ELSE
					EXEC ('
						  EXEC(''
								EXEC sputnik.backups.usp_RunBack @DBName_in=N'''''+@DBNameSource+''''', @TypeBack=''''Full'''', @OnlyFull=1, @ForceCopy=1;
						  '') AT ['+@ServerSource+']
					');
				SET @NewFB=1;	
			end try
			begin catch
				SET @StrErr=N'Ошибка при попытке выполнить полный бэкап в ХП [usp_GC2]! Текст ошибки: '+ERROR_MESSAGE();
				RAISERROR(@StrErr,11,1) WITH LOG
			end catch
		--Если полный бэкап уже есть, тогда попробуем найти бэкап DIFF, если такого нет, то нужно его сделать (если включен разрешающий параметр). 
		ELSE IF @FullPath IS NOT NULL
		BEGIN
			--Обработку дифф. бэкапа производится только, если Полный бэкап старше 12 часов! Иначе быстрее восстановить из полного без создания Дифф!
			IF @ToDate IS NULL
				SET @OldBackupHH = DATEDIFF(MINUTE,@BackupFullFinishDate,SYSDATETIME());
			ELSE
				SET @OldBackupHH = DATEDIFF(MINUTE,@BackupFullFinishDate,@ToDate);
			IF @OldBackupHH>12*60
			BEGIN
				SELECT @BackupDiffID=ID, @BackupDiffFinishDate=BackupDate,  
				@DiffPath=case when @FromCopy=0 OR NetDir is null OR NetDir='' then LocalDir+BackupFile else NetDir+BackupFile end
				FROM @TT
				WHERE Backup_Type='Diff' AND BackupDate > @BackupFullFinishDate
					AND (((@FromCopy=0 OR NetDir is null OR NetDir='') AND CheckLocalFile=1) OR ((@FromCopy=1 AND CheckNetFile=1)))
					AND (@FreshBack=0 OR DATEDIFF(MINUTE,BackupDate,SYSDATETIME())<8*60)
				IF @DiffPath IS NULL AND @RunNewDiffBackIfNeed=1 AND @ToDate IS NULL
					begin try	
						--если настроек по Diff нет, тогда временно создадим их!
						DECLARE @TTD TABLE (DB NVARCHAR(300));
						IF @ServerSource IS NULL OR @ServerSource=@LocalServer
							INSERT INTO @TTD
							SELECT [DBName] AS DB FROM sputnik.backups.BackConf WHERE Kind='Diff' AND DBName=@DBNameSource;
						ELSE
							INSERT INTO @TTD
							EXEC('SELECT [DBName] AS DB
								  FROM OPENQUERY(['+@ServerSource+'], ''SELECT [DBName] FROM sputnik.backups.BackConf WHERE Kind=''''Diff'''' AND DBName=N'''''+@DBNameSource+''''';'')
								  ');
						IF NOT EXISTS(SELECT DB FROM @TTD)
						BEGIN
							IF @ServerSource IS NULL OR @ServerSource=@LocalServer
								INSERT INTO sputnik.backups.BackConf ([DBName], LocalDir, NetDir, LocalDays, NetDays, Kind, [LocalPolicy],[NetPolicy])
								SELECT [DBName], LocalDir, NetDir, 1, 1, 'Diff' AS Kind, 1, 1
								FROM sputnik.backups.BackConf
								WHERE  Kind='Full' AND DBName=@DBNameSource
							ELSE
								EXEC ('
									EXEC(''
										INSERT INTO sputnik.backups.BackConf ([DBName], LocalDir, NetDir, LocalDays, NetDays, Kind, [LocalPolicy],[NetPolicy])
										SELECT [DBName], LocalDir, NetDir, 1, 1, ''''Diff'''' AS Kind, 1, 1
										FROM sputnik.backups.BackConf
										WHERE  Kind=''''Full'''' AND DBName=N'''''+@DBNameSource+''''';
									'') AT ['+@ServerSource+']
								');
							SET @NewConf=1;
						END
						--Делаем Дифф. Бэкап Боевой базы на локальном ИЛИ удалённом сервере:
						--При этом сразу после создания Бэкапа запустим Ротацию по Дифф.бэкапам, чтобы не занять весь диск!
						IF @ServerSource IS NULL OR @ServerSource=@LocalServer
						BEGIN
							EXEC sputnik.backups.usp_RunBack @DBName_in=@DBNameSource, @TypeBack='Diff', @ForceCopy=1;
							EXEC sputnik.backups.[usp_CleaningBack] @DBFilter=@DBNameSource, @type='Diff';
						END
						ELSE
							EXEC ('
								EXEC(''
									EXEC sputnik.backups.usp_RunBack @DBName_in=N'''''+@DBNameSource+''''', @TypeBack=''''Diff'''', @ForceCopy=1;
									EXEC sputnik.backups.[usp_CleaningBack] @DBFilter=N'''''+@DBNameSource+''''', @type=''''Diff'''';
								'') AT ['+@ServerSource+']
							');
						SET @NewDB=1;	
					end try
					begin catch
						SET @StrErr=N'Ошибка при попытке сформировать Дифф. бэкап в ХП [usp_GC2]! Текст ошибки: '+ERROR_MESSAGE();
						RAISERROR(@StrErr,11,1) WITH LOG
					end catch
			END
		END
		--Проверяем, если Полный или Дифф. бэкап создавались заново, нужно снова получить инфу о последних бэкапах!
		IF @NewDB=1 OR @NewFB=1
		BEGIN
			DELETE FROM @TT;
			IF @ServerSource IS NULL OR @ServerSource=@LocalServer
				INSERT INTO @TT
					EXEC sputnik.info.usp_GetLastBackups @DBName=@DBNameSource, @ToDate=@ToDate;
			ELSE
				INSERT INTO @TT
					EXEC ('	SELECT *
							FROM OPENQUERY(['+@ServerSource+'], ''EXEC sputnik.info.usp_GetLastBackups @DBName=N'''''+@DBNameSource+''''', @ToDate='+@pToDate+';'')
						');
			IF @NewFB=1
			BEGIN
				SELECT @File=BackupFile, @BackupFullID=ID, @BackupFullFinishDate=BackupDate,  
					@Dir=case when  @FromCopy=0 OR NetDir is null OR NetDir='' then LocalDir else NetDir end
				FROM @TT
				WHERE Backup_Type='Full'
					AND (((@FromCopy=0 OR NetDir is null OR NetDir='') AND CheckLocalFile=1) OR ((@FromCopy=1 AND CheckNetFile=1)));
				SET @FullPath=@Dir+@File;
			END
			IF @NewDB=1
			BEGIN 
				SELECT @File=BackupFile, @BackupDiffID=ID, @BackupDiffFinishDate=BackupDate,  
				@Dir=case when @FromCopy=0 OR NetDir is null OR NetDir='' then LocalDir else NetDir end
				FROM @TT
				WHERE Backup_Type='Diff' AND BackupDate > @BackupFullFinishDate
				AND (((@FromCopy=0 OR NetDir is null OR NetDir='') AND CheckLocalFile=1) OR ((@FromCopy=1 AND CheckNetFile=1)));
				IF @@ROWCOUNT>0
					SET @DiffPath=@Dir+@File;
				ELSE
					SET @DiffPath=NULL;
			END
		END			
	
		IF @FullPath IS NULL
			return 0;

		--Если выполняется Восстановление/Настройка Зеркалирования, нужно обязательно создать последний бэкап Лога!
		IF @RM=1
		BEGIN
			DECLARE @LogOff TABLE(DBName nvarchar(300));
			IF @ServerSource IS NULL OR @ServerSource=@LocalServer
			BEGIN
				begin try
					UPDATE [sputnik].[backups].[BackConf]
					SET [Kind]='Log'
					OUTPUT inserted.[DBName] into @LogOff
					WHERE [DBName]=@DBNameSource AND [Kind]='XLog';
					EXEC sputnik.backups.usp_RunBack @DBName_in=@DBNameSource, @TypeBack='Log', @ForceCopy=1;
				end try
				begin catch
					SET @StrErr=N'Ошибка при попытке сформировать последний бэкап Лога в ХП [usp_GC2]! Текст ошибки: '+ERROR_MESSAGE();
					RAISERROR(@StrErr,11,1) WITH LOG
				end catch
			END
			ELSE
				begin try
					INSERT INTO @LogOff
					EXEC ('	SELECT DBName
							FROM OPENQUERY(['+@ServerSource+'], ''SELECT DBName 
																  FROM [sputnik].[backups].[BackConf] 
																  WHERE [DBName]=N'''''+@DBNameSource+''''' AND [Kind]=''''XLog'''';'')
						');
					IF EXISTS(SELECT DBname FROM @LogOff)
					BEGIN
						SET XACT_ABORT ON;
						EXEC ('	UPDATE OPENQUERY(['+@ServerSource+'], ''SELECT [Kind]
																		FROM [sputnik].[backups].[BackConf] 
																		WHERE [DBName]=N'''''+@DBNameSource+''''' AND [Kind]=''''XLog'''';'')
								SET [Kind]=''Log''
			 			');
						SET XACT_ABORT OFF;
					END	
					EXEC ('
						EXEC(''
							EXEC sputnik.backups.usp_RunBack @DBName_in=N'''''+@DBNameSource+''''', @TypeBack=''''Log'''', @ForceCopy=1;
						'') AT ['+@ServerSource+']
					');
				end try
				begin catch
					SET @StrErr=N'Ошибка при попытке сформировать последний бэкап Лога в ХП [usp_GC2]! Текст ошибки: '+ERROR_MESSAGE();
					RAISERROR(@StrErr,11,1) WITH LOG
				end catch
		END

		--Формируем цепочку бэкапов для восстановления
		DECLARE @ChainBack TABLE (BackupFile NVARCHAR(800), BackupType VARCHAR(4), ID INT, BackupDate DATETIME2(2));	
		INSERT INTO @ChainBack (BackupFile, BackupType, ID, BackupDate)
		VALUES (@FullPath, 'Full', @BackupFullID, @BackupFullFinishDate);
		IF @DiffPath IS NOT NULL
			INSERT INTO @ChainBack (BackupFile, BackupType, ID, BackupDate)
			VALUES (@DiffPath, 'Diff', @BackupDiffID, @BackupDiffFinishDate);
		IF @ServerSource IS NULL OR @ServerSource=@LocalServer
			INSERT INTO @ChainBack (BackupFile, BackupType, ID, BackupDate)
				EXEC sputnik.info.usp_GetChainLogs @DBName=@DBNameSource, @BackupFullID=@BackupFullID, @FilterBackupID=@BackupDiffID, @ToDate=@ToDate, @fromcopy=@fromcopy;
		ELSE
		BEGIN
			DECLARE @strP VARCHAR(300);
			IF @BackupDiffID IS NOT NULL
				SET @strP='@BackupFullID='+CAST(@BackupFullID AS VARCHAR(40))+', @FilterBackupID='+CAST(@BackupDiffID AS NVARCHAR(40))+', @fromcopy='+CAST(@fromcopy AS VARCHAR(1));
			ELSE
				SET @strP='@BackupFullID='+CAST(@BackupFullID AS VARCHAR(40))+', @FilterBackupID=NULL, @fromcopy='+CAST(@fromcopy AS VARCHAR(1));
			INSERT INTO @ChainBack (BackupFile, BackupType, ID, BackupDate)
				EXEC ('	SELECT *
						FROM OPENQUERY(['+@ServerSource+'] ,''EXEC sputnik.info.usp_GetChainLogs @DBName=N'''''+@DBNameSource+''''',  @ToDate='+@pToDate+', '+@strP+';'')
					 ');
		END
		--После формирования цепочки бэкапов, для режима восстановления/настройки Зеркалирования отключим настройки бэкапов Логов
		IF @RM=1
		BEGIN
			IF EXISTS(SELECT DBName FROM @LogOff)
				IF @ServerSource IS NULL OR @ServerSource=@LocalServer
					UPDATE [sputnik].[backups].[BackConf]
					SET [Kind]='XLog'
					WHERE [DBName]=@DBNameSource AND [Kind]='Log';	
				ELSE
				BEGIN 
					SET XACT_ABORT ON;
					EXEC ('	UPDATE OPENQUERY(['+@ServerSource+'], ''SELECT [Kind]
																	FROM [sputnik].[backups].[BackConf] 
																	WHERE [DBName]=N'''''+@DBNameSource+''''' AND [Kind]=''''Log'''';'')
							SET [Kind]=''XLog''
			 			');
					SET XACT_ABORT OFF;
				END
		END

		--Формирование имени новой базы (если не задано)
		IF @DBNameTarget IS NULL
		begin
			declare @BackupFinishDate Datetime2(2);
	
			SELECT @BackupFinishDate=MAX([BackupDate])
			FROM @ChainBack;

			SET @DBNameTarget=@DBNameSource+'_COPY_'+CONVERT(VARCHAR(8), @BackupFinishDate, 112)+'_'+REPLACE(CONVERT(VARCHAR(20), @BackupFinishDate, 108), ':', '');
		END
		--Восстановление из полученной цепочки бэкапов.
		DECLARE @BF nvarchar(800), @BT varchar(4);
		DECLARE RE CURSOR FOR
			SELECT BackupFile, BackupType
			FROM @ChainBack
			--ORDER BY ID;
		OPEN RE;
		FETCH NEXT FROM RE INTO @BF, @BT;
		WHILE @@FETCH_STATUS=0
		BEGIN
			begin try
			IF @BT='Full' 
				BEGIN
					if @pp=0
						PRINT ('********************************
							Восстановление ['+@DBNameTarget+'] из ПОЛНОГО Бэкапа: '+@BF);
					EXEC [sputnik].[backups].[usp_RestoreDB_simple] 
						@DBNameTarget=@DBNameTarget, 
						@FromDisk=@BF,
						@MoveFilesTo=@MoveFilesTo,
						@MoveLogFilesTo=@MoveLogFilesTo,
						@NoRecovery=1,
						@NoStats=@pp,
						@StandBy_File=@StandBy_File
						--,@dbowner=@dbowner
					;
				END
				ELSE IF @BT='Diff' 
				BEGIN
					if @pp=0
						PRINT ('********************************
							Восстановление ['+@DBNameTarget+'] из ДИФФ. Бэкапа: '+@BF);
					EXEC [sputnik].[backups].[usp_RestoreDB_simple] 
						@DBNameTarget=@DBNameTarget, 
						@FromDisk=@BF,
						@MoveFilesTo=@MoveFilesTo,
						@MoveLogFilesTo=@MoveLogFilesTo,
						@NoRecovery=1,
						@DiffBack=1,
						@NoFileList=1,
						@NoStats=@pp,
						@StandBy_File=@StandBy_File
						--,@dbowner=@dbowner
					;
				END
				ELSE IF @BT='Log' 
				BEGIN
					if @pp=0
						PRINT ('********************************
							Восстановление ['+@DBNameTarget+'] из Бэкапа ЛОГА (ЖТ): '+@BF);
					EXEC [sputnik].[backups].[usp_RestoreDB_simple] 
						@DBNameTarget=@DBNameTarget, 
						@FromLog=@BF,
						@MoveFilesTo=@MoveFilesTo,
						@MoveLogFilesTo=@MoveLogFilesTo,
						@NoRecovery=1,
						@NoFileList=1,
						@NoStats=@pp,
						@StandBy_File=@StandBy_File
						--,@dbowner=@dbowner
					;
				END
			end try 
			begin catch
				SET @StrErr=N'Ошибка в ХП [usp_GC2] при попытке восстановить БД ['+@DBNameTarget+'] из '+@BT+'-Бэкапа ('+@BF+') ! Текст ошибки: '+ERROR_MESSAGE();
				RAISERROR(@StrErr,11,1) WITH LOG
			end catch
			FETCH NEXT FROM RE INTO @BF, @BT;
		END
		CLOSE RE;
		DEALLOCATE RE;
		--Перевод базы данных в режим RECOVERY
		IF @NoRecovery=0
		begin
			if @pp=0
				PRINT ('********************************
					Перевод новой базы в режим ONLINE + изменение db_owner');
			EXEC [sputnik].[backups].[usp_RestoreDB_simple] 
				@DBNameTarget=@DBNameTarget, 
				@ForceRecovery=1,
				@dbowner=@dbowner;
		end;
		--Если запуск произведен из модуля Log Shipping Easy,
		--тогда установим ID для последнего восстановленного бэкапа в sputnik.lse.TargetConfig
		IF @lse=1
		BEGIN
			UPDATE sputnik.lse.TargetConfig
			SET [InitBackupHS_id]=(SELECT MAX(ID) FROM @ChainBack),
				[InitDate]=@lseInitDate
			WHERE [DBNameTarget]=@DBNameTarget;
		END

		--В самом конце делаем очистку от Дифф. бэкапов и удаляем настройки, 
		--только если они были созданы в этой же процедуре ИЛИ существует точно такая же настройка с предыдущего неудачного запуска!
		begin try
			DELETE @TTD;
			IF @ServerSource IS NULL OR @ServerSource=@LocalServer
				INSERT INTO @TTD
				SELECT DBName AS DB 
				FROM sputnik.backups.BackConf 
				WHERE DBName=@DBNameSource AND Kind='Diff' AND LocalDays=1 AND NetDays=1
					AND [LocalPolicy]=1 AND [NetPolicy]=1
					AND EXISTS (SELECT DBName AS DB FROM sputnik.backups.BackConf as BakF WHERE BakF.Kind='Full' AND BakF.DBName=@DBNameSource);
			ELSE
				INSERT INTO @TTD
				EXEC('SELECT [DBName] AS DB
					  FROM OPENQUERY(['+@ServerSource+'], ''SELECT [DBName] FROM sputnik.backups.BackConf WHERE Kind=''''Diff''''  AND LocalDays=1 AND NetDays=1 AND DBName=N'''''+@DBNameSource+''''' AND [LocalPolicy]=1 AND [NetPolicy]=1 AND EXISTS (SELECT DBName AS DB FROM sputnik.backups.BackConf as BakF WHERE BakF.Kind=''''Full'''' AND BakF.DBName=N'''''+@DBNameSource+''''');'')
					');
			IF @NewConf=1 OR EXISTS(SELECT DB FROM @TTD )
			BEGIN
				IF @ServerSource IS NULL OR @ServerSource=@LocalServer
				BEGIN	
					EXEC sputnik.backups.[usp_CleaningBack] @DBFilter=@DBNameSource, @type='Diff';
					DELETE 
					FROM sputnik.backups.BackConf
					WHERE DBName=@DBNameSource AND Kind='Diff';
					--Дополнительно удаляем из истории Бэкапов информацию о созданном Дифф. бэкапе
					DELETE [sputnik].[backups].[BackupHistory]
					WHERE [ID] = @BackupDiffID;
				END
				ELSE
				BEGIN
					DECLARE @BackupDiffIDstr nvarchar(50);
					set @BackupDiffIDstr=CAST(@BackupDiffID AS NVARCHAR(50));
					EXEC ('
							EXEC(''
									EXEC sputnik.backups.[usp_CleaningBack] @DBFilter=N'''''+@DBNameSource+''''', @type=''''Diff'''';
									DELETE 
									FROM sputnik.backups.BackConf
									WHERE DBName=N'''''+@DBNameSource+''''' AND Kind=''''Diff'''';
									--Дополнительно удаляем из истории Бэкапов информацию о созданном Дифф. бэкапе
									DELETE [sputnik].[backups].[BackupHistory]
									WHERE [ID] = '+@BackupDiffIDstr+';
							'') AT ['+@ServerSource+']
						');
				END
			END
		end try
		begin catch
			SET @StrErr=N'Ошибка в ХП [usp_GC2] при попытке удалить настройку и историю по Дифф. бэкапам! Текст ошибки: '+ERROR_MESSAGE();
			RAISERROR(@StrErr,11,1) WITH LOG
		end catch
		return 1;
	END
GO
PRINT N'Creating Procedure [config].[usp_cleanup_hs_run]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 26.02.2014 (1.0)
	-- Description: Эта процедура используется для очистки исторических данных в базе sputnik!
					Что конкретно и как чистить определено в таблице config.cleanup_hs!
					На основании этих данных выполняется очистка старых данных.
	-- Update:		22.10.2015 (1.01)
					Добавлен параметр @top - для очистки только указанного числа строк!
					02.12.2015 (1.02)
					Для параметра @top задано значение по умолчанию=10000 (ранее было NULL) !
					10.03.2016 (1.03)
					Для параметра @top задано значение по умолчанию=2000 (ранее было 10000) !
					24.11.2017 (1.032)
					Добавлен новый алгоритм - для таблицы sql_handle_collect очищаем сразу по 20000 строк, в связи с тем что данные не успевают очищаться в этой таблице !
					09.02.2018 (1.033)
					Алгоритм агрессивной зачистки теперь действует для таблиц: sql_handle_collect, pfc_data, pfc_data_dyn
	-- ============================================= */
	CREATE PROCEDURE [config].[usp_cleanup_hs_run] 
		@only_print_command bit=0,
		@top int=2000
	AS
		SET NOCOUNT ON;
		DECLARE @SN nvarchar(300), @TN nvarchar(300), @CF nvarchar(300), @IT varchar(30), @I varchar(10), @sql_cmd nvarchar(1000), @top_cmd nvarchar(100)='';
		DECLARE @top_cmd_plus nvarchar(100)='';
		set @top_cmd_plus=' TOP (20000) ';
		if @top is not null
			set @top_cmd=' TOP ('+cast(@top as varchar(40))+') ';
		DECLARE Cl CURSOR FOR
		SELECT SchemaName,TableName,Column_filter,interval_type,interval
		FROM sputnik.config.cleanup_hs;
		OPEN Cl;
		FETCH NEXT FROM Cl INTO @SN, @TN, @CF, @IT, @I;
		WHILE @@FETCH_STATUS=0
		BEGIN
			SET @sql_cmd='IF OBJECT_ID(''['+@SN+'].['+@TN+']'') IS NOT NULL
		DELETE '+CASE WHEN @TN IN ('sql_handle_collect','pfc_data','pfc_data_dyn') THEN @top_cmd_plus ELSE @top_cmd END+' FROM ['+@SN+'].['+@TN+'] WHERE ['+@CF+'] < DATEADD('+@IT+',-'+@I+',SYSDATETIME())';
			IF @only_print_command=1
				PRINT @sql_cmd;
			ELSE
				EXEC(@sql_cmd);
			FETCH NEXT FROM Cl INTO @SN, @TN, @CF, @IT, @I;
		END
		CLOSE Cl;
		DEALLOCATE Cl;
GO
PRINT N'Creating Procedure [db_maintenance].[usp_WriteHS]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 19.10.2016 (1.0)
	-- Description: The procedure is used for logging all database maintenance operations (writing to the HS table).
	-- Update:		
					21.10.2016 (1.005) Fixed bug number, now 55000 (50000 cannot be used for custom bugs).
					27.12.2017 (1.010) Instead of NULL for DB_ID, 0 will be written to the history table.
	-- ============================================= */
	CREATE PROCEDURE db_maintenance.usp_WriteHS
		@DB_ID int,
		@Object_ID int=null,
		@Index_Stat_ID int=null,
		@Index_Stat_Type bit=null,
		@Command_Type tinyint,
		@Command_Text_1000 varchar(8000),
		@tt_start datetime2(2),
		@tt_end datetime2(2)=null,
		@Status bit,
		@Error_Text_1000 varchar(8000)=null
	as
	begin
		set nocount on;
		DECLARE @StrErr VARCHAR(2048);
		if @tt_end is null
			set @tt_end=CAST(SYSDATETIME() as datetime2(2));
		if LEN(@Command_Text_1000)>1000
			set @Command_Text_1000=LEFT(@Command_Text_1000,1000);
		if @Error_Text_1000 is not null AND LEN(@Error_Text_1000)>1000
			set @Error_Text_1000=LEFT(@Error_Text_1000,1000);

		BEGIN TRY
			insert into sputnik.db_maintenance.HS ([DB_ID],[Object_ID],[Index_Stat_ID],[Index_Stat_Type],[Command_Type],[Command_Text_1000],[tt_start],[tt_end],[Status],[Error_Text_1000])
			select COALESCE(@DB_ID,0), @Object_ID, @Index_Stat_ID, @Index_Stat_Type, @Command_Type, @Command_Text_1000, @tt_start, @tt_end, @Status, @Error_Text_1000 ;
		END TRY
		BEGIN CATCH
			SET @StrErr=N'An error occurred while writing to the sputnik.db_maintenance.HS table via the [usp_WriteHS] procedure! Error text: '+COALESCE(ERROR_MESSAGE(),'null *Error message is not defined');
			--print @StrErr;
			--RAISERROR(@StrErr,11,1) WITH LOG;
			EXEC xp_logevent 55000, @StrErr, ERROR; 
		END CATCH
		
	end
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating Procedure [db_maintenance].[usp_reindex_preparedata]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO


/* =============================================
-- Author:		Андрей Иванов (sqland1c)
-- Create date: 10.12.2013 (1.0)
-- Description: Процедура для сбора первичных данных для реиндексации таблиц в базе
				Параметр @db_name определяет для какой базы собирается статистика.
-- Update:		15.01.2014 (1.1)
				Размер текстовых переменных (nvarchar) увеличен.	
				26.02.2014 (1.2)
				Добавлено условие в отбор индексов - только Включенные индексы отбирать.
				Также в таблицу ReindexDataFor_ добавлены новый столбец ReindexCount - количество выполнений операций Перестроении или Дефрагментаций индекса.
				27.02.2014 (1.3)
				Добавлен список столбцов при вставке данных!
				Также добавлен алгоритм для получения данных о хранении LOB в индексе. Если такие есть, то ONLINE перестроение индекса запрещено (столбец NotRunOnline = 1).
				03.03.2014 (1.4)
				Добавлен новый столбец PrepareDate - определяет дату и время подготовки данных (то есть инициализации таблицы ReindexDataFor_).
				Также для всех столбцов с типом Дата изменён Тип на более новый (кот-й занимает меньше места) - datetime2 c 2 разрядами после секунды.
				05.03.2014 (1.41)
				Добавлена настройка сеанса Низкий приоритет взаимоблокировки и READ UNCOMMITTED в качестве уровня изоляции транзакций.
				24.06.2015 (2.00)
				Совершенно новый алгоритм сбора и хранения данных для Реиндексации: 1. Теперь будет одна таблица на все БД, 2. Теперь таблицы не будут пересоздаваться,
				а информация будет обновляться с помощью MERGE!
				10.09.2015 (2.02)
				Добавлено дополнительные условие в команду MERGE, чтобы не обновлять строки, если они не изменились.
				Такде добавлено условие, чтобы удалять строки только по текущей БД - этим исправлена существенная ошибка!
				14.12.2016 (2.030)
				Изменена таблица ReindexData и добавлен алгоритм логгирования в таблицу HS.
-- ============================================= */
CREATE PROCEDURE db_maintenance.usp_reindex_preparedata
	@db_name nvarchar(300)
AS
BEGIN
	SET NOCOUNT ON;
	SET DEADLOCK_PRIORITY LOW;
	SET LOCK_TIMEOUT 30000;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	--Проверка АКТУАЛЬНОСТИ указанной базы данных:
	declare @db_name_check nvarchar(300);
	select @db_name_check = name from sys.databases where name = @db_name and state_desc='ONLINE'
	if @db_name_check is null
		return -1;
	declare @tsql Nvarchar(2400);
	--Подготовка таблицы ReindexData - если её нет, создадим!
	if object_id('sputnik.db_maintenance.ReindexData') IS NULL
		create table db_maintenance.ReindexData
		(
			DBName     nvarchar(300),
			SchemaName nvarchar(300),
			TableName  nvarchar(300),
			IndexName  nvarchar(300),
			TableID    int,
			IndexID	   int,
			IndexType  tinyint,
			SetFillFactor tinyint,
			TableCreateDate datetime2(2),
			TableModifyDate datetime2(2),
			PrepareDate datetime2(2),
			[PageCount]  bigint,
			AVG_Fragm_percent tinyint,
			[~PageUsed_perc] tinyint,
			[~Row_cnt] bigint,
			[~RowSize_Kb] numeric(9,3),
			LastUpdateStats datetime2(2),
			LastCommand nvarchar(500),
			LastRunDate datetime2(2),
			ReindexCount int default 0,
			NotRunOnline bit default 0
		);
	else
	begin
		--тут добавим новые столбцы (если их нет):
		if not exists (select column_id from sys.columns where object_id=OBJECT_ID('sputnik.db_maintenance.ReindexData') and name='~PageUsed_perc')
			alter table sputnik.db_maintenance.ReindexData add [~PageUsed_perc] tinyint NULL;
		if not exists (select column_id from sys.columns where object_id=OBJECT_ID('sputnik.db_maintenance.ReindexData') and name='~Row_cnt')
			alter table sputnik.db_maintenance.ReindexData add [~Row_cnt] bigint NULL;
		if not exists (select column_id from sys.columns where object_id=OBJECT_ID('sputnik.db_maintenance.ReindexData') and name='~RowSize_Kb')
			alter table sputnik.db_maintenance.ReindexData add [~RowSize_Kb] numeric(9,3) NULL;

	end
	--В отдельном пакете соберём всю исходную информацию о таблицах и индексах по базе данных
	--Вся полученная информация сохраняется во временной таблице #T_Source для дальнейшей обработки.
	if object_id('tempdb..#T_Source') is not null
		drop table #T_Source;
	create table #T_Source
		(
			DBName     nvarchar(300),
			SchemaName nvarchar(300),
			TableName  nvarchar(300),
			IndexName  nvarchar(300),
			TableID    int,
			IndexID	   int,
			IndexType  tinyint,
			SetFillFactor tinyint,
			TableCreateDate datetime2(2),
			TableModifyDate datetime2(2),
			PrepareDate datetime2(2),
			[PageCount]  bigint,
			AVG_Fragm_percent tinyint,
			[~PageUsed_perc] tinyint,
			[~Row_cnt] bigint,
			[~RowSize_Kb] numeric(9,3),
			LastUpdateStats datetime2(2),
			LastCommand nvarchar(500),
			LastRunDate datetime2(2),
			ReindexCount int default 0,
			NotRunOnline bit default 0
		);
	set @tsql ='use '+QUOTENAME(@db_name_check)+';
		SET NOCOUNT ON;
		SET DEADLOCK_PRIORITY LOW;
		SET LOCK_TIMEOUT 30000;
		SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
		insert into #T_Source (DBName, SchemaName, TableName, IndexName, TableID, IndexID, IndexType,SetFillFactor, TableCreateDate, TableModifyDate, PrepareDate, PageCount, AVG_Fragm_percent,[~PageUsed_perc],[~Row_cnt],[~RowSize_Kb], LastUpdateStats, LastCommand, LastRunDate,NotRunOnline)
		select 
			'''+QUOTENAME(@db_name_check)+''' as DBName,QUOTENAME(S.name) as SchemaName, T.TableName, I.IndexName, 
			T.object_id as TableID, I.index_id as IndexID,
			 I.type as IndexType, 
			I.Fill_Factor as SetFillFactor, T.create_date as TableCreateDate, 
			T.modify_date as TableModifyDate, getdate() as PrepareDate, null as PageCount, 
			null as AVG_Fragm_percent, 
			NULL as [~PageUsed_perc],
			NULL as [~Row_cnt],
			NULL as [~RowSize_Kb],
			null as LastUpdateStats, 
			null as LastCommand, null as LastRunDate,
			case 
				when LOB.index_id is null then 0
				when LOB.index_id is not null then 1
			end as NotRunOnline
		from
			(
				select 
					object_id, 
					QUOTENAME(name) as IndexName, 
					index_id, 
					type, 
					fill_factor 
				from sys.indexes
				where 
					index_id>0  --Исключить Кучи.
					and is_disabled=0 --Только Включенные индексы
			) I
			inner join
			(	
				select 
					QUOTENAME(name) as TableName, 
					object_id,
					schema_id, 
					create_date, 
					modify_date 
				from 
					sys.tables
			) T
				on I.object_id=T.object_id
			inner join sys.schemas S 
				on T.schema_id=S.schema_id 
			left join
			(
				select 
					object_id, 
					index_id 
				from
					(
					select container_id as id
					from sys.allocation_units
					where type=2 --LOB_DATA
					) lob
				inner join sys.partitions p
					on lob.id=p.partition_id
			) LOB
				on LOB.object_id=I.object_id and LOB.index_id=I.index_id
			';
	declare @db_id int, @flag_fail bit, @StrErr varchar(2048), @tt_start datetime2(2), @command_text_log varchar(8000);
	set @flag_fail=0;
	set @StrErr=NULL;
	BEGIN TRY
		set @tt_start=CAST(SYSDATETIME() AS datetime2(2));
		exec (@tsql);
		--Теперь используя команду MERGE синхронизируем информацию по таблицам и индексам между фактическими данными (#T_Source) и таблицей ReindexData
		MERGE
			INTO sputnik.db_maintenance.ReindexData AS target
			USING #T_Source AS source --(DBName, SchemaName, TableName, IndexName, IndexType,SetFillFactor, TableCreateDate, TableModifyDate, PrepareDate, PageCount, AVG_Fragm_percent, LastUpdateStats, LastCommand, LastRunDate,NotRunOnline)
			ON target.DBName=source.DBName AND target.SchemaName=source.SchemaName AND target.TableName=source.TableName AND target.IndexName=source.IndexName
			WHEN NOT MATCHED THEN
				INSERT (DBName, SchemaName, TableName, IndexName, TableID, IndexID, IndexType,SetFillFactor, TableCreateDate, TableModifyDate, PrepareDate, PageCount, AVG_Fragm_percent, [~PageUsed_perc],[~Row_cnt],[~RowSize_Kb], LastUpdateStats, LastCommand, LastRunDate,NotRunOnline)
				VALUES (source.DBName, source.SchemaName, source.TableName, source.IndexName, source.TableID, source.IndexID, source.IndexType, source.SetFillFactor, source.TableCreateDate, source.TableModifyDate, source.PrepareDate, source.PageCount, source.AVG_Fragm_percent,source.[~PageUsed_perc],source.[~Row_cnt],source.[~RowSize_Kb], source.LastUpdateStats, source.LastCommand, source.LastRunDate, source.NotRunOnline)
			WHEN NOT MATCHED BY source AND 
				--дополнительное условие - удаляем только строки по текущей БД!
				(target.DBName=QUOTENAME(@db_name_check)) THEN
					DELETE
			WHEN MATCHED AND 
				--дополнительные условия, чтобы не обновлять, если не было никаких изменений!
				(
					target.TableID<>source.TableID OR target.IndexID<>source.IndexID OR target.IndexType<>source.IndexType
					OR target.SetFillFactor<>source.SetFillFactor OR target.TableCreateDate<>source.TableCreateDate
					OR target.TableModifyDate<>source.TableModifyDate OR target.NotRunOnline<>source.NotRunOnline
				)
			THEN
				UPDATE SET
					target.TableID=source.TableID, target.IndexID=source.IndexID, target.IndexType=source.IndexType, 
					target.SetFillFactor=source.SetFillFactor, target.TableCreateDate=source.TableCreateDate, 
					target.TableModifyDate=source.TableModifyDate, target.PrepareDate=source.PrepareDate, 
					target.LastUpdateStats=source.LastUpdateStats, target.NotRunOnline=source.NotRunOnline
		;	
	END TRY
	BEGIN CATCH
			set @flag_fail=1;
			set @StrErr=/*'Ошибка при подготовке данных по индексам через процедуру [usp_reindex_preparedata]! Текст ошибки: '+*/COALESCE(ERROR_MESSAGE(),'null *Error message is not defined');
	END CATCH
	set @db_id=DB_ID(@db_name_check);
	--Логгируем в историю Обслуживания БД
	set @command_text_log='exec [db_maintenance].[usp_reindex_preparedata] @db_name='''+@db_name_check+''';';
	EXEC sputnik.db_maintenance.usp_WriteHS 
		@DB_ID=@db_id,
		@Index_Stat_Type=0, --0-Index
		@Command_Type=4, --4-Prepare data for ReIndex (usp_reindex_preparedata)
		@Command_Text_1000=@command_text_log,
		@tt_start=@tt_start,
		@Status=@flag_fail, --0-Success, 1-Fail(Error)
		@Error_Text_1000=@StrErr;

END
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating Procedure [db_maintenance].[usp_reindex_updatestats]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO

/* =============================================
-- Author:		Андрей Иванов (sqland1c)
-- Create date: 15.01.2014 (1.0)
-- Description: Процедура для сбора и обновления статических данных для реиндексации таблиц в базе
				на основании системной функции dm_db_index_physical_stats 
				Параметр @db_name определяет для какой базы собирается статистика.
				Параметр @rowlimit - определяет количество строк для обработки за 1 раз. По умолчанию 500.
				Параметр @countexec - количество подходов (раз) выполнения с заданными настройками. По умолчанию 50 раз.
				Параметр @delayperiod - определяет временную задержку в формате строки 00:00:00, перед запуском обработки следующих строк. По умолчанию 06 сек.
				Эти 3 параметра необходимы, чтобы минимизировать нагрузку на SQL Server.
				Параметр @oldupdhours - определяет количество часов, после которых информация считается устаревшей и требуется обновление! По умолчанию 6 часов.
-- Update:		15.01.2014 (1.1)
				Добавлен алгоритм предварительной проверки найденных строк. Если найденных строк нет, то выполнение прерывается.
				24.01.2014 (1.15)
				Изменены значения параметров по умолчанию.
				24.01.2014 (1.20)
				Для сбора статистики используется метод default вместо DETAILED.
				30.01.2014 (1.4)
				Добавлены алгоритмы проверки указанной базы и главное проверки Таблиц И Индексов в сохранённой статистике!			
				25.02.2014 (1.5)
				Добавлено условие в отбор индексов - только Включенные индексы отбирать.
				26.02.2014 (1.55)
				Изменен параметр @oldupdate на @oldupdhours - теперь возраст статистики будет проверяться в часах, а не в днях. Значение по умолчанию 6 часов.
				27.02.2014 (1.56)
				Значение по умолчанию для параметра @oldupdhours уменьшено с 6 до 3 часов.
				05.03.2014 (1.57)
				Добавлена настройка сеанса Низкий приоритет взаимоблокировки и READ UNCOMMITTED в качестве уровня изоляции транзакций.
				Также размер тектовой переменной @tsql увеличен до 2400.
				06.03.2014 (1.58)
				Изменено значение по умолчанию для параметра @delayperiod с 6 до 2 сек.
				15.10.2014 (1.6)
				Добавлен новый параметр @TableFilter - теперь можно запустить принудительно сбор статистик для конкретной таблицы.
				При этом значение параметра @oldupdhours не учитывается!
				24.06.2015 (2.0)
				Совершенно новый алгоритм сбора дополнительной информации по индексам. Вся проверка актуальности производиться 
				в процедуре usp_reindex_preparedata. Вся информация сохраняется в одну таблицу ReindexData.
				18.08.2016 (2.01) Добавлен новый параметр @rowlimit_max - за 1 запуск обновляем только
				указанное кол-во статистик.
				14.12.2016 (2.020)
				Новый алгоритм сбора информации и логгирования в таблицу HS.
-- ============================================= */
CREATE PROCEDURE db_maintenance.usp_reindex_updatestats
	@db_name nvarchar(300) = NULL,
	@rowlimit int = 50,
	@delayperiod char(12) = '00:00:00:500',
	@oldupdhours tinyint = 3,
	@TableFilter nvarchar(300)=null,
	@rowlimit_max bigint = 1000000
AS
BEGIN
	declare @tt_start_proc datetime2(2);
	set @tt_start_proc=CAST(SYSDATETIME() AS datetime2(2));
	SET NOCOUNT ON;
	SET DEADLOCK_PRIORITY LOW;
	SET LOCK_TIMEOUT 30000;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	declare @tsql nvarchar (2400),@tsqlcheck nvarchar (600);
	----Проверка АКТУАЛЬНОСТИ указанной базы данных:
	--declare @DB_current nvarchar(300);
	--select @DB_current = name from sys.databases where name = @db_name and state_desc='ONLINE'
	--if @DB_current is null
	--	return -1;

	if @TableFilter is not null
		set @oldupdhours=0;
	else
		set @TableFilter='';

	/*	Отбор БД для обслуживания */
	declare @DB_current nvarchar(300);
	if OBJECT_ID('tempdb..#src_ag_db') IS NOT NULL
		DROP TABLE #src_ag_db;
	CREATE TABLE #src_ag_db (DB nvarchar(800), [db_id] int, [Role] nvarchar(800), [PartnerReplica] nvarchar(800), [PrimaryReplica] nvarchar(800), sync_state nvarchar(800), health nvarchar(800), DB_State nvarchar(800));
	IF CAST (LEFT (CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(2)),2) AS SMALLINT) >= 11
		--Информация о вторичных репликах AlwaysON AG на текущем сервере:
		INSERT INTO #src_ag_db (DB, [db_id], [Role], [PartnerReplica], [PrimaryReplica], sync_state, health, DB_State)
			SELECT
				DB_NAME(ag_db.database_id) as DB,
				ag_db.database_id as [db_id],
				ISNULL(arstates.role_desc, '') AS [Role],
				ISNULL(AR.replica_server_name, '') as [PartnerReplica],
				ISNULL(agstates.primary_replica, '') AS [PrimaryReplica],
				ag_db.synchronization_state_desc as sync_state,
				ag_db.synchronization_health_desc as health,
				ag_db.database_state_desc as DB_State 
			FROM sys.dm_hadr_database_replica_states ag_db
			LEFT JOIN sys.dm_hadr_availability_group_states as agstates
				on ag_db.group_id=agstates.group_id	
			LEFT JOIN sys.dm_hadr_availability_replica_states AS arstates
				ON ag_db.replica_id = arstates.replica_id
					and ag_db.group_id=arstates.group_id
			LEFT JOIN sys.availability_replicas as AR
				ON ag_db.replica_id=AR.replica_id
					and ag_db.group_id=AR.group_id
			WHERE ag_db.is_local=1 
				AND ISNULL(arstates.role_desc, '') = 'SECONDARY'
	DECLARE DB CURSOR FOR
	select name as DB
	from sys.databases sdb
	left join #src_ag_db adb ON sdb.database_id=adb.[db_id]
	where 
		(name = @db_name or @db_name is null or @db_name='') 
		and state_desc='ONLINE'
		and database_id>4
		and is_read_only=0
		and (name NOT LIKE '201%(%)%' and name NOT LIKE 'S201%(%)%')
		and adb.db is null;
	OPEN DB;
	FETCH NEXT FROM DB INTO @DB_current;
	WHILE @@FETCH_STATUS=0
	BEGIN
		
		--Теперь ВСЯ проверка актуальности таблиц и индексов полностью производится в процедуре usp_reindex_preparedata	 			
		--При этом пересоздания таблиц не происходит, а осуществляется СИНХРОНИЗАЦИЯ данных через MERGE!
		exec sputnik.db_maintenance.usp_reindex_preparedata @DB_current;
	
		declare @db_id int, @flag_fail bit, @StrErr varchar(2048), @tt_start datetime2(2), @command_text_log varchar(8000);
		--Новый алгоритм сбора дополнительной информации по индексам: avg_fragmentation_in_percent и page_count.
		declare @IndexID int, @TableID int, @AvgFrag tinyint, @PageCount bigint, @i_limit int=1,@Avg_Page_Used tinyint,@Row_cnt bigint,@RowSize_Kb numeric(9,3);
		set @db_id=DB_ID(@DB_current);

		declare C cursor for
		select TOP (@rowlimit_max) IndexID,TableID
		from   [db_maintenance].[ReindexData]
		where
			DBName=QUOTENAME(@DB_current)
			and (@TableFilter = '' or TableName= QUOTENAME(@TableFilter))
			and ([LastUpdateStats] is null or [LastRunDate]>[LastUpdateStats]
				or DATEDIFF(HOUR,[LastUpdateStats],getdate())>=@oldupdhours)
		order by [LastUpdateStats] ASC;
		open C
		fetch next from C into @IndexID, @TableID
		while @@fetch_status=0
		begin
			set @flag_fail=0;
			set @StrErr=NULL;
			BEGIN TRY
			
				set @tt_start=CAST(SYSDATETIME() AS datetime2(2));
						
				select 			
					@AvgFrag=cast (ROUND(max(avg_fragmentation_in_percent),0) as tinyint),
					@Avg_Page_Used=cast (ROUND(min(avg_page_space_used_in_percent),0) as tinyint),
					@PageCount=sum(page_count),
					@Row_cnt=sum(record_count),
					@RowSize_Kb=cast (max(avg_record_size_in_bytes)/1024.00 as numeric(9,3))
				from sys.dm_db_index_physical_stats (@db_id, @TableID, @IndexID,NULL,'SAMPLED');

				--select @AvgFrag,@Avg_Page_Used,@PageCount,@Row_cnt,@RowSize_Kb
				--select @DB_current,@TableID,@IndexID;
				--select [AVG_Fragm_percent],[PageCount],[~PageUsed_perc],[~Row_cnt],[~RowSize_Kb],[LastUpdateStats]
				--from [db_maintenance].[ReindexData] 
				--where DBName=@DB_current
				--	and TableID=@TableID
				--	and IndexID=@IndexID; 

				update [db_maintenance].[ReindexData] 
				set [AVG_Fragm_percent]=@AvgFrag,
					[PageCount]=@PageCount,
					[~PageUsed_perc]=@Avg_Page_Used,
					[~Row_cnt]=@Row_cnt,
					[~RowSize_Kb]=@RowSize_Kb,
					[LastUpdateStats]=getdate()
				where 
					DBName=QUOTENAME(@DB_current)
					and TableID=@TableID
					and IndexID=@IndexID;
			END TRY
			BEGIN CATCH
				--Логгируем в историю Обслуживания БД (ТОЛЬКО ОШИБКИ!):
				set @flag_fail=1;
				set @StrErr=/*'Ошибка при обновлении данных по индексам через процедуру [usp_reindex_updatestats]! Текст ошибки: '+*/COALESCE(ERROR_MESSAGE(),'null *Error message is not defined');
				set @command_text_log='--dlck_pr=-5;tr_iso_lvl=1;lck_tmt=30000;
		select @AvgFrag=cast(MAX(avg_fragmentation_in_percent) as tinyint), @PageCount=sum(page_count)
		from sys.dm_db_index_physical_stats ('+CAST(@db_id as varchar(100))+','+CAST(@TableID as varchar(100))+','+CAST(@IndexID as varchar(100))+',default,default);
		--update table [db_maintenance].[ReindexData]';
				EXEC sputnik.db_maintenance.usp_WriteHS 
					@DB_ID=@db_id,
					@Object_ID=@TableID,
					@Index_Stat_ID=@IndexID,
					@Index_Stat_Type=0, --0-Index
					@Command_Type=5, --5-Update data for ReIndex (usp_reindex_updatestats)
					@Command_Text_1000=@command_text_log,
					@tt_start=@tt_start,
					@Status=@flag_fail, --0-Success, 1-Fail(Error)
					@Error_Text_1000=@StrErr;
			END CATCH
		
			fetch next from C into @IndexID, @TableID;
		
			if @i_limit>=@rowlimit
			begin
				waitfor delay @delayperiod;
				set @i_limit=1;
			end
			else
				set @i_limit+=1;		
		end
		close C
		deallocate C;

		--Логгируем в историю Обслуживания БД в конце по всему вызову процедуры:
		set @command_text_log='exec [db_maintenance].[usp_reindex_updatestats] @db_name='''+@DB_current+''', @rowlimit='+CAST(@rowlimit as varchar(100))+',@delayperiod='''+@delayperiod+''',@oldupdhours='+CAST(@oldupdhours as varchar(100))+',@TableFilter='+CASE WHEN @TableFilter='' THEN 'NULL' ELSE ''''+@TableFilter+'''' END+',@rowlimit_max='+CAST(@rowlimit_max as varchar(100))+';';
		EXEC sputnik.db_maintenance.usp_WriteHS 
			@DB_ID=@db_id,
			@Index_Stat_Type=0, --0-Index
			@Command_Type=5, --5-Update data for ReIndex (usp_reindex_updatestats)
			@Command_Text_1000=@command_text_log,
			@tt_start=@tt_start_proc,
			@Status=0, --0-Success, 1-Fail(Error)
			@Error_Text_1000=NULL;

		FETCH NEXT FROM DB INTO @DB_current;
	END
	CLOSE DB;
	DEALLOCATE DB;
END
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating Procedure [db_maintenance].[usp_reindex_run]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 24.01.2013 (1.0)
	-- Description: Процедура для выполнения интелектуальной реиндексации в уканной базе на основе собранной статистики 
					в таблице db_maintenance.ReindexDataFor_ИмяБазы.

					Параметр @db_name определяет в какой базы будет реиндексация.
				
					Параметр @indexeslimit - определяет количество индексов для обработки за 1 раз. По умолчанию 50.
					Параметр @delayperiod - определяет временную задержку в формате строки 00:00:00, перед запуском обработки следующих индексов. По умолчанию 2 сек.
						Эти 2 параметра необходимы, чтобы минимизировать нагрузку на SQL Server.
				
					Параметр @filter_pages - определяет количество страниц, определяющих примерный размер индекса. Индексы с таким размером и большим, будут попадать в отбор
						для дальнейшего перестроения. По умолчанию 128. Если задать значение null, то в отбор попадут все индексы.
					Параметр @filter_fragm - определяет текущую фрагментацию в %. Индексы с такой фрагментацией и больше, будут попадать в отбор для дальнейшего 
						перестроения. По умолчанию 10. Если задать значение null, то в отбор попадут все индексы.
					Параметр @filter_old_hours - определяет возраст реиндексации в часах. Все индексы, которые перестаивались раньше, должны попасть в отбор для нового перестроения.
						По умолчанию 6. Если задать значение null, то в отбор попадут все индексы.
					Параметр @fragm_tresh - определяет порог фрагментации в %. Индексы с меньшей фрагментацией будут дефрагментироваться (reorginize), а с большим порогом - 
						перестраиваться (rebuild). По умолчанию 30.
					Параметр @set_fillfactor - определяет устанавливаемый параметр FillFactor при перестроении индексов. По умолчанию 97%.
					Параметр @set_compression - определяет устанавливаемый параметр Сжатие данных при перестроение. Поддерживается только в Enterprise! По умолчанию NONE.
					Параметр @set_online - определяет возможность online операции с индексами. Поддерживается только в Enterprise! По умолчанию OFF.						
	-- Update:		
					31.01.2014 (1.1)
					Параметр @filter_pages, значение по умолчанию изменено на 12. 
					Добавлен параметр @set_sortintempdb, если ON, тогда при перестроении индексов будет использован параметр sort_in_tempdb	
					22.02.2014 (1.2)
					Исправлена ошибка - после реиндексации обновлять поле LastUpdateStats не нужно!
					25.02.2014 (1.3)
					Цикл в конце изменён на условие (IF). 
					26.02.2014 (1.4)
					Добавлен учёт количества выполненных операций Перестроения/Дефрагментации индекса в столбце ReindexCount.
					Также изменён входной параметр @filter_oldest -> @filter_old_hours - вместо Дней, задаётся количество часов. По умолчанию 6 часов.
					27.02.2014 (1.5)
					Добавлен алгоритм проверки возможности ONLINE перестроения индекса (только для операции REBUILD).
						Если индекс содержит LOB данные, то ONLINE перестроение невозможно.
					05.03.2014 (1.51)
					Добавлена настройка сеанса Низкий приоритет взаимоблокировки и READ UNCOMMITTED в качестве уровня изоляции транзакций.
					11.03.2014 (1.6)
					Добавлен новый параметр @PauseMirroring (соответствует новому столбцу PauseMirroring в таблице ReindexConf). Определяет приостановку Зеркалирования
					на время Реиндексации (если установлен 1). По умолчанию 0.
					15.10.2014 (1.62)
					Добавлен новый параметр @TableFilter - теперь можно запустить реиндексацию для конкретной таблицы! При этом реиндексация будет запущена
					принудительно (без учета параметра @filter_old_hours).
					18.12.2014 (1.63)
					Добавлена настройка сеанса ожидание блокировки=30 сек (по умолчанию бесконечно). Это может существенно помочь в решении блокировок.
					02.03.2015 (1.64)
					Вызов модуля usp_freeproccache (сброс процедурного кэша) перенесён в usp_reindex_start.
					24.06.2015 (2.00) 
					Полная оптимизация схемы Реиндексации. Процедура запуска значительно переделана под новую схему.
					08.07.2015 (2.01) 
					Небольшое исправление в алгоритме получения данных из ReindexData - изменена сортировка (теперь учитывается кол-во выполненных операций обслуживания - ReindexCount).
					09.07.2015 (2.02) 
					Добавлен параметр @only_show - позволяет просмотреть отобранные для обслуживания индексы (без обслуживания)
					07.11.2015 (2.05)
					Изменен алгоритм получения данных из ReindexData - изменена сортировка. Теперь отбор индексов происходит на основе рейтинга qt.
					Он расчитывается исходя из фрагментации, размера, кол-во обслуживаний в прошлый раз, и как давно последний раз обслуживался индекса. 
					А финальная сортировка перед непосредственным выполнением Реиндекса осуществляется случайным образом!
					01.12.2015 (2.06)
					Исправлен алгоритм расчета рейтинга qt.
					18.10.2016 (2.07)
					Исправлен алгоритм расчета рейтинга qt - теперь [ReindexCount] Кол-во реиндексаций ВЫЧИТАЕМ, а не прибавляем.
					31.03.2017 (3.000)
					Новая версия, большие изменения (переработан алгоритм+запись истории), несколько новых параметров (@PageUsed_tresh,@MaxDop,@timeout_sec,@policy_offline)
					12.04.2017 (3.002)
					Исправлен алгоритм расчёта @MaxDop_set - добавлено "послабление" для серверов с небольшим кол-вом ядер CPU (до 20). 
					Также изменён алгоритм выборки индексов для обслуживания - вставлена конструкция "order by qt desc". Финальная сортировка остаётся по-прежнему "случайной".
					26.04.2017 (3.005)
					Добавлена возможность принудительного перестроения (Rebuild) всех индексов. Для этого нужно в параметре @fragm_tresh задать отрицательное значение (например, -1).
					29.12.2017 (3.006)
					Увеличины размеры строковых переменных.
	-- ============================================= */
	CREATE PROCEDURE [db_maintenance].[usp_reindex_run]
		@db_name nvarchar(2000)=NULL,
		@UniqueName_SL nvarchar(200)=NULL,
		@rowlimit smallint = 50,
		@delayperiod char(12) = '00:00:00.100',
		@filter_pages_min int = 12,
		@filter_pages_max int = null,
		@filter_fragm_min tinyint = 10,
		@filter_fragm_max tinyint = null,
		@filter_old_hours tinyint = 24,
		@fragm_tresh smallint = 30,
		@set_fillfactor tinyint = 100,
		@set_compression char(4)='NONE',
		@set_online char(3)='OFF',
		@set_sortintempdb char(3)='OFF',
		@PauseMirroring bit=0,
		@TableFilter nvarchar(2000)=null,
		@DeadLck_PR smallint=0,
		@Lck_Timeout int=20000,
		@only_show bit = 0,
		@PageUsed_tresh tinyint = 80,	--% заполнения страницы, если меньше этого значения то обязательно нужен REBUILD, а не reorganize.
		@MaxDop smallint = NULL,		--кол-во ядер CPU на которых будет выполнятся обслуживание индекса (Работает только в Enterprise!).
		@timeout_sec int = NULL,		--Ограничение времени выполнения в данной процедуре в сек. Если NULL (или 0) - бесконечно.
		@policy_offline tinyint = 2		--Определяет что делать, если Online Rebuild невозможен: 0-Rebuild Offline,1-пропустить,2-Reorganize.
	AS
	BEGIN
		SET NOCOUNT ON;
		SET DEADLOCK_PRIORITY LOW;
		SET LOCK_TIMEOUT 30000;
		SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

		DECLARE @tt_start datetime2(2), @StrErr NVARCHAR(MAX),@flag_fail bit, @db_id_check int, @obj_id int, @ind_id int, @command_type tinyint, @tsql_handle_log varchar(2000), @commant_text_log Nvarchar(MAX),@AllCores_cnt smallint, @MaxDop_set smallint;
		declare @tt_start_usp datetime2(2), @time_elapsed_sec int;
		declare @tsql_handle nvarchar (2400), @tsql nvarchar (2400), @tsqlcheck nvarchar (800), @StopList_str NVARCHAR(MAX);
		declare @MirrorState nvarchar(75);
		set @tt_start_usp=CAST(SYSDATETIME() AS datetime2(2));
		--Определяем текущую редакцию SQL Server. MaxDop будет работать только в Enterprise:
		DECLARE @Ed VARCHAR(3)=LEFT(CAST(SERVERPROPERTY('Edition') AS VARCHAR(128)),3);
		IF @Ed='Ent'
		BEGIN
			--Определяем доступное кол-во ядер CPU для SQL Server:
			select @AllCores_cnt=count(*) from sys.dm_os_schedulers where [status]='VISIBLE ONLINE';
			--Максимум для MAXDOP = 64 ядра:
			IF @AllCores_cnt>64
				set @AllCores_cnt=64;
			IF @MaxDop is not null
			BEGIN
				set @MaxDop_set=@MaxDop;
				IF @AllCores_cnt<@MaxDop_set
					set @MaxDop_set=@AllCores_cnt;
			END
		END

		IF @TableFilter is not null
			set @filter_old_hours=0;
		ELSE
			set @TableFilter='';

		--Формируем список исключений таблиц, индексы для этих таблиц не будут обслужены в текущем запуске.
		select @StopList_str=StopList_str from sputnik.db_maintenance.StopLists where UniqueName=@UniqueName_SL;
		select @StopList_str=COALESCE(@StopList_str,'');
	
		--Заголовок запроса для обслуживания индексов!
		set @tsql_handle= N'
	SET DEADLOCK_PRIORITY '+CAST(@DeadLck_PR as varchar(2))+';
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	SET LOCK_TIMEOUT '+CAST(@Lck_Timeout as varchar(12))+';
		';
		--Заголовок запроса для логгирования:
		set @tsql_handle_log='--dlck_pr='+CAST(@DeadLck_PR as varchar(2))+';tr_iso_lvl=1;lck_tmt='+CAST(@Lck_Timeout as varchar(12))+';
		';
		--Далее получаем индексы для обслуживания и формируем команды для обслуживания, и выполняем их по очереди в отдельном пакете.
		declare @SchemaName nvarchar(2000), @TableName nvarchar(2000), @IndexName nvarchar(2000), @PageCount int, @AVG_Fragm_percent tinyint,@NotRunOnline bit;
		declare @command nvarchar(MAX), @check_set_online char(3), @PageU_prc tinyint, @i_cnt bigint=0,@i_cnt_skip bigint=0;
		--declare @T_i table (SchemaName nvarchar(300),TableName nvarchar(300),IndexName nvarchar(300), obj_id int, ind_id int, [PageCount] bigint,AVG_Fragm_percent tinyint,PageU_prc tinyint,NotRunOnline bit);
		IF OBJECT_ID('tempdb.dbo.#T_RI') IS NOT NULL
			DROP TABLE #T_RI;
		CREATE TABLE #T_RI (DB nvarchar(2000),SchemaName nvarchar(2000),TableName nvarchar(2000),IndexName nvarchar(2000), obj_id int, ind_id int, [PageCount] bigint,AVG_Fragm_percent tinyint,PageU_prc tinyint,NotRunOnline bit, qt numeric(19,6));


		/*	Отбор БД для обслуживания */
		declare @DB_current nvarchar(2000);
		if OBJECT_ID('tempdb..#src_ag_db') IS NOT NULL
			DROP TABLE #src_ag_db;
		CREATE TABLE #src_ag_db (DB nvarchar(2000), [db_id] int, [Role] nvarchar(2000), [PartnerReplica] nvarchar(2000), [PrimaryReplica] nvarchar(2000), sync_state nvarchar(2000), health nvarchar(2000), DB_State nvarchar(2000));
		IF CAST (LEFT (CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(2)),2) AS SMALLINT) >= 11
			--Информация о вторичных репликах AlwaysON AG на текущем сервере:
			INSERT INTO #src_ag_db (DB, [db_id], [Role], [PartnerReplica], [PrimaryReplica], sync_state, health, DB_State)
				SELECT
					DB_NAME(ag_db.database_id) as DB,
					ag_db.database_id as [db_id],
					ISNULL(arstates.role_desc, '') AS [Role],
					ISNULL(AR.replica_server_name, '') as [PartnerReplica],
					ISNULL(agstates.primary_replica, '') AS [PrimaryReplica],
					ag_db.synchronization_state_desc as sync_state,
					ag_db.synchronization_health_desc as health,
					ag_db.database_state_desc as DB_State 
				FROM sys.dm_hadr_database_replica_states ag_db
				LEFT JOIN sys.dm_hadr_availability_group_states as agstates
					on ag_db.group_id=agstates.group_id	
				LEFT JOIN sys.dm_hadr_availability_replica_states AS arstates
					ON ag_db.replica_id = arstates.replica_id
						and ag_db.group_id=arstates.group_id
				LEFT JOIN sys.availability_replicas as AR
					ON ag_db.replica_id=AR.replica_id
						and ag_db.group_id=AR.group_id
				WHERE ag_db.is_local=1 
					AND ISNULL(arstates.role_desc, '') = 'SECONDARY'
		DECLARE DB CURSOR FOR
		select name as DB
		from sys.databases sdb
		left join #src_ag_db adb ON sdb.database_id=adb.[db_id]
		where 
			(name = @db_name or @db_name is null or @db_name='') 
			and state_desc='ONLINE'
			and database_id>4
			and is_read_only=0
			and (name NOT LIKE '201%(%)%' and name NOT LIKE 'S201%(%)%')
			and adb.db is null;
		OPEN DB;
		FETCH NEXT FROM DB INTO @DB_current;
		WHILE @@FETCH_STATUS=0
		BEGIN
			;with cte_src_1 as
			(
				select top (@rowlimit) 
					SchemaName,TableName,IndexName,[PageCount],AVG_Fragm_percent,NotRunOnline
					,CAST( 
							([AVG_Fragm_percent])
							+ (100-[~PageUsed_perc])
							+ (cast([PageCount] as numeric(19,6)) / IIF(MAX ([PageCount]) over ()=0,1,MAX ([PageCount]) over ()) * 10)
							+ (datediff(day,LastRunDate,[LastUpdateStats])*[AVG_Fragm_percent]*0.01) 
							- (cast([ReindexCount] as numeric(19,6)) / IIF(MAX (ReindexCount) over ()=0,1,MAX (ReindexCount) over ()) * 10)
							as numeric(19,6)) as qt,
					[TableID] as obj_id, [IndexID] as ind_id,
					[~PageUsed_perc] as PageU_prc
				from 
					[db_maintenance].[ReindexData]
				where 
					DBName=QUOTENAME(@DB_current)
					and (@TableFilter='' or TableName=QUOTENAME(@TableFilter))
					and CHARINDEX(TableName+';',@StopList_str)=0
					and ([LastUpdateStats] is not null or @fragm_tresh<0)
					and ([PageCount] is not null and (@filter_pages_min is null or [PageCount] >= @filter_pages_min))
					and ([PageCount] is not null and (@filter_pages_max is null or [PageCount] <= @filter_pages_max))
					and (
							(
								(AVG_Fragm_percent is not null and (@filter_fragm_min is null or AVG_Fragm_percent >= @filter_fragm_min))
								OR ([~PageUsed_perc]<@PageUsed_tresh AND AVG_Fragm_percent>0)
							)
							AND (AVG_Fragm_percent is not null and (@filter_fragm_max is null or AVG_Fragm_percent <= @filter_fragm_max))				
						)
					and (LastRunDate is null or (@filter_old_hours is null or DATEDIFF(HOUR,[LastRunDate],getdate()) >= @filter_old_hours))
					and (LastRunDate is null or (LastUpdateStats > LastRunDate) or @fragm_tresh<0)
				order by qt desc
			)
			insert into #T_RI (DB, SchemaName,TableName,IndexName, obj_id, ind_id, [PageCount],AVG_Fragm_percent,PageU_prc,NotRunOnline,qt)
			select
					@DB_current,SchemaName,TableName,IndexName, obj_id, ind_id, [PageCount],AVG_Fragm_percent,PageU_prc,NotRunOnline,qt
			from 
				cte_src_1;
		
			FETCH NEXT FROM DB INTO @DB_current;
		END
		CLOSE DB;
		DEALLOCATE DB;

		--Создадим индекс по qt!
		--Для гарантированного отбора по Коэфициенту!
		CREATE CLUSTERED INDEX tmp_cix_qc01 ON #T_RI
		(
			[qt] DESC
		) ;

		if @only_show=1
			select SchemaName,TableName,IndexName,[PageCount],AVG_Fragm_percent,NotRunOnline 
			from
			(select  top (@rowlimit) SchemaName,TableName,IndexName,[PageCount],AVG_Fragm_percent,NotRunOnline from #T_RI order by [qt] desc) t
			order by NEWID();
		else
		BEGIN

			declare C cursor for
			select DB, SchemaName,TableName,IndexName, obj_id, ind_id ,[PageCount],AVG_Fragm_percent,PageU_prc,NotRunOnline
			from
			(select  top (@rowlimit) DB, SchemaName,TableName,IndexName, obj_id, ind_id,  [PageCount],AVG_Fragm_percent, PageU_prc, NotRunOnline from #T_RI order by [qt] desc) t
			order by NEWID();
			open C
			fetch next from C into @DB_current, @SchemaName,  @TableName, @IndexName, @obj_id, @ind_id, @PageCount, @AVG_Fragm_percent,@PageU_prc,@NotRunOnline;
			while @@fetch_status=0
			begin
				--Проверяем TimeOut, если время вышло - пишем в лог HS и выходим!
				IF @timeout_sec is not null AND @timeout_sec>0
				BEGIN
					set @time_elapsed_sec=DATEDIFF(second,@tt_start_usp, CAST(SYSDATETIME() AS datetime2(2)));
					IF @time_elapsed_sec>@timeout_sec
					BEGIN
						set @commant_text_log='Достигнут TimeOut в usp_reindex_run. @TimeOut_sec='+cast(@TimeOut_sec as varchar(30))+'; @time_elapsed_sec='+cast(@time_elapsed_sec as varchar(30));
						--Логгируем в историю Обслуживания БД:
						EXEC sputnik.db_maintenance.usp_WriteHS 
							@DB_ID=@db_id_check,
							@Command_Type=100, --100-TimeOut for Reindex (usp_reindex_run)
							@Command_Text_1000=@commant_text_log,
							@tt_start=@tt_start_usp,
							@Status=0; --0-Success
						BREAK; --выход из текущего цикла.
					END
				END

				set @db_id_check=DB_ID(@DB_current);
				select 
					@MirrorState=mirroring_state_desc
				from 
					sys.database_mirroring
				where
					mirroring_guid is not null
					and database_id=@db_id_check
	
				if @PauseMirroring=1 and @MirrorState in ('SYNCHRONIZED','SYNCHRONIZING')
					exec(N'alter database ['+@DB_current+'] set partner suspend');

				--Только если Enterprise: Автоопределение @MaxDop (если не задан) - в зависимости от объема индекса!
				IF @MaxDop IS NULL AND @Ed='Ent'
				BEGIN
					select @MaxDop_set=
					CASE 
						WHEN @PageCount<640 THEN 2		--5Мб
						WHEN @PageCount<6400 THEN 4 	--50Мб
						WHEN @PageCount<64000 THEN 8	--500Мб
						WHEN @PageCount<640000 THEN 16	--5Гб
						WHEN @PageCount<6400000 THEN 32	--50Гб
						ELSE 64
					END;
					--Если ядер CPU мало, то сработает послабление:
					select @MaxDop_set=
					CASE 
						WHEN @AllCores_cnt<=4 AND @MaxDop_set>1 THEN 1
						WHEN @AllCores_cnt<=9 AND @MaxDop_set>2 THEN 2
						WHEN @AllCores_cnt<=14 AND @MaxDop_set>3 THEN 3
						WHEN @AllCores_cnt<=16 AND @MaxDop_set>4 THEN 4
						WHEN @AllCores_cnt<=20  AND @MaxDop_set>5 THEN 5
						ELSE @MaxDop_set
					END;
					IF @AllCores_cnt<=@MaxDop_set
						set @MaxDop_set=@AllCores_cnt-1;
				END;

				set @check_set_online=@set_online;
				IF (@check_set_online='ON' and @NotRunOnline=1 and @policy_offline=1)
				BEGIN
					--Пропустить этот индекс
					set @command_type=8;
					set @commant_text_log='Этот индекс пропущен, т.к. @NotRunOnline=1 и @policy_offline=1';
					set @i_cnt_skip += 1;
				END
				ELSE BEGIN
	
					if @check_set_online='ON' and @NotRunOnline=1 and @policy_offline=0
						set @check_set_online='OFF';	
						
					--rebuild делаем только если фрагментация меньше @fragm_tresh и если заполненость страницы более чем @PageUsed_tresh
					--в остальных случаях нужен reorginize!
					if (@AVG_Fragm_percent <= @fragm_tresh AND (@PageU_prc>=@PageUsed_tresh)) OR (@NotRunOnline=1 AND @check_set_online='ON' AND @policy_offline=2)
					begin
						set @command=N'alter index '+@IndexName+N' on '+@SchemaName+N'.'+@TableName+N' reorganize ';
						set @command_type=2;
					end
					else if @AVG_Fragm_percent > @fragm_tresh OR (@PageU_prc<@PageUsed_tresh and @AVG_Fragm_percent>0)
					begin
						if @check_set_online='ON'
							set @command_type=1;
						else
							set @command_type=0;
						set @command=N'alter index '+@IndexName+N' on '+@SchemaName+N'.'+@TableName+N' rebuild with ( sort_in_tempdb = '+@set_sortintempdb+', online = '+@check_set_online+N' , data_compression = '+@set_compression+', fillfactor='+cast(@set_fillfactor as varchar(5))+CASE WHEN @Ed='Ent' THEN ', MAXDOP = '+cast(@MaxDop_set as varchar(5)) ELSE '' END+')';

					end
					set @tsql=@tsql_handle+N'
		use '+QUOTENAME(@DB_current)+';
		'			+@command;
			
					set @flag_fail=0;
					set @StrErr=NULL;
					BEGIN TRY
						--PRINT(@UpdCmd);
						set @tt_start=CAST(SYSDATETIME() AS datetime2(2));
						exec(@tsql);

						update [db_maintenance].[ReindexData] 
						set 
							[LastRunDate]=getdate(),
							[LastCommand]=@command,
							[ReindexCount]+=1
						where 
							DBName=QUOTENAME(@DB_current)
							AND SchemaName=@SchemaName
							AND TableName=@TableName
							AND IndexName=@IndexName;
					END TRY
					BEGIN CATCH
						set @flag_fail=1;
						set @StrErr=/*'Ошибка при обслуживании индексов через процедуру [usp_reindex_run]! Текст ошибки: '+*/COALESCE(ERROR_MESSAGE(),'null *Error message is not defined');
					END CATCH
					--НЕ будем тратить время на пересчет статистик. Тем более что пересчет статистик теперь выполняется в отдельной процедуре!
					--exec(N''use '+@DB_current+'; update statistics ''+ @SchemaName+N''.''+@TableName+N'' ''+@IndexName+N'' with fullscan'' );
			
					set @commant_text_log=@tsql_handle_log+@command;
	
					set @i_cnt+=1;
		
					waitfor delay @delayperiod;
				END;
		
			--Логгируем в историю Обслуживания БД:
				EXEC sputnik.db_maintenance.usp_WriteHS 
					@DB_ID=@db_id_check,
					@Object_ID=@obj_id,
					@Index_Stat_ID=@ind_id,
					@Index_Stat_Type=0, --0-Index
					@Command_Type=@command_type, --0-Rebuild Index Offline, 1-Rebuild Index Online, 2-Reorginize Index,8-Skip Offline Index
					@Command_Text_1000=@commant_text_log,
					@tt_start=@tt_start,
					@Status=@flag_fail, --0-Success, 1-Fail(Error)
					@Error_Text_1000=@StrErr;
				fetch next from C into @DB_current, @SchemaName,  @TableName, @IndexName, @obj_id, @ind_id, @PageCount, @AVG_Fragm_percent,@PageU_prc,@NotRunOnline;
			
			end
			close C;
			deallocate C;

			select 
				@MirrorState=mirroring_state_desc
			from 
				sys.database_mirroring
			where
				mirroring_guid is not null
				and database_id=DB_ID(@DB_current)
			if @PauseMirroring=1 and @MirrorState = 'SUSPENDED'
				exec(N'alter database ['+@DB_current+'] set partner resume');
	
			set @commant_text_log='Задача завершена: usp_reindex_run. Обработано объектов: '+CONVERT(VARCHAR(10),@i_cnt)+
			CASE WHEN @i_cnt_skip>0 THEN ' ; пропущено: '+CONVERT(VARCHAR(10),@i_cnt_skip)
				ELSE ''
			END
			+' . Параметры: @db_name='''+COALESCE(@db_name,'NULL')+''',@RowCount='+CONVERT(VARCHAR(10),@RowLimit);
			--Логгируем в историю Обслуживания БД:
			EXEC sputnik.db_maintenance.usp_WriteHS 
				@DB_ID=0,
				@Command_Type=200, --200-TaskCompleted for Reindex (usp_reindex_run)
				@Command_Text_1000=@commant_text_log,
				@tt_start=@tt_start_usp,
				@Status=0; --0-Success

		END
	END
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating Procedure [db_maintenance].[usp_RecomputeStats]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 01.03.2015 (1.0)
	-- Description: Процедура для Интеллектуального пересчета статистик распределения (UPDATE STATISTICS) 
					по тем статистикам, которые не были пересчитаны при выполнении Реиндексации!
					Есть обязательный параметр - @DBName - имя БД для которой нужно запустить пересчет статистик.
					Параметр @RowLimit - необязательный - определяет кол-во статистик, которые нужно пересчитать за 1 вызов (по умолчанию 100).
					Эта процедура должна вызываться из другой процедуры usp_reindex_start сразу после выполнения Реиндексации!
	-- Update:		
					30.04.2015 (1.1)
					Добавлены новые параметры для более гибкой работы с процедурой. Новые параметры @old_days, @perc_threshold, @rows_threshold
					позволяют при вызове процедуры задать фильтры на отбор статистик. Параметр @obj_filter позволяет отфильтровать статистики
					по имени объекта (таблицы), причем можно использовать % и _ для поиска по шаблону строки.
					Ещё один новый параметр @only_show - позволяет только просмотреть статистики без пересчета.

					01.07.2015 (2.0)
					Новая оптимизированная схема Реиндексации. Теперь пересчет статистик запускается на основании окон обслуживания.

					02.12.2016 (2.102)
					Внесены изменения в алгоритм определения @policy_scan.
					А также добавлен алгоритм Логгирования - запись результатов выполнения в таблицу HS через процедуру usp_WriteHS!
					Также исправлен алгоритм выборки статистик - при расчёте perc_change добавлена защита от деления на 0.
					Также добавлена возможность обновления статистик по нескольким БД (параметр @DBName теперь может принять значения NULL).

					31.03.2017 (2.110)
					Добавлены новые параметры: @ModCntr_max,@ModCntr_min,@timeout_sec.

					12.04.2017 (2.112)
					Исправление в алгоритме выбора статистик (динамический sql в переменной @TSQL). В конец добавлена сортировка:
					ORDER BY mod_count DESC, [perc_change] DESC - чтобы всегда выбирать наименее актуальные статистики.

					02.06.2017	(2.120)
					Добавлен механизм исключений (таблица TabList_US и функция uf_CheckTabList_US).
					Также при выборе Policy_Scan теперь учитывается кол-во ядер CPU, доступных SQL - если менее 12 ядер,
					то Policy_Scan менее трудозатратный.

					18.07.2017	(2.142)
					ПАТЧ 01 - исправление в механизме исключений. Теперь в любом случае сначала будет
					проверка исключения (даже если задан @policy_scan), а потом уже определение @policy_scan. 
					ПАТЧ 02 - исправление при учёте кол-ва ядер CPU. Теперь три варианта: до 5 ядер, от 6 и до 11 ядер, и более 12 ядер.
					ИЗМЕНЕНИЕ 01 - теперь policy_scan учитывается не по числу строк, а по размеру таблицы!
					ИЗМЕНЕНИЕ 02 - добавлены два новых параметра @filter_DataUsedMb_min и @filter_DataUsedMb_max - 
					для фильтрации по размеру таблиц!

					29.12.2017	(2.147)
					Увеличен размер для всех строковых переменных.
					Небольшое изменение алгоритма выбора имени БД - чтобы в обработку попадали БД с кириллицей в названии.
	-- ============================================= */
	CREATE PROCEDURE db_maintenance.usp_RecomputeStats
		@DBName nvarchar(2000)=NULL,
		@UniqueName_SL nvarchar(200)=NULL,
		@RowLimit smallint=10,
		@delayperiod char(12)='00:00:00.200',
		@filter_rows_min int=NULL,
		@filter_rows_max int=NULL,
		@filter_DataUsedMb_min numeric(9,1)=NULL,
		@filter_DataUsedMb_max numeric(9,1)=NULL,
		@filter_perc_min decimal(18,2)=15.00,
		@filter_perc_max decimal(18,2)=NULL,
		@filter_old_hours tinyint=24,
		@policy_scan varchar(100)=NULL,
		@PauseMirroring bit=0,
		@DeadLck_PR smallint=0,
		@Lck_Timeout int=20000,
		@obj_filter nvarchar(2000) = null,
		@only_show bit = 0,
		@ModCntr_max bigint=10000000, --Если кол-во измененных строк больше этого, будем обновлять!
		@ModCntr_min int=10, --Защита от маленьких таблиц. Если кол-во измененных строк меньше этого - пропускаем!
		@timeout_sec int = NULL,		--Ограничение времени выполнения в данной процедуре в сек. Если NULL (или 0) - бесконечно.
		@analyze_mode smallint = 0 --Вывод информации в аналитическом виде.
	as
	begin
		set nocount on;
		SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
		DECLARE @tt_start datetime2(2), @StrErr NVARCHAR(MAX);
		declare @tt_start_usp datetime2(2), @time_elapsed_sec int, @i_cnt bigint=0;
		DECLARE @TSQL NVARCHAR(MAX),@obj_filter_str nvarchar(2000), @StopList_str NVARCHAR(MAX);
		DECLARE @AllCores_cnt smallint;
		set @tt_start_usp=CAST(SYSDATETIME() AS datetime2(2));
		--Формируем список исключений таблиц, индексы для этих таблиц не будут обслужены в текущем запуске.
		select @StopList_str=StopList_str from sputnik.db_maintenance.StopLists where UniqueName=@UniqueName_SL;
		select @StopList_str=COALESCE(@StopList_str,'');

		--Определяем доступное кол-во ядер CPU для SQL Server:
		select @AllCores_cnt=count(*) from sys.dm_os_schedulers where [status]='VISIBLE ONLINE';

		IF OBJECT_ID('tempdb.dbo.#T_ST') IS NOT NULL
			DROP TABLE #T_ST;
		CREATE TABLE #T_ST (db NVARCHAR(2000), shm NVARCHAR(2000), obj NVARCHAR(2000), stat NVARCHAR(2000), obj_id int, stat_id int, last_upd datetime2(2), mod_count bigint, perc_change decimal(18,2), row_count bigint,DataUsed_Mb decimal(9,1));

		/*	Отбор БД для обслуживания */
		declare @DB_current nvarchar(2000);
		if OBJECT_ID('tempdb..#src_ag_db') IS NOT NULL
			DROP TABLE #src_ag_db;
		CREATE TABLE #src_ag_db (DB nvarchar(2000), [db_id] int, [Role] nvarchar(800), [PartnerReplica] nvarchar(800), [PrimaryReplica] nvarchar(800), sync_state nvarchar(800), health nvarchar(800), DB_State nvarchar(800));
		IF CAST (LEFT (CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(2)),2) AS SMALLINT) >= 11
			--Информация о вторичных репликах AlwaysON AG на текущем сервере:
			INSERT INTO #src_ag_db (DB, [db_id], [Role], [PartnerReplica], [PrimaryReplica], sync_state, health, DB_State)
				SELECT
					DB_NAME(ag_db.database_id) as DB,
					ag_db.database_id as [db_id],
					ISNULL(arstates.role_desc, '') AS [Role],
					ISNULL(AR.replica_server_name, '') as [PartnerReplica],
					ISNULL(agstates.primary_replica, '') AS [PrimaryReplica],
					ag_db.synchronization_state_desc as sync_state,
					ag_db.synchronization_health_desc as health,
					ag_db.database_state_desc as DB_State 
				FROM sys.dm_hadr_database_replica_states ag_db
				LEFT JOIN sys.dm_hadr_availability_group_states as agstates
					on ag_db.group_id=agstates.group_id	
				LEFT JOIN sys.dm_hadr_availability_replica_states AS arstates
					ON ag_db.replica_id = arstates.replica_id
						and ag_db.group_id=arstates.group_id
				LEFT JOIN sys.availability_replicas as AR
					ON ag_db.replica_id=AR.replica_id
						and ag_db.group_id=AR.group_id
				WHERE ag_db.is_local=1 
					AND ISNULL(arstates.role_desc, '') = 'SECONDARY'
		DECLARE DB CURSOR FOR
		select name as DB
		from sys.databases sdb
		left join #src_ag_db adb ON sdb.database_id=adb.[db_id]
		where 
			(name = @DBName or @DBName is null or @DBName='') 
			and state_desc='ONLINE'
			and database_id>4
			and is_read_only=0
			and (name NOT LIKE '201%(%)%' and name NOT LIKE 'S201%(%)%')
			and adb.db is null;
		OPEN DB;
		FETCH NEXT FROM DB INTO @DB_current;
		WHILE @@FETCH_STATUS=0
		BEGIN
			SET @obj_filter_str=COALESCE(@obj_filter,'');
			SET @TSQL=N'USE ['+@DB_current+N'];
			INSERT INTO #T_ST
			SELECT TOP ('+CONVERT(NVARCHAR(10),@RowLimit)+N')
					CAST(DB_NAME() AS NVARCHAR(2000)) as [db], SCHEMA_NAME(objs.schema_id) as shm, objs.name as obj, stat.name as stat, objs.object_id as obj_id, stat.stats_id as stat_id,
					CAST(sp.last_updated as datetime2(2)) as last_upd, sp.modification_counter as mod_count,
					CAST(100 * CAST([sp].[modification_counter] AS DECIMAL(18,2)) / CAST(IIF([sp].[rows]=0,1,[sp].[rows]) AS DECIMAL(18,2)) AS DECIMAL(18,2)) AS [perc_change], prts.rows as row_count, prts.DataUsed_Mb
			FROM sys.stats stat
			INNER JOIN sys.objects objs ON stat.object_id=objs.object_id
			INNER JOIN 
				(
					SELECT
						p.object_id,
						SUM(p.row_count) AS rows, 
						CAST(SUM(p.[used_page_count])/128.0 as numeric(9,1)) AS DataUsed_Mb
					FROM sys.dm_db_partition_stats p
					WHERE index_id IN (0,1)
					GROUP BY p.object_id
				) prts
				 ON objs.object_id=prts.object_id
			CROSS APPLY sys.dm_db_stats_properties(stat.object_id, stat.stats_id) AS sp
			WHERE 
				(
					(CAST(100 * CAST([sp].[modification_counter] AS DECIMAL(18,2)) / CAST(IIF([sp].[rows]=0,1,[sp].[rows]) AS DECIMAL(18,2)) AS DECIMAL(18,2)) >= '+CONVERT(VARCHAR(18),@filter_perc_min)+'
					AND ('+COALESCE(CONVERT(VARCHAR(20),@filter_perc_max),'NULL')+' IS NULL OR CAST(100 * CAST([sp].[modification_counter] AS DECIMAL(18,2)) / CAST(IIF([sp].[rows]=0,1,[sp].[rows]) AS DECIMAL(18,2)) AS DECIMAL(18,2)) <= '+COALESCE(CONVERT(VARCHAR(20),@filter_perc_max),'NULL')+'))
					OR [sp].[modification_counter]>'+COALESCE(CONVERT(VARCHAR(30),@ModCntr_max),'1000000')+'
				)
				AND [sp].[modification_counter]>'+COALESCE(CONVERT(VARCHAR(30),@ModCntr_min),'10')+'
				AND last_updated<DATEADD(HOUR,-'+CONVERT(VARCHAR(5),@filter_old_hours)+',getdate())
				AND ('+COALESCE(CONVERT(VARCHAR(20),@filter_rows_min),'NULL')+' IS NULL OR prts.rows>='+COALESCE(CONVERT(VARCHAR(20),@filter_rows_min),'NULL')+')
				AND ('+COALESCE(CONVERT(VARCHAR(20),@filter_rows_max),'NULL')+' IS NULL OR prts.rows<='+COALESCE(CONVERT(VARCHAR(20),@filter_rows_max),'NULL')+')
				AND ('+COALESCE(CONVERT(VARCHAR(20),@filter_DataUsedMb_min),'NULL')+' IS NULL OR prts.DataUsed_Mb>='+COALESCE(CONVERT(VARCHAR(20),@filter_DataUsedMb_min),'NULL')+')
				AND ('+COALESCE(CONVERT(VARCHAR(20),@filter_DataUsedMb_max),'NULL')+' IS NULL OR prts.DataUsed_Mb<='+COALESCE(CONVERT(VARCHAR(20),@filter_DataUsedMb_max),'NULL')+')
				AND ('''+@obj_filter_str+'''='''' OR objs.name LIKE '''+@obj_filter_str+''')
				AND CHARINDEX(objs.name+'';'','''+@StopList_str+''')=0
			ORDER BY mod_count DESC, [perc_change] DESC
			;';

			--PRINT(@TSQL);
			EXEC(@TSQL);
			FETCH NEXT FROM DB INTO @DB_current;
		END
		CLOSE DB;
		DEALLOCATE DB;

		--Создадим индекс по mod_count и perc_change!
		--Для отбора по кол-ву изменённых строк+по % изменений!
		CREATE CLUSTERED INDEX tmp_cix_mod01 ON #T_ST
		(
			mod_count DESC,
			perc_change DESC
		) ;

		IF @only_show=1
		BEGIN
			IF @analyze_mode=0 
				SELECT TOP (@RowLimit) * FROM #T_ST ORDER BY mod_count DESC, perc_change DESC;
			IF @analyze_mode=1
				SELECT DISTINCT 
					[db], [shm], 
					COUNT_BIG(*) over (partition by [db], [shm]) as cnt,
					SUM(mod_count)  over (partition by [db], [shm]) as sum_mod_cnt,
					SUM(row_count)  over (partition by [db], [shm]) as sum_row_count,
					CAST(100 * CAST(SUM(mod_count)  over (partition by [db], [shm]) AS DECIMAL(19,0)) / CAST(IIF(SUM(row_count)  over (partition by [db], [shm])=0,1,SUM(row_count)  over (partition by [db], [shm])) AS DECIMAL(19,0)) AS DECIMAL(19,0)) AS [perc_change],
					SUM(DataUsed_Mb)  over (partition by [db], [shm]) as sum_DataUsed_Mb,
					MIN(last_upd) over  (partition by [db], [shm]) as old_upd
				FROM #T_ST
			IF @analyze_mode=2
			BEGIN
				;WITH cte_src01 as(
					SELECT COUNT_BIG(DISTINCT [db]) as db_cnt FROM #T_ST
				)
				SELECT TOP 1 
					(SELECT db_cnt FROM cte_src01) as db_cnt,
					COUNT_BIG(*) over () as cnt,
					SUM(mod_count)  over () as sum_mod_cnt,
					SUM(row_count)  over () as sum_row_count,
					CAST(100 * CAST(SUM(mod_count)  over () AS DECIMAL(19,0)) / CAST(IIF(SUM(row_count)  over ()=0,1,SUM(row_count)  over ()) AS DECIMAL(19,0)) AS DECIMAL(19,0)) AS [perc_change],
					SUM(DataUsed_Mb)  over () as sum_DataUsed_Mb,
					MIN(last_upd) over () as old_upd
				FROM #T_ST
			END
		END
		ELSE
		BEGIN		 
			DECLARE @commant_text_log NVARCHAR(MAX),@HandleCmd NVARCHAR(2000), @Cmd_handle_log NVARCHAR(MAX), @UpdCmd NVARCHAR(MAX), @shm_id int, @obj_id int, @stat_id int, @db_id int, @flag_fail bit;
			DECLARE CST CURSOR FOR
			SELECT TOP(@RowLimit)
				N'SET DEADLOCK_PRIORITY '+CAST(@DeadLck_PR as nvarchar(5))+N';
				SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
				SET LOCK_TIMEOUT '+CAST(@Lck_Timeout as nvarchar(25))+N';
				USE ['+DB+N'];
				' as Cmd_Handle,
				--Заголовок запроса для логгирования:
				tsql_handle_log=N'--dlck_pr='+CAST(@DeadLck_PR as nvarchar(2))+N';tr_iso_lvl=1;lck_tmt='+CAST(@Lck_Timeout as nvarchar(12))+N';
				',
				N'UPDATE STATISTICS '+QUOTENAME(shm)+N'.'+QUOTENAME(obj)+N' '+QUOTENAME(stat)+N' '+
				COALESCE(
					--Сначало проверяем исключения по таблице и статистике:
					COALESCE(db_maintenance.uf_CheckTabList_US(QUOTENAME(obj),QUOTENAME(stat)),@policy_scan),
					CASE 
						WHEN @AllCores_cnt>11 OR DataUsed_Mb<750 THEN 
							CASE 
								----Сначало проверяем исключения по таблице и статистике:
								--WHEN db_maintenance.uf_CheckTabList_US(QUOTENAME(obj),QUOTENAME(stat)) IS NOT NULL THEN db_maintenance.uf_CheckTabList_US(QUOTENAME(obj),QUOTENAME(stat))  
								WHEN DataUsed_Mb<=300 THEN N'WITH FULLSCAN;'
								--WHEN row_count<1000000 THEN 'WITH FULLSCAN;'
								WHEN DataUsed_Mb<=500 THEN N'WITH SAMPLE 90 PERCENT;'
								--WHEN row_count<3000000 THEN 'WITH SAMPLE 90 PERCENT;'
								WHEN DataUsed_Mb<=1024  THEN N'WITH SAMPLE 75 PERCENT;'
								--WHEN row_count<5000000 THEN 'WITH SAMPLE 85 PERCENT;'
								WHEN DataUsed_Mb<1500 THEN N'WITH SAMPLE 50 PERCENT;'
								--WHEN row_count<10000000 THEN 'WITH SAMPLE 50 PERCENT;'
								WHEN DataUsed_Mb<2048 THEN N'WITH SAMPLE 35 PERCENT;'
								--WHEN row_count<15000000 THEN 'WITH SAMPLE 40 PERCENT;'
								WHEN DataUsed_Mb<3000 THEN N'WITH SAMPLE 24 PERCENT;'
								--WHEN row_count<20000000 THEN 'WITH SAMPLE 25 PERCENT;'
								WHEN DataUsed_Mb<5000 THEN N'WITH SAMPLE 12 PERCENT;'
								--WHEN row_count<30000000 THEN 'WITH SAMPLE 15 PERCENT;'
								WHEN DataUsed_Mb<7000 THEN N'WITH SAMPLE 9 PERCENT;'
								--WHEN row_count<50000000 THEN 'WITH SAMPLE 10 PERCENT;'
								WHEN DataUsed_Mb<10100 THEN N'WITH SAMPLE 6 PERCENT;'
								--WHEN row_count<75000000 THEN 'WITH SAMPLE 7 PERCENT;'
								WHEN DataUsed_Mb<15100 THEN N'WITH SAMPLE 3 PERCENT;'
								--WHEN row_count<100000000 THEN 'WITH SAMPLE 5 PERCENT;'
								WHEN DataUsed_Mb<20100 THEN N'WITH SAMPLE 2 PERCENT;'
								WHEN DataUsed_Mb<30100 THEN N'WITH SAMPLE 1 PERCENT;'
								--WHEN row_count<200000000 THEN 'WITH SAMPLE 3 PERCENT;'
								--WHEN row_count<300000000 THEN 'WITH SAMPLE 2 PERCENT;'
								--WHEN row_count<500000000 THEN 'WITH SAMPLE 1 PERCENT;'
								ELSE N'WITH SAMPLE 50000 ROWS'
							END
						WHEN (@AllCores_cnt>5 AND @AllCores_cnt<=11) OR DataUsed_Mb<1500  THEN
							CASE 
								----Сначало проверяем исключения по таблице и статистике:
								--WHEN db_maintenance.uf_CheckTabList_US(QUOTENAME(obj),QUOTENAME(stat)) IS NOT NULL THEN db_maintenance.uf_CheckTabList_US(QUOTENAME(obj),QUOTENAME(stat))  
								--WHEN row_count<500000 THEN 'WITH FULLSCAN;'
								--WHEN row_count<1000000 THEN 'WITH SAMPLE 80 PERCENT;'
								--WHEN row_count<2000000 THEN 'WITH SAMPLE 45 PERCENT;'
								--WHEN row_count<3000000 THEN 'WITH SAMPLE 30 PERCENT;'
								--WHEN row_count<5000000 THEN 'WITH SAMPLE 20 PERCENT;'
								--WHEN row_count<7000000 THEN 'WITH SAMPLE 13 PERCENT;'
								--WHEN row_count<10000000 THEN 'WITH SAMPLE 9 PERCENT;'
								--WHEN row_count<15000000 THEN 'WITH SAMPLE 6 PERCENT;'
								--WHEN row_count<20000000 THEN 'WITH SAMPLE 3 PERCENT;'
								--WHEN row_count<40000000 THEN 'WITH SAMPLE 2 PERCENT;'
								--WHEN row_count<75000000 THEN 'WITH SAMPLE 1 PERCENT;'
								--ELSE 'WITH SAMPLE 700000 ROWS'
								WHEN DataUsed_Mb<=151 THEN N'WITH FULLSCAN;'
								WHEN DataUsed_Mb<=300 THEN N'WITH SAMPLE 90 PERCENT;'
								WHEN DataUsed_Mb<=751  THEN N'WITH SAMPLE 75 PERCENT;'
								WHEN DataUsed_Mb<1201 THEN N'WITH SAMPLE 50 PERCENT;'
								WHEN DataUsed_Mb<1801 THEN N'WITH SAMPLE 35 PERCENT;'
								WHEN DataUsed_Mb<2048 THEN N'WITH SAMPLE 24 PERCENT;'
								WHEN DataUsed_Mb<3501 THEN N'WITH SAMPLE 12 PERCENT;'
								WHEN DataUsed_Mb<5501 THEN N'WITH SAMPLE 9 PERCENT;'
								WHEN DataUsed_Mb<7510 THEN N'WITH SAMPLE 6 PERCENT;'
								WHEN DataUsed_Mb<10100 THEN N'WITH SAMPLE 3 PERCENT;'
								WHEN DataUsed_Mb<15100 THEN N'WITH SAMPLE 2 PERCENT;'
								WHEN DataUsed_Mb<20100 THEN N'WITH SAMPLE 1 PERCENT;'
								ELSE N'WITH SAMPLE 25000 ROWS'
							END
						ELSE
							CASE 
								----Сначало проверяем исключения по таблице и статистике:
								--WHEN db_maintenance.uf_CheckTabList_US(QUOTENAME(obj),QUOTENAME(stat)) IS NOT NULL THEN db_maintenance.uf_CheckTabList_US(QUOTENAME(obj),QUOTENAME(stat))  
								--WHEN row_count<200000 THEN 'WITH FULLSCAN;'
								--WHEN row_count<300000 THEN 'WITH SAMPLE 80 PERCENT;'
								--WHEN row_count<500000 THEN 'WITH SAMPLE 50 PERCENT;'
								--WHEN row_count<1000000 THEN 'WITH SAMPLE 30 PERCENT;'
								--WHEN row_count<2000000 THEN 'WITH SAMPLE 15 PERCENT;'
								--WHEN row_count<3000000 THEN 'WITH SAMPLE 10 PERCENT;'
								--WHEN row_count<4000000 THEN 'WITH SAMPLE 8 PERCENT;'
								--WHEN row_count<5000000 THEN 'WITH SAMPLE 6 PERCENT;'
								--WHEN row_count<7000000 THEN 'WITH SAMPLE 3 PERCENT;'
								--WHEN row_count<10000000 THEN 'WITH SAMPLE 2 PERCENT;'
								--ELSE 'WITH SAMPLE 300000 ROWS'
								WHEN DataUsed_Mb<=101 THEN N'WITH FULLSCAN;'
								WHEN DataUsed_Mb<=200 THEN N'WITH SAMPLE 90 PERCENT;'
								WHEN DataUsed_Mb<=551  THEN N'WITH SAMPLE 75 PERCENT;'
								WHEN DataUsed_Mb<1001 THEN N'WITH SAMPLE 50 PERCENT;'
								WHEN DataUsed_Mb<1501 THEN N'WITH SAMPLE 35 PERCENT;'
								WHEN DataUsed_Mb<1751 THEN N'WITH SAMPLE 24 PERCENT;'
								WHEN DataUsed_Mb<2501 THEN N'WITH SAMPLE 12 PERCENT;'
								WHEN DataUsed_Mb<3501 THEN N'WITH SAMPLE 9 PERCENT;'
								WHEN DataUsed_Mb<5510 THEN N'WITH SAMPLE 6 PERCENT;'
								WHEN DataUsed_Mb<7800 THEN N'WITH SAMPLE 3 PERCENT;'
								WHEN DataUsed_Mb<10100 THEN N'WITH SAMPLE 2 PERCENT;'
								WHEN DataUsed_Mb<25100 THEN N'WITH SAMPLE 1 PERCENT;'
								ELSE N'WITH SAMPLE 12000 ROWS'
							END
					END )
				 as Cmd,
				obj_id, stat_id, DB_ID(DB)
			FROM #T_ST
			ORDER BY mod_count DESC, perc_change DESC;
		
			OPEN CST;
			FETCH NEXT FROM CST INTO @HandleCmd, @Cmd_handle_log, @UpdCmd, @obj_id, @stat_id, @db_id;
			WHILE @@FETCH_STATUS=0
			BEGIN
				--Проверяем TimeOut, если время вышло - пишем в лог HS и выходим!
				IF @timeout_sec is not null AND @timeout_sec>0
				BEGIN
					set @time_elapsed_sec=DATEDIFF(second,@tt_start_usp, CAST(SYSDATETIME() AS datetime2(2)));
					IF @time_elapsed_sec>@timeout_sec
					BEGIN
						set @commant_text_log=N'Достигнут TimeOut в usp_RecomputeStats. @TimeOut_sec='+cast(@TimeOut_sec as nvarchar(30))+N'; @time_elapsed_sec='+cast(@time_elapsed_sec as nvarchar(30));
						--Логгируем в историю Обслуживания БД:
						EXEC sputnik.db_maintenance.usp_WriteHS 
							@DB_ID=@db_id,
							@Command_Type=101, --101-TimeOut for Update Statistics (usp_RecomputeStats)
							@Command_Text_1000=@commant_text_log,
							@tt_start=@tt_start_usp,
							@Status=0; --0-Success
						BREAK; --выход из текущего цикла.
					END
				END

				set @flag_fail=0;
				set @StrErr=NULL;
				BEGIN TRY
					--PRINT(@HandleCmd);
					set @tt_start=CAST(SYSDATETIME() AS datetime2(2));
					EXEC(@HandleCmd+@UpdCmd);

				END TRY
				BEGIN CATCH
					set @flag_fail=1;
					set @StrErr=/*'Ошибка при пересчёте статистик распределения через процедуру [usp_RecomputeStats]! Текст ошибки: '+*/COALESCE(ERROR_MESSAGE(),'null *Error message is not defined');
				END CATCH
				set @commant_text_log=@Cmd_handle_log+@UpdCmd;
				--Логгируем в историю Обслуживания БД:
				EXEC sputnik.db_maintenance.usp_WriteHS 
					@DB_ID=@db_id,
					@Object_ID=@obj_id,
					@Index_Stat_ID=@stat_id,
					@Index_Stat_Type=1, --1-Statistic
					@Command_Type=3, --3-Update Statistics
					@Command_Text_1000=@commant_text_log,
					@tt_start=@tt_start,
					@Status=@flag_fail, --0-Success, 1-Fail(Error)
					@Error_Text_1000=@StrErr;
			
				set @i_cnt+=1;
				--Делаем заданную задержку перед следующим запуском!
				WAITFOR DELAY @delayperiod;

				FETCH NEXT FROM CST INTO @HandleCmd, @Cmd_handle_log, @UpdCmd, @obj_id, @stat_id, @db_id;
			END
			CLOSE CST;
			DEALLOCATE CST;
		END;
		IF @only_show=0
		BEGIN
			set @commant_text_log=N'Задача завершена: usp_RecomputeStats. Обработано объектов: '+CONVERT(NVARCHAR(10),@i_cnt)+N' . Параметры: @DBName='''+COALESCE(@DBName,'NULL')+N''',@RowCount='+CONVERT(nvarchar(20),@RowLimit);
			--Логгируем в историю Обслуживания БД:
			EXEC sputnik.db_maintenance.usp_WriteHS 
				@DB_ID=0,
				@Command_Type=201, --201-TaskCompleted for Update Statistics (usp_RecomputeStats)
				@Command_Text_1000=@commant_text_log,
				@tt_start=@tt_start_usp,
				@Status=0; --0-Success
		END;
	end
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating Procedure [db_maintenance].[usp_reindex_start]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 24.01.2013 (1.0)
	-- Description: Процедура для запуска Реиндексации по всем настроенным в таблице ReindexConf базам.
					Параметр @DBFilter - здесь можно указать для какой конкретно базы будет выполнен запуск.
					Параметр @StartUpdateStats - если задан 1, то запускается Сбор статистик по индексам. Если 0, то запускается
						Реиндексация. По умолчанию 0.
	-- Update:		
					21.02.2014 (1.1) Получения дня недели реализовано с помощью отдельной функции uf_GetWeekDay
					26.02.2014 (1.11) Изменения столбца filter_old_hours.
					11.03.2014 (1.2) В таблице ReindexConf добавлено новое поле PauseMirroring (тип bit). Значение по умолчанию 0.
									 Если значение 1, тогда на время Реиндексации Сеанс Зеркалирования для базы должен быть приостановлен!
					12.03.2014 (1.22) Небольшое исправление - теперь при вызове процедуры usp_reindex_run Параметры указываются через ИмяПараметра=Значение.
					15.10.2014 (1.25) Добавлен новый параметр @TableFilter - теперь можно запустить сбор статистик и реиндексацию для конкретной таблицы!!
					01.03.2015 (1.27) Добавлен вызов ХП usp_ReComputeStats - Интеллектуальный пересчет статистик распределения сразу после Реиндексации.
									  Будут пересчитываться только те статистики, которые не пересчитались при Реиндексации!
					02.03.2015 (1.28) Вызов модуля usp_freeproccache (сброс процедурного кэша) перенесён в конец этого модуля из модуля usp_reindex_run.
					23.06.2015 (2.00) Полная оптимизация схемы Реиндексации. Процедура запуска значительно переделана под новую схему.
					07.07.2015 (2.01) Исправлен алгоритм выбора окна обслуживания!
					09.07.2015 (2.02) Добавлен параметр @only_show - просмотр данных для обслуживания (без обслуживания)!
									 Также исправлен вызов Реиндексации - был пропущен параметр @UniqueName_SL.
					07.09.2015 (2.03) Исправлен алгоритм выборка окна обслуживания.
					16.12.2015 (2.04) Исправлен алгоритм выбора окна обслуживания. Неправильно отрабатывал, когда задано окно в два дня (сегодня и завтра).
					10.08.2016 (2.05) Исправлен алгоритм запуска обновления данных по индексам (@StartUpdateStats=1). При запуске задан параметр @oldupdhours=3
					чтобы обновлять информацию о состоянии индексов каждые 3 часа.
					18.08.2016 (2.06) Исправлен алгоритм запуска обновления данных по индексам (@StartUpdateStats=1). 
					При запуске задан новый параметр @rowlimit_max=1000 - за 1 запуск обновляем только 1000 самых устаревших статистик .
					02.12.2016 (2.102) В новой версии поддерживается реиндексация и обновление статистик по нескольким БД.
					19.07.2017 (2.104) Небольшой ПАТЧ - добавлена возможность использования параметров filter_DataUsedMb_min и filter_DataUsedMb_max
					в алгоритме запуска Пересчёта статистик распределения.
	-- ============================================= */
	CREATE PROCEDURE db_maintenance.usp_reindex_start
		@DBFilter nvarchar(300) = null,
		@StartUpdateStats bit = 0,
		@TableFilter nvarchar(300) = null,
		@StartRecomputeStats bit = 0,
		@only_show bit = 0
	as
	begin
		set nocount on;
		declare @getdate datetime, @gettime time,  @WeekDay tinyint;
		declare @DBName nvarchar(500), @RowLimit smallint, @delayperiod char(12), @filter_pages_min int , @filter_pages_max int , @UniqueName_SL nvarchar(200),
		@filter_fragm_min tinyint, @filter_fragm_max tinyint, @filter_old_hours tinyint, 
		@fragm_tresh tinyint, @set_fillfactor tinyint, @set_compression char(4), @set_online char(3), @set_sortintempdb char(3), @PauseMirroring bit,
		@DeadLck_PR smallint, @Lck_Timeout int, @filter_rows_min int, @filter_rows_max int, @filter_perc_min decimal(18,2), @filter_perc_max decimal(18,2),
		@policy_scan varchar(100), @timeout_sec int;
		declare @mv_Name nvarchar(200);
		declare @filter_DataUsedMb_min numeric(9,1), @filter_DataUsedMb_max numeric(9,1);
		set @getdate=GETDATE();
		set @gettime=CAST(@getdate as TIME);
		--Определяем текущий день недели!
		select @WeekDay=sputnik.info.uf_GetWeekDay(@getdate);

		--Определяем наиболее подходящее окно обслуживания для текущего времени!
		--insert into @mv(Name)
		select top 1 @mv_Name=UniqueName
		from sputnik.db_maintenance.mw as mw
		where 
				(@getdate >= mw.DateOpen OR mw.DateOpen IS NULL)
			  and (@getdate <= mw.DateClose OR mw.DateClose IS NULL)
			  and (
				(
					(@gettime >= IIF(mw.TimeOpen<mw.TimeClose,mw.TimeOpen,'00:00:00') OR mw.TimeOpen IS NULL)
					 and (@gettime <= mw.TimeClose OR mw.TimeClose IS NULL)
				) 
				OR	
				(	(@gettime >= mw.TimeOpen OR mw.TimeOpen IS NULL)
					and (@gettime <= IIF(mw.TimeOpen<mw.TimeClose,mw.TimeClose,'23:59:59.999') OR mw.TimeClose IS NULL)
				)
			  )
			  and (CHARINDEX(CAST(@WeekDay as CHAR(1)),mw.WeekDays/*,CAST(@WeekDay as CHAR(1))*/)>0 OR mw.WeekDays IS NULL)
			  /*and UniqueName IN (select UniqueName_MW from sputnik.db_maintenance.ReindexConf)*/
		order by IIF(TimeClose<TimeOpen,DATEDIFF(minute, TimeOpen, '23:59:59')+1+DATEDIFF(minute, '00:00:00', TimeClose),DATEDIFF (minute, TimeOpen,TimeClose));
		--select @mv_Name as MW_Name;

		if @StartRecomputeStats=0
		BEGIN
			--Определяем настройки Реиндексации на основании окна обслуживания!
			--Проверяем что эти базы существуют, и их состояние ONLINE, и это не системные БД!
			declare INDEXs cursor
			for
				select Conf.*
				from
				(
					select [DBName]
							--,[UniqueName_MW]
							,[UniqueName_SL]
							,[RowLimit]
							,[delayperiod]
							,[filter_pages_min]
							,[filter_pages_max]
							,[filter_fragm_min]
							,[filter_fragm_max]
							,[filter_old_hours]
							,[fragm_tresh]
							,[set_fillfactor]
							,[set_compression]
							,[set_online]
							,[set_sortintempdb]
							,[PauseMirroring]
							,[DeadLck_PR]
							,[Lck_Timeout]
							,[timeout_sec]
					from sputnik.db_maintenance.ReindexConf
					where
						(@DBFilter is null or DBName=@DBFilter)
						and (UniqueName_MW = @mv_Name ) 
				) Conf
				inner join
				(
					select name as dbname
					from sys.databases
					where 
					state_desc='ONLINE' and is_in_standby=0 and is_read_only=0
					and name not in ('master','msdb','model','tempdb')
					union all 
					select NULL as dbname
				) DBFact
				on Conf.dbname=DBFact.dbname OR (DBFact.dbname IS NULL and Conf.DBName IS NULL)
		END
		else 
		BEGIN
			--Определяем настройки Пересчета статистик на основании окна обслуживания!
			--Проверяем что эти базы существуют, и их состояние ONLINE, и это не системные БД!
			declare ReStats cursor
			for
				select Conf.*
				from
				(
					select  [DBName]
						  --,[UniqueName_MW]
						  ,[UniqueName_SL]
						  ,[RowLimit]
						  ,[delayperiod]
						  ,[filter_rows_min]
						  ,[filter_rows_max]
						  ,filter_DataUsedMb_min , filter_DataUsedMb_max 
						  ,[filter_perc_min]
						  ,[filter_perc_max]
						  ,[filter_old_hours]
						  ,[policy_scan]
						  ,[PauseMirroring]
						  ,[DeadLck_PR]
						  ,[Lck_Timeout]
						  ,[timeout_sec]
					from sputnik.db_maintenance.RecomputeStatsConf
					where
						(@DBFilter is null or DBName=@DBFilter)
						and (UniqueName_MW = @mv_Name ) 
				) Conf
				inner join
				(
					select name as dbname
					from sys.databases
					where 
					state_desc='ONLINE' and is_in_standby=0 and is_read_only=0
					and name not in ('master','msdb','model','tempdb')
					union all 
					select NULL as dbname
				) DBFact
				on Conf.dbname=DBFact.dbname OR (DBFact.dbname IS NULL and Conf.DBName IS NULL)
		END
	
		if @StartRecomputeStats=0 --Запуск Реиндексации или сбора информации по таблицам и индексам.
		BEGIN
			open INDEXs
			fetch next from INDEXs
				into @DBName, @UniqueName_SL, @RowLimit, @delayperiod, @filter_pages_min, @filter_pages_max, @filter_fragm_min, @filter_fragm_max,
					@filter_old_hours, @fragm_tresh, @set_fillfactor, @set_compression, @set_online, @set_sortintempdb, @PauseMirroring, @DeadLck_PR,
					@Lck_Timeout,@timeout_sec;
			while @@FETCH_STATUS=0
			begin
				if @StartUpdateStats=0
					--Запуск Реиндексации!
					EXEC db_maintenance.usp_reindex_run 
						@db_name=@DBName, 
						@UniqueName_SL=@UniqueName_SL,
						@RowLimit=@RowLimit, 
						@delayperiod=@delayperiod, 
						@filter_pages_min=@filter_pages_min,
						@filter_pages_max=@filter_pages_max, 
						@filter_fragm_min=@filter_fragm_min,
						@filter_fragm_max=@filter_fragm_max,
						@filter_old_hours=@filter_old_hours, 
						@fragm_tresh=@fragm_tresh, 
						@set_fillfactor=@set_fillfactor, 
						@set_compression=@set_compression, 
						@set_online=@set_online, 
						@set_sortintempdb=@set_sortintempdb,
						@PauseMirroring=@PauseMirroring,
						@TableFilter=@TableFilter,
						@DeadLck_PR=@DeadLck_PR,
						@Lck_Timeout=@Lck_Timeout,
						@only_show=@only_show,
						@timeout_sec=@timeout_sec;
				else
				BEGIN
					--Запуск Сбора статистик(информации) по индексам и таблицам!
					--Указываем @oldupdhours=3 - означает, что обновляем только те данные, которые старше 3 часов.
					--@rowlimit_max=1000 - за 1 запуск обновляем только 1000 самых устаревших статистик .
				
					--для отладки
					--select @DBName as DBName, @rowlimit as rowlimit, @delayperiod as DelayPeriod,
					--	   3 as OldUpdhours, @TableFilter as TableFilter;
					exec db_maintenance.usp_reindex_updatestats 
						@db_name=@DBName, 
						@rowlimit=@rowlimit,
						@delayperiod=@delayperiod,
						@oldupdhours=3,
						@TableFilter=@TableFilter,
						@rowlimit_max=3000;
				END
				fetch next from INDEXs
				into @DBName, @UniqueName_SL, @RowLimit, @delayperiod, @filter_pages_min, @filter_pages_max, @filter_fragm_min, @filter_fragm_max,
					@filter_old_hours, @fragm_tresh, @set_fillfactor, @set_compression, @set_online, @set_sortintempdb, @PauseMirroring, @DeadLck_PR,
					@Lck_Timeout,@timeout_sec;
			end;
			CLOSE INDEXs;
			DEALLOCATE INDEXs;
		END
		else if @StartRecomputeStats=1
		BEGIN
		--Запуск пересчета статистик распределения теперь тоже осуществляется из этой процедуре
		--также как и запуск Реиндексации - на основании окна обслуживания!
			open ReStats
			fetch next from ReStats
				into @DBName, @UniqueName_SL, @RowLimit, @delayperiod, @filter_rows_min, @filter_rows_max, @filter_DataUsedMb_min, @filter_DataUsedMb_max,
				 @filter_perc_min, @filter_perc_max, @filter_old_hours, @policy_scan, @PauseMirroring, @DeadLck_PR, @Lck_Timeout,@timeout_sec;
			while @@FETCH_STATUS=0
			begin
				exec db_maintenance.usp_RecomputeStats
					@DBName=@DBName, 
					@UniqueName_SL=@UniqueName_SL,
					@RowLimit=@RowLimit,
					@delayperiod=@delayperiod,
					@filter_rows_min=@filter_rows_min,
					@filter_rows_max=@filter_rows_max,
					@filter_DataUsedMb_min=@filter_DataUsedMb_min,
					@filter_DataUsedMb_max=@filter_DataUsedMb_max,
					@filter_perc_min=@filter_perc_min,
					@filter_perc_max=@filter_perc_max,
					@filter_old_hours=@filter_old_hours,
					@policy_scan=@policy_scan,
					@PauseMirroring=@PauseMirroring,
					@DeadLck_PR=@DeadLck_PR,
					@Lck_Timeout=@Lck_Timeout,
					@only_show=@only_show,
					@timeout_sec=@timeout_sec;
		
				fetch next from ReStats
				into @DBName, @UniqueName_SL, @RowLimit, @delayperiod, @filter_rows_min, @filter_rows_max, @filter_DataUsedMb_min, @filter_DataUsedMb_max,
				 @filter_perc_min, @filter_perc_max, @filter_old_hours, @policy_scan, @PauseMirroring, @DeadLck_PR, @Lck_Timeout,@timeout_sec;
			end
			CLOSE ReStats;
			DEALLOCATE ReStats;
		END
	end
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating Procedure [db_maintenance].[usp_FreeProcCache]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO

/* =============================================
-- Author:		Андрей Иванов (sqland1c)
-- Create date: 28.02.2014 (1.0)
-- Description: Процедура для выполнения очистки процедурного Кэша.
				Выполняется на основании настроек, заданных в таблице db_maintenance_FreeProcCache
-- Update:		25.03.2014 (1.05)
				Добавлен параметр Force - если задан 1, то принудительно будет запущен FREEPROCCACHE.
					По умолчанию 0.
-- ============================================= */
CREATE PROCEDURE db_maintenance.usp_FreeProcCache 
	@Force bit = 0
AS
BEGIN
	declare @WeekDay tinyint, @getdate datetime2(2), @PeriodHours tinyint, @LastRunDate datetime2(2);
	set nocount on;
	set @getdate=GETDATE();
	select @WeekDay=sputnik.info.uf_GetWeekDay(@getdate);

	select top 1 
		@PeriodHours=[PeriodHours], 
		@LastRunDate=[LastRunDate]
	from 
		[sputnik].[db_maintenance].[FreeProcCache]
	where 
		(WeekDay is null or WeekDay=@WeekDay)
	
	if (@LastRunDate is null) or (datediff(hour,@LastRunDate,@getdate)>=@PeriodHours) or (@Force=1)
	begin
		DBCC FREEPROCCACHE;
		update [sputnik].[db_maintenance].[FreeProcCache]
		set [LastRunDate]=@getdate;
	end
END
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating Procedure [db_maintenance].[usp_ShrinkLogFile]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 29.11.2013 (1.0)
	-- Description: Процедура для обслуживания БД! Для указанной в параметре @db_name 
					базы данных производит shrinkfile и изменяет настройки 
					(размер файла, автоприращение).
					Необязательные параметры @SetSizeMb - до какого размера сжимать в Мб
					и  @FileGrowthMb - установка приращений в Мб.
					Параметр @truncate - позволяет выполнить зачистку транзакций в Log и сжать файл до нужного размера.
					По умолчанию выключен!
	-- Update:	
					17.03.2014 (1.1)
					Изменены значения по умолчанию для Приращения. А также максимальный размер @SetSizeMb установлен в 23 Гб.
					25.04.2014 (1.12)
					Ещё раз оптимизированы значения по умолчанию для всех параметров
						@FileGrowthMb=64 (минимум 4Гб), @SetSizeMb - максимум 10Гб. 
					15.04.2014 (1.14)
					Изменены значения по умолчанию: 512 Мб для @FileGrowthMb (шаг приращения) и 3072 Мб для @SetSizeMb (начальный размер).
					18.03.2016 (1.20)
					Новые алгоритмы определения конечного размера и размера приращения!
					Также переопределены значения по умолчанию!
					Также теперь выполняется CHECKPOINT перед сжатием!
					Также теперь сжатие и установка приращения выполняются в отдельных пакетах
					и только в том случае, если устанавливаемый размер файла журнала транзакций
					меньше чем текущий размер. Приращение устанавливается только если новое значение
					отличается от текущего.
	-- ============================================= */
	CREATE PROCEDURE db_maintenance.usp_ShrinkLogFile
		@db_name nvarchar(50) = null,
		@SetSizeMb int = null,
		@FileGrowthMb int = null,
		@truncate bit=null
	AS
	BEGIN
		SET NOCOUNT ON;
		IF @db_name is not null
		begin
			declare @name varchar(128), @size int, @max_size int, @growth int, @is_percent_growth bit, @tsql nvarchar(500), @RecoveryModel varchar(11);
			declare @set_min_size int;
			select 
				@RecoveryModel=recovery_model_desc 
			from sys.databases where name=@db_name

			declare CUR_LogFiles CURSOR
			FOR		select name, size/128, max_size, growth, is_percent_growth
					from sys.master_files
					where database_id=DB_ID(@db_name) and type=1 and state=0; --type=1 (LOG) и state=0 (ONLINE)
			open CUR_LogFiles
			fetch next from CUR_LogFiles
				into @name,@size,@max_size,@growth,@is_percent_growth
		
			while @@FETCH_STATUS=0
			begin
				if @SetSizeMb is null or @SetSizeMb<=0  --Если размер не задан, или задан неверно!
					set @SetSizeMb=	@size/4 --Устанавливаем 25% от текущего размера файла.
			
				--Определяем минимальный размер = 4% от текущего размера файла.
				--НО не меньше чем 32 Мб!
				select @set_min_size=
					CASE 
						WHEN @size/25>32 THEN @size/25
						ELSE 32	
					END;
				if @SetSizeMb < @set_min_size	--Устанавливаем минимально-возможный размер	
					set @SetSizeMb=	@set_min_size 

				if @SetSizeMb > 19*1024 ---Определяем максимальный размер	
					set @SetSizeMb=19*1024 --установить размер 19 Гб!
			
				/*
					--Старый алгоритм определения авто-приращения @FileGrowthMb
					if @FileGrowthMb is null or @FileGrowthMb<=0 
						set @FileGrowthMb=64--АвтоПриращение установить в размере 64 (по умолчанию).
					else if  @FileGrowthMb>1024
						set @FileGrowthMb=1024--АвтоПриращение установить в размере 1024 (максимум).
					else if @FileGrowthMb<8 --Если приращение меньше 8 Мб.
						set @FileGrowthMb=8 --установить минимальное приращение в 8 Мб (Минимум).
				*/

				--	Новый алгоритм определения авто-приращения @FileGrowthMb
				if @FileGrowthMb is null or @FileGrowthMb<=0 
				begin
					--Определяем АвтоПриращение по умолчанию.
					select @FileGrowthMb=
						CASE 
							--WHEN @db_name = 'tempdb' THEN 1024
							WHEN @size <= 128 THEN 32
							WHEN @size <= 512 THEN 128
							WHEN @size <= 2048 THEN 256
							WHEN @size <= 8192 THEN 512
							WHEN @size <= 16384 THEN 1024
							WHEN @size <= 32768 THEN 2048
							ELSE 3072
						END	
				end
				else if  @FileGrowthMb>3072
					set @FileGrowthMb=3072--Максимальное АвтоПриращение установить в размере 3 Гб.
				else if @FileGrowthMb<32 
					set @FileGrowthMb=32 --Минимальное АвтоПриращение установить в размере 32 Мб.

				if @truncate=1 and @RecoveryModel<>'SIMPLE'
				begin
					set @tsql='use [master]
					ALTER DATABASE ['+@db_name+'] SET RECOVERY SIMPLE WITH NO_WAIT'
					exec(@tsql);
				end
			
				if @SetSizeMb<@size
				begin
					set @tsql='use ['+@db_name+'];
					CHECKPOINT;
					WAITFOR DELAY ''00:00:02'';'
					exec(@tsql);

					set @tsql='use ['+@db_name+'];
					DBCC SHRINKFILE (N'''+@name+''' , '+cast(@SetSizeMb as varchar(25))+');';
					exec(@tsql);

					if (@FileGrowthMb<>@growth or @is_percent_growth=1)
					begin
						set @tsql='use [master];
						ALTER DATABASE ['+@db_name+'] MODIFY FILE ( NAME = N'''+@name+''', FILEGROWTH = '+cast(@FileGrowthMb as varchar(25))+'MB)';
						exec(@tsql);
					end
				end
						
				if @truncate=1 and @RecoveryModel<>'SIMPLE'
				begin
					set @tsql='use [master]
					ALTER DATABASE ['+@db_name+'] SET RECOVERY '+@RecoveryModel+' WITH NO_WAIT'
					exec(@tsql);
				end

				fetch next from CUR_LogFiles
					into @name,@size,@max_size,@growth,@is_percent_growth
			end
		CLOSE CUR_LogFiles;
		DEALLOCATE CUR_LogFiles;
		end
	END
GO
PRINT N'Creating Procedure [db_maintenance].[usp_ShrinkDB]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 10.12.2013 (1.0)
	-- Description: Процедура для обслуживания БД! Для указанной в параметре @db_name 
					базы данных производит shrinkfile и изменяет настройки 
					(автоприращение).
					Необязательные параметры @SetSizeMb - до какого размера сжимать в Мб (по умолчанию 1 Гб)
					и  @FileGrowthMb - установка приращений в Мб, если не указан, то изменение настроек не производится.
					Необязательный параметр @Disk- позволяет обработать файлы только на указанном диске (если не задан, то все файлы)!
	-- Update:		17.12.2013 (1.1) - Изменён алгоритм сжатия. Теперь блок try...catch включен в команду, передаваемую в exec.
										А также если произошла ошибка при сжатии, в исключении происходит запись ошибки в журнал SQL Server.
										Теперь в первую очередь будут обработаны файлы с большим размером!
					17.12.2013 (1.2) - Изменён алгоритм отбора файлов. Теперь размеры файлов берутся из системной функции dm_io_virtual_file_stats
									   которая возвращает реальный размер файлов.
					25.04.2014 (1.3) - Добавлен параметр @SetMaxSizeGB - теперь можно установить Limit для файлов в Гб. По умолчанию не используется.
										Также задержка между обработкой файлов снижена до 1 сек (вместо 3).	
					28.04.2014 (1.31) - Добавлена сортировка файлов в случайном порядке!
					30.04.2014 (1.35) - Исправлена критическая ошибка во второй части процедуры. А также добавлен алгоритм получения файлов с большим
										количеством свободных экстентов - только для БД TempDB.
					09.06.2014 (1.4)  - Новый параметр и новый алгоритм. Параметр @AutoShrink (по умолчанию 0), задаёт автоматическое определение нужного
										размера для каждого Файла в базе данных! В случае если этот параметр задан, то параметр @SetSizeMb не используется!
					19.02.2015 (1.41) - Изменил параметры местами. Параметр @AutoShrink поставлен самым последним. 
										Добавлен вывод обработки текущего файла.
					01.03.2016 (1.42) - Добавлен новый параметр @truncateonly - если задан, то при сжатии файлов используется опция TRUNCATEONLY - 
										освобождает все свободное место в КОНЦЕ файла, не перемещает страницы данных внутри файла.
										Аргумент target_size не обрабатывается - параметры @SetSizeMb и @AutoShrink обнуляются!
	-- ============================================= */
	CREATE PROCEDURE [db_maintenance].[usp_ShrinkDB]
		@db_name nvarchar(50),
		@SetSizeMb int = 1024,
		@FileGrowthMb int = null,
		@Disk char(1) = null,
		@SetMaxSizeGB int = NULL,
		@AutoShrink BIT = 0,
		@truncateonly BIT = 0
	AS
	BEGIN
		SET NOCOUNT ON;
		IF @truncateonly=1
		BEGIN
			SET @SetSizeMb=0;
			SET @AutoShrink=0;
		END
		IF @AutoShrink=1
		BEGIN
			CREATE TABLE #FSizeUsed
			(
	
				FName NVARCHAR(100),
				UsedSpaceMB INT
			)
			DECLARE @db NVARCHAR(300), @Str NVARCHAR(1000);
			SELECT @db=name
			FROM sys.databases
			WHERE state_desc='ONLINE'
				AND name=@db_name;
			SELECT @Str=N'USE ['+@db+N']
				INSERT INTO #FSizeUsed
				SELECT 
					name as FName,
					CAST(ROUND(FILEPROPERTY(name, ''SpaceUsed'')/128.00 + 0.5, 0) as INT) AS UsedSpaceMB
				FROM sys.database_files';
			EXEC sp_executesql @Str;
		END

		declare @tstr nvarchar(500), @name nvarchar(30), @tstrMaxSize NVARCHAR(100)='';
		DECLARE @T TABLE (File_ID INT);
		IF @db_name = 'TempDB'
		BEGIN
			--Отдельно для БД TempDB: проверяем количество свободных экстентов в файлах данных.
			INSERT INTO @T
				SELECT file_id
				FROM TempDB.SYS.dm_db_file_space_usage
				WHERE unallocated_extent_page_count > (user_object_reserved_page_count + internal_object_reserved_page_count + version_store_reserved_page_count + mixed_extent_page_count) * 10
		END
		declare tc cursor for
		select 
			mf.Name
		from 
			(
			select database_id, file_id, name, type_desc
			from sys.master_files
			where
				database_id=DB_ID(@db_name) 
				and (@Disk is null or LEFT(physical_name,1)=@Disk) --Зачистка файлов только на указанном диске!
			)mf
		left join sys.dm_io_virtual_file_stats(DEFAULT, DEFAULT) fs			--Отсюда получим реальные размеры файлов БД.
			on mf.database_id = fs.database_id and mf.file_id = fs.file_id
		where
			fs.size_on_disk_bytes / (1024.0*1024.0) > @SetSizeMb	--отбирать только файлы Более @SetSizeMb.
			AND ((@db_name='TempDB' AND mf.type_desc='ROWS' AND mf.file_id IN (SELECT File_ID FROM @T)) OR (@db_name<>'TempDB') OR (mf.type_desc<>'ROWS'))
		order by newid()	--сортировка в случайном порядке!!

		open tc
		fetch next from tc into @name
		while @@FETCH_STATUS = 0 
		begin
			--Сжать все файлы до @SetSizeMb.
			--Если возникла ошибка при работе с текущим файлом - Записать имя файла в ЖУрнал !
		
			IF @AutoShrink=1
				SELECT @SetSizeMb=UsedSpaceMB
				FROM #FSizeUsed
				WHERE FName=@name;

			set @tstr = 'use ['+@db_name+'];
			declare @terror nvarchar(500);
			BEGIN TRY
				PRINT(''Сжатие файла ['+@name+'] в БД ['+@db_name+']'');
				DBCC SHRINKFILE (N''' + @name + ''', '+CASE WHEN @truncateonly = 0 THEN cast(@SetSizeMb as varchar(25)) ELSE ' TRUNCATEONLY ' END+') --Сжатие файлов БД из ХП [db_maintenance].[usp_ShrinkDB]
			END TRY
			BEGIN CATCH
				set @terror=N''Ошибка при сжатии файла ' + @name+ N' базы данных ' + @db_name + N' . Причина : ''+error_message();
				RAISERROR(@terror ,11,1) WITH LOG;
			END CATCH';
			--print @tstr
			exec( @tstr );
			fetch next from tc into @name
			waitfor delay '00:00:01'	--Если всё ОК. то задержка 1 сек перед след. файлом.
		end
		close tc
		deallocate tc

		if @FileGrowthMb is not null
		begin
			--Во второй части запроса происходит принудительная настройка всех файлов в БД TempDB - приращение файла установить в @FileGrowthMb.
			declare tc cursor for
			select name
			from sys.master_files
			where
				database_id=DB_ID(@db_name) 
				and (growth*8)/1024 <> @FileGrowthMb  --Установленное приращение файла не равно FileGrowthMb
				and (@Disk is null or LEFT(physical_name,1)=@Disk) --Зачистка файлов только на указанном диске!
			order by physical_name

			open tc

			fetch next from tc into @name
			while @@FETCH_STATUS = 0 
			begin
				IF @SetMaxSizeGB IS NOT NULL
					SET @tstrMaxSize=N', MAXSIZE = '+CAST(@SetMaxSizeGB AS NVARCHAR(25))+'GB ';
				set @tstr='ALTER DATABASE ['+@db_name+'] MODIFY FILE ( NAME = '''+@name+''', FILEGROWTH = '+cast(@FileGrowthMb as nvarchar(25))+'MB '+@tstrMaxSize+')';
				--print @tstr;
				EXEC( @tstr )
				fetch next from tc into @name
			end
			close tc
			deallocate tc
		end

	END
GO
PRINT N'Creating Procedure [info].[usp_GetSqlLog]...';


GO

/* =============================================
-- Author:		Андрей Иванов (sqland1c)
-- Create date: 15.03.2015
-- Description:	Эта процедура возвращает информацию из журналов SQL Server.
				Имеется множество входных параметров для применения различных отборов (фильтров).
				Обязательных параметров нет!
				@Filter1 и @Filter2 - основные фильтры для отбора по тексту события!
				@FilterOR - если задан, тогда фильтры @Filter1 и @Filter2 применяются как OR (ИЛИ), иначе AND (И).
				@FilterNotLike - дополнительный фильтр используется для отсечения ненужных значений (можно использовать %).
				@DateStart и @DateEnd - фильтры для отбора событий по датам (можно задавать как вместе так и по отдельности).
				@DateLastNHours - ещё один фильтр по дате (отбирает события за последние @DateLastNHours часов).
				@TOP - ограничение результирующиего набора по кол-ву строк (по умолчанию 4000).
				Для получения подобной информации используется системные расширенные процедуры.
-- Update:		20.03.2015 (1.05)
				Добавлены новые параметры @FilterSource и @FilterSourceNotLike и возможность фильтрация 
				по Источнику (столбец ProccessInfo). Также внесены исправления в код (устранение небольших ошибок).
				25.03.2015 (1.10)
				В результирующий запрос добавлена оконная функция ROW_NUMBER чтобы пронумеровать одинаковые строки (если время события и источник одинаковы).
				Причем уникальность по времени события в пределах 1 секунды (без учета милисек, как и в 1С).
				Необходимо, чтобы можно было нормально загружать в Хьюстон!
				Также добавлен параметр @WithRowNum, если он задан то ROW_NUMBER будет выведен. Если не задан, тогда запрос будет работать быстрее и без ROW_NUMBER.
				19.01.2016 (1.15)
				Добавлены новые параметры: @tt_tz_min - определяет часовой пояс в минутах, для компьютера откуда запущен запрос (например, сервер программы Хьюстон).
				@Convert_tz_InFilters - при отборах по датам @DateStart и @DateEnd  будет происходит конвертация часового пояса в местное время (с учетом заданного параметра @tt_tz_min).
				@Convert_tz_InResults - в результатах, при выводе даты события LogDate, будет происходит конвертация часового пояса из местного в заданный в параметре @tt_tz_min .
				19.10.2017 (1.200)
				Добавлен новый параметр: @GroupByText - группировать события по Тексту.
				Также табл.переменная заменена на временную таблицу #TLog.
				Также столбец ServerName теперь определяется по новому: учитывается имя сервера + имя экземпляра (отдельно).
				13.03.2018 (1.202)
				Для определения правильного имени сервера SQL теперь используется процедура info.usp_getHostname	
				31.01.2019 (1.250)
				Добавлен новый параметр @SortAZ-направление сортировки в результате.
				Также переделан алгоритм получения результата: вместо нескольких запросов сделан один динамический код sql.
-- ============================================= */
CREATE PROCEDURE info.usp_GetSqlLog
	@Filter1 NVARCHAR(200) = NULL,
	@Filter2 NVARCHAR(200) = NULL,
	@FilterOR BIT = 0,
	@FilterNotLike NVARCHAR(200) = NULL,
	@FilterSource NVARCHAR(75) = NULL,
	@FilterSourceNotLike NVARCHAR(75) = NULL,
	@DateStart DATETIME2(0) = NULL,
	@DateEnd DATETIME2(0) = NULL,
	@DateLastNHours SMALLINT = 6,
	@TOP INT = 4000,
	@WithRowNum BIT=0,
	@tt_tz_min SMALLINT = NULL,
	@Convert_tz_InFilters BIT=1,
	@Convert_tz_InResults BIT=1,
	@GroupByText BIT=0,
	@SortAZ NVARCHAR(10) = 'DESC'
AS
BEGIN
	SET NOCOUNT ON;
	SET DATEFORMAT YMD;
	DECLARE @GD DATETIME2(0)=SYSDATETIME(), @Num TINYINT;
	declare @SQLServer nvarchar(510);
	declare @cmd nvarchar(max);
	exec sputnik.info.usp_GetHostname @Servername=@SQLServer OUT;

	IF @DateStart IS NULL AND @DateEnd IS NULL
	BEGIN
		SET @DateEnd=@GD;
		SET @DateStart=DATEADD(HOUR,-@DateLastNHours,@GD);
	END
	ELSE
	BEGIN
		IF @Convert_tz_InFilters=1
		BEGIN
			SET @DateEnd=COALESCE(DATEADD(minute,datepart(TZoffset,SYSDATETIMEOFFSET())-@tt_tz_min,@DateEnd),@GD);
			SET @DateStart=COALESCE(DATEADD(minute,datepart(TZoffset,SYSDATETIMEOFFSET())-@tt_tz_min,@DateStart),CAST('1900-01-01' AS DATETIME2(0)));
		END 				
		ELSE
		BEGIN
			SET @DateEnd=COALESCE(@DateEnd,@GD);
			SET @DateStart=COALESCE(@DateStart,CAST('1900-01-01' AS DATETIME2(0)));	
		END
	END
	DECLARE @TLogNum TABLE ([Archive #] TINYINT, [Date] DATETIME2(0), [Log File Size (Byte)] bigint);
	INSERT INTO @TLogNum EXEC sys.xp_enumerrorlogs;
	DECLARE N CURSOR FOR
	SELECT [Archive #] as Num
	FROM @TLogNum
	WHERE [Date]>=(SELECT COALESCE(MAX([Date]),@DateStart) FROM @TLogNum WHERE [Date]<=@DateStart)
		AND [Date]<=(SELECT COALESCE(MIN([Date]),@DateEnd) FROM @TLogNum WHERE [Date]>=@DateEnd);
	OPEN N;
	FETCH NEXT FROM N INTO @Num;
	IF OBJECT_ID('tempdb.dbo.#TLog') IS NOT NULL
		DROP TABLE #TLog;
	CREATE TABLE #TLog (LogDate DATETIME, ProccessInfo VARCHAR(50),[Text] NVARCHAR(4000));
	WHILE @@FETCH_STATUS=0
	BEGIN
		IF @FilterOR=0
			INSERT INTO #TLog
			EXEC master.dbo.xp_readerrorlog @Num, 1, @Filter1, @Filter2, @DateStart, @DateEnd;
		ELSE
		BEGIN
			INSERT INTO #TLog
			EXEC master.dbo.xp_readerrorlog @Num, 1, @Filter1, null, @DateStart, @DateEnd;
			INSERT INTO #TLog
			EXEC master.dbo.xp_readerrorlog @Num, 1, @Filter2, null, @DateStart, @DateEnd;		
		END	
		FETCH NEXT FROM N INTO @Num;
	END
	CLOSE N;
	DEALLOCATE N;
	
	SET @cmd = '
	SELECT TOP ('+cast(@TOP as varchar(20))+') 
		'''+@SQLServer+''' AS ServerName, 
		'+CASE 
				
			WHEN (@GroupByText=0 OR @GroupByText IS NULL) AND @Convert_tz_InResults=1 THEN 'ISNULL(DATEADD(minute,'+cast(@tt_tz_min as varchar(20))+'-datepart(TZoffset,SYSDATETIMEOFFSET()),LogDate),LogDate)'
			WHEN (@GroupByText=0 OR @GroupByText IS NULL) AND @Convert_tz_InResults<>1 THEN 'LogDate'
			WHEN (@GroupByText<>0 AND @GroupByText IS NOT NULL) AND @Convert_tz_InResults=1 THEN 'max(ISNULL(DATEADD(minute,'+cast(@tt_tz_min as varchar(20))+'-datepart(TZoffset,SYSDATETIMEOFFSET()),LogDate),LogDate)) over (partition by [Text])'
			WHEN (@GroupByText<>0 AND @GroupByText IS NOT NULL) AND @Convert_tz_InResults<>1 THEN 'Max(LogDate) over (partition by [Text])'
		END +' AS LogDate,
		'+CASE 
				
			WHEN (@GroupByText=0 OR @GroupByText IS NULL) AND @Convert_tz_InResults=1 THEN 'CONVERT(VARCHAR(23),ISNULL(DATEADD(minute,'+cast(@tt_tz_min as varchar(20))+'-datepart(TZoffset,SYSDATETIMEOFFSET()),LogDate),LogDate),121)'
			WHEN (@GroupByText=0 OR @GroupByText IS NULL) AND @Convert_tz_InResults<>1 THEN 'CONVERT(VARCHAR(23),LogDate,121)'
			WHEN (@GroupByText<>0 AND @GroupByText IS NOT NULL) AND @Convert_tz_InResults=1 THEN 'CONVERT(VARCHAR(23),max(ISNULL(DATEADD(minute,'+cast(@tt_tz_min as varchar(20))+'-datepart(TZoffset,SYSDATETIMEOFFSET()),LogDate),LogDate)) over (partition by [Text]),121)'
			WHEN (@GroupByText<>0 AND @GroupByText IS NOT NULL) AND @Convert_tz_InResults<>1 THEN 'CONVERT(VARCHAR(23),Max(LogDate) over (partition by [Text]),121)'
		END +' AS LogDate_str,
		'+CASE 
			WHEN (@GroupByText=0 OR @GroupByText IS NULL) THEN 'ProccessInfo,'
			ELSE 'COUNT(*) over (partition by [Text]) as ProccessInfo,'
		END+' 
		'+case
			when @WithRowNum=1 and (@GroupByText=0 OR @GroupByText IS NULL) then 'ROW_NUMBER() OVER (PARTITION BY CONVERT(VARCHAR(19),LogDate,121),ProccessInfo ORDER BY LogDate DESC) AS RowNum' 
			else 'NULL AS RowNum' 
		end+', 
		[Text]
	FROM #TLog
	WHERE 1=1
		'+CASE WHEN @FilterNotLike IS NULL THEN '' ELSE 'AND [Text] NOT LIKE '''+@FilterNotLike+'''' END+'
		'+CASE WHEN @FilterSource IS NULL THEN '' ELSE 'AND [ProccessInfo] LIKE '''+@FilterSource+'''' END+'
		'+CASE WHEN @FilterSourceNotLike IS NULL THEN '' ELSE 'AND [ProccessInfo] NOT LIKE '''+@FilterSourceNotLike+'''' END+' 
	ORDER BY LogDate '+@SortAZ+';';	
	--PRINT (@cmd);
	EXEC (@cmd);
END
GO
PRINT N'Creating Procedure [info].[usp_GetDrives2]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 03.08.2016 (1.0)
	-- Description:	Новая процедура, возвращает информацию о локальных дисках и свободном месте в Гб на Них в виде Таблицы!
					В отличии от первой версии (info.usp_GetDrives) эта процедура возвращает наиболее
					полную информацию (метка диска, весь объем диска).
	-- Update:		07.11.2016 (1.050)
					Добавлен новый параметр @DiskFilter - отбор по букве диска (необязательный).
	-- ============================================= */
	CREATE PROCEDURE info.usp_GetDrives2 
		@Details bit=1,
		@DiskFilter varchar(1)=NULL
	AS
	BEGIN
		set nocount ON;
		declare @sql varchar(400);
		declare @DiskFilter_ps varchar(300)='';
		IF @DiskFilter IS NOT NULL 
			set @DiskFilter_ps=' WHERE {$_.Name -eq '''+@DiskFilter+':\''} |';
		--declare @svrName varchar(255)
		--По умолчанию выводим информацию для текущего Компьютера. НО также можно указать другой компьютер в параметре -ComputerName
		--set @svrName = CAST(SERVERPROPERTY('MachineName') as varchar(255));
		--set @sql = 'powershell.exe -c "Get-WmiObject -ComputerName ' + QUOTENAME(@svrName,'''') + ' -Class Win32_Volume -Filter ''DriveType = 3'' | select name,capacity,freespace,label | foreach{$_.name+''|''+$_.capacity/1048576+''%''+$_.freespace/1048576+''*''+$_.label+''@''}"'

		/*--ТипДиска:
				Value	Meaning
				0 (0x0) Unknown
				1 (0x1)	No Root Directory
				2 (0x2)	Removable Disk
				3 (0x3)	Local Disk
				4 (0x4)	Network Drive
				5 (0x5)	Compact Disk
				6 (0x6)	RAM Disk
		*/
			set @sql = 'powershell.exe -c "Get-WmiObject -Class Win32_Volume |'+@DiskFilter_ps+' select name,capacity,freespace,label,FileSystem,DriveType | foreach{$_.name+''|''+$_.capacity/1048576+''%''+$_.freespace/1048576+''*''+$_.label+''@''+$_.FileSystem+''#''+$_.DriveType+''!''}"';
			if object_id('tempdb.dbo.#output') is not null
				drop table #output;
			CREATE TABLE #output
			(line varchar(255))
			insert #output
			EXEC xp_cmdshell @sql
			--select * from #output
			----script to retrieve the values in MB from PS Script output
			--select rtrim(ltrim(SUBSTRING(line,1,CHARINDEX('|',line) -1))) as drivename
			--      ,round(cast(rtrim(ltrim(SUBSTRING(line,CHARINDEX('|',line)+1,
			--      (CHARINDEX('%',line) -1)-CHARINDEX('|',line)) )) as Float),0) as 'capacity(MB)'
			--      ,round(cast(rtrim(ltrim(SUBSTRING(line,CHARINDEX('%',line)+1,
			--      (CHARINDEX('*',line) -1)-CHARINDEX('%',line)) )) as Float),0) as 'freespace(MB)'
			--from #output
			--where line like '[A-Z][:]%'
			--order by drivename
			--script to retrieve the values in GB from PS Script output
			IF @Details=1 
				select rtrim(ltrim(SUBSTRING(line,1,CHARINDEX('|',line) -1))) as Drive
					  ,
					  CASE rtrim(ltrim(SUBSTRING(line,CHARINDEX('#',line)+1,(CHARINDEX('!',line) -1)-CHARINDEX('#',line))))
						WHEN 0 THEN 'Unknown' 
						WHEN 1 THEN 'No_Root_Directory' 
						WHEN 2 THEN 'Removable' 
						WHEN 3 THEN 'Fixed'
						WHEN 4 THEN 'Network'
						WHEN 5 THEN 'CD-ROM'
						WHEN 6 THEN 'RAM_Disk'
					  END as DriveType		
					  ,rtrim(ltrim(SUBSTRING(line,CHARINDEX('*',line)+1,(CHARINDEX('@',line) -1)-CHARINDEX('*',line)))) as Label
					  ,rtrim(ltrim(SUBSTRING(line,CHARINDEX('@',line)+1,(CHARINDEX('#',line) -1)-CHARINDEX('@',line)))) as FileSystem
					  ,round(cast(rtrim(ltrim(SUBSTRING(line,CHARINDEX('|',line)+1,
					  (CHARINDEX('%',line) -1)-CHARINDEX('|',line)) )) as Float)/1024,0) as 'GB_Capacity'
					  ,round(cast(rtrim(ltrim(SUBSTRING(line,CHARINDEX('%',line)+1,
					  (CHARINDEX('*',line) -1)-CHARINDEX('%',line)) )) as Float) /1024 ,0)as 'GB_Free'
				from #output
				where line like '[A-Z][:]%'
				order by Drive
			ELSE
				select LEFT(rtrim(ltrim(SUBSTRING(line,1,CHARINDEX('|',line) -1))),1) as Drive
					  ,round(cast(rtrim(ltrim(SUBSTRING(line,CHARINDEX('|',line)+1,
					  (CHARINDEX('%',line) -1)-CHARINDEX('|',line)) )) as Float)/1024,0) as 'GB_Capacity'
					  ,round(cast(rtrim(ltrim(SUBSTRING(line,CHARINDEX('%',line)+1,
					  (CHARINDEX('*',line) -1)-CHARINDEX('%',line)) )) as Float) /1024 ,0)as 'GB_Free'
				from #output
				where line like '[A-Z][:]%'
					AND rtrim(ltrim(SUBSTRING(line,CHARINDEX('#',line)+1,(CHARINDEX('!',line) -1)-CHARINDEX('#',line))))=3
				order by Drive			
			if object_id('tempdb.dbo.#output') is not null
				drop table #output;
	END
GO
PRINT N'Creating Procedure [info].[usp_tempusing_total]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 09.04.2018
	-- Description:	Эта процедура возвращает данные из представления v_tempusing. Процедура создана для zabbix!

	-- Update:		
	-- ============================================= */
	CREATE PROC [info].[usp_tempusing_total] 
	AS
	BEGIN
		set nocount on;
		select [vl] from sputnik.info.vtempusing where pr='total_mb';
	END
GO
PRINT N'Creating Procedure [info].[usp_tempusing_user]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 09.04.2018
	-- Description:	Эта процедура возвращает данные из представления v_tempusing. Процедура создана для zabbix!

	-- Update:		
	-- ============================================= */
	CREATE PROC [info].[usp_tempusing_user] 
	AS
	BEGIN
		set nocount on;
		select [vl] from sputnik.info.vtempusing where pr='user_mb';
	END
GO
PRINT N'Creating Procedure [info].[usp_tempusing_internal]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 09.04.2018
	-- Description:	Эта процедура возвращает данные из представления v_tempusing. Процедура создана для zabbix!

	-- Update:		
	-- ============================================= */
	CREATE PROC [info].[usp_tempusing_internal] 
	AS
	BEGIN
		set nocount on;
		select [vl] from sputnik.info.vtempusing where pr='internal_mb';
	END
GO
PRINT N'Creating Procedure [info].[usp_tempusing_rowver]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 09.04.2018
	-- Description:	Эта процедура возвращает данные из представления v_tempusing. Процедура создана для zabbix!

	-- Update:		
	-- ============================================= */
	CREATE PROC [info].[usp_tempusing_rowver] 
	AS
	BEGIN
		set nocount on;
		select [vl] from sputnik.info.vtempusing where pr='rowver_mb';
	END
GO
PRINT N'Creating Procedure [info].[usp_SQLMon]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 03.08.2015
	-- Description:	Процедура для мониторинга выполняющихся запросов. 
					Выводит информацию о тяжелых запросах за последнюю минуты (интервал можно изменить в параметре @interval_sec)!
					Если @interval_sec=0, то берется самый последний снимок данных.
					Вся информация берётся из схемы awr базы sputnik, а не из dmv!
					Можно задать фильтры по REads, Duration и Text запросов.
					Параметр zabbix если включен, то выводит кол-во проблемных запросов за последнюю минуту.
					Также есть параметр @Kill если включен, то проблемные запросы будут удалены 
					(а на вкладке Messages выводится команда KILL для каждого запроса).
	-- Update:		17.09.2015 (1.02)
					Новый параметр @get_runtime_metr для замера длительности выполнения запросов в разрезах max, all, top5, avg.
					27.01.2016 (1.03)
					Добавлено исключение - трассировка OLAP событий.
					10.03.2016 (1.04)
					Оптимизация - вместо одного запроса со сложным условием, сделано два отдельных.
					Условие IF @interval_sec=0 - тогда используется точный поиск (tt=@last_tt)
					по индексу - гораздо меньше чтений! 
	-- ============================================= */
	CREATE PROCEDURE info.usp_SQLMon
		@Filter_Reads INT = 100000,
		@Filter_DurSec INT = 30,
		@Filter_Text NVARCHAR(500) = NULL,
		@interval_sec SMALLINT = 60,
		@zabbix BIT = 0,
		@kill BIT = 0,
		@get_runtime_metr BIT = 0
	AS
	BEGIN
		SET DATEFORMAT YMD;
		SET DATEFIRST 1;
		SET TRAN ISOLATION LEVEL READ UNCOMMITTED;
		SET NOCOUNT ON;
		declare @last_tt datetime;
		select @last_tt = max(tt) from awr.sql_handle_collect;
		IF datediff(second,@last_tt, getdate())<=60
		BEGIN
			--IF OBJECT_ID('tempdb.dbo.#last_tt') IS NOT NULL
			--	DROP TABLE #last_tt;
			CREATE TABLE #last_tt (tt datetime, spid smallint, start_time datetime);
			IF @interval_sec=0
				insert into #last_tt
				select distinct max(tt) over (partition by spid, start_time) as tt, spid, start_time			 
				from awr.sql_handle_collect
				where
					(tt=@last_tt)
					AND ([status] <> 'sleeping' OR @get_runtime_metr=1) --AND [status] IN ('running', 'runnable')
					AND (Logical_Reads+IO_Reads>@Filter_Reads OR @Filter_Reads=0)
					AND (DATEDIFF(second,start_time,tt)>@Filter_DurSec OR @Filter_DurSec=0)
			ELSE
				insert into #last_tt
				select distinct max(tt) over (partition by spid, start_time) as tt, spid, start_time			 
				from awr.sql_handle_collect
				where
					(tt between DATEADD(SECOND,-@interval_sec,@last_tt) AND @last_tt)
					AND ([status] <> 'sleeping' OR @get_runtime_metr=1) --AND [status] IN ('running', 'runnable')
					AND (Logical_Reads+IO_Reads>@Filter_Reads OR @Filter_Reads=0)
					AND (DATEDIFF(second,start_time,tt)>@Filter_DurSec OR @Filter_DurSec=0)
			IF @get_runtime_metr=1
			BEGIN
				--IF OBJECT_ID('tempdb.dbo.#t01') IS NOT NULL
				--	DROP TABLE #t01;
				select h.tt, ROUND(datediff(second,h.start_time,h.tt)/60.00,2) as RunTime_min
				into #t01
				from #last_tt as last_tt
				inner join awr.sql_handle_collect h
					on last_tt.tt=h.tt AND last_tt.SPID=h.SPID AND last_tt.start_time=h.start_time;
				;with cte_src AS (
					select
						tt, 
						cast(max(RunTime_min) over () as numeric(19,2)) as _max_min,
						cast(sum(RunTime_min) over () as numeric(19,2)) as _all_min,
						cast(avg(RunTime_min) over () as numeric(19,2)) as _avg_min,
						RunTime_min,
						row_number() over (order by RunTime_min desc) as rn
					from #t01	
				),
				cte_results_1 as (
					select distinct
						tt, _max_min as _Max, _avg_min as _Avg, _all_min as _All,
						cast(sum(RunTime_min) over () as numeric(19,2)) as _Top5 
					from cte_src
					where rn<=5
				)
				select tt, 'Run_time_query_min' as counter_name, instance_name, value
				from cte_results_1
				unpivot(value for instance_name in ([_Max],[_Avg],[_All],[_Top5])
				)unpvt
				order by counter_name,instance_name
				;
			END
			ELSE
			BEGIN
				select h.tt, h.SPID, h.Host, h.Program, h.Login, h.login_time, h.status, h.start_time, h.RunTime_sec, h.DB,
					h.wait_resource, h.wait_type, h.wait_time, h.Blk_By,	h.CPU_sec, h.Logical_Reads,h.IO_Reads, h.IO_Writes,
						REPLACE(REPLACE(REPLACE(	
							CASE WHEN [statement_start] > 0 THEN 
								CASE [statement_end] 
									WHEN -1 THEN SUBSTRING([SQLTEXT], ([statement_start]/2) + 1, 2147483647)
									ELSE SUBSTRING([SQLTEXT], ([statement_start]/2) + 1, ([statement_end] - [statement_start])/2)  
								END 
								ELSE CASE [statement_end] 
										WHEN -1 THEN RTRIM(LTRIM([SQLTEXT])) 
										ELSE LEFT([SQLTEXT], ([statement_end]/2) +1) 
								END 
							END
						,char(10),' '),char(9), ' '),char(13),' ')
						AS [Exec_Statement]
				INTO #t1
				FROM #last_tt as last_tt
				inner join awr.sql_handle_collect h
					on last_tt.tt=h.tt AND last_tt.SPID=h.SPID AND last_tt.start_time=h.start_time
				inner join awr.sql_text_collect as t
					on h.SQLHandle=t.SQLHandle
				--WHERE (SQLText LIKE @Filter_Text OR @Filter_Text IS NULL);
				WHERE SQLText NOT LIKE '%SELECT @OlapEvent = %';	--исключаем диагностические запросы (Трассировка OLAP).
				IF @zabbix=0
					SELECT SPID, Host, 
						CASE 
							WHEN Program LIKE 'SQLAgent - TSQL JobStep (Job 0x%' THEN 
								(	SELECT top 1 'SQLAgent Job "'+j.name+'". Step ('+SUBSTRING(T1.Program,CHARINDEX(': Step',T1.Program)+7,100)
									FROM [msdb].[dbo].[sysjobs] j
									WHERE convert(varchar(100),convert(binary(16),  j.job_id),2)=LEFT(REPLACE(T1.Program,'SQLAgent - TSQL JobStep (Job 0x',''),33)
								)
							ELSE Program
						END as Program,
						[Login], login_time, DB, RunTime_sec, [status], wait_type, Blk_By,Exec_Statement
					FROM #t1 as T1
					WHERE (Exec_Statement LIKE @Filter_Text OR @Filter_Text IS NULL);
				ELSE
					SELECT COUNT(*) as cnt FROM #t1 WHERE (Exec_Statement LIKE @Filter_Text OR @Filter_Text IS NULL);		

				IF @kill=1
				BEGIN
					declare @spid smallint, @kill_sql nvarchar(300);
					Declare C Cursor FOR
						SELECT spid FROM #t1 WHERE (Exec_Statement LIKE @Filter_Text OR @Filter_Text IS NULL);
					open C;
					FETCH NEXT FROM C INTO @spid;
					WHILE @@FETCH_STATUS=0
					BEGIN
						IF EXISTS(SELECT session_id FROM sys.dm_exec_sessions where session_id=@spid)
						BEGIN
							set @kill_sql='KILL '+CAST(@spid as varchar(6))+';';
							PRINT(@kill_sql);
							EXEC(@kill_sql);
						END
						FETCH NEXT FROM C INTO @spid;
					END
					close C;
					deallocate C;
				END
			END
	END
	END
GO
PRINT N'Creating Procedure [info].[usp_get_DiskMetr]...';


GO

/* =============================================
-- Author:		Андрей Иванов (sqland1c)
-- Create date: 09.09.2015 (1.0)
-- Description: Получаем данные о счетчике производительности Logical Disk из xEvents xe_DiskInfo (собирает каждые 15 сек.)
				xEvents xe_DiskInfo должен быть включен и должен собирать информацию.
				Вывод результатов основан на предположении что все значения получаемых счетчиков (кроме free_megabytes и cur_disk_queue_len) из xEvents (Logical Disk) куммулятивные (то есть постоянно накапливаются)
				Значения большинство показателей высчитываются как среднее примерно за последнюю минуту (учитывается 4 последних сборов данных)
				Значения free_megabytes и cur_disk_queue_len берется из последнего сбора (самые свежие данные)
				
-- Update:		23.09.2015 (1.03)
				Добавлен алгоритм включения и настройки Extended Events "xe_DiskInfo" если он ещё не был настроен!
				Также добавлено исправление если из кольцевого буфера получаем NULL - здесь делаем включение
				сессии xEvents и возвращаем пустой набор данных.
				28.09.2015 (1.04)
				Включение и настройка xEvents [xe_DiskInfo] перенесена в начало ХП usp_pfc_collect,  а здесь закомментировано.
				При получении данных из xml расширен тип для столбцов % использования и простоя диска с numeric(19,2) до numeric(38,2).
				19.10.2015 (1.05)
				Небольшое исправление: включение сессии закоментировано (т.к. все равно это невозможно внутри транзакции).
-- ============================================= */
CREATE PROCEDURE info.usp_get_DiskMetr

AS
begin
	--IF NOT EXISTS (SELECT * FROM sys.server_event_sessions WHERE name = 'xe_DiskInfo')
	--BEGIN
	----Настраиваем и включаем сборщик данных через Extended Events!
	----xEvents сессия для сбора информации о счетчиках группы Logical Disk (инфо обновляется каждые 15 сек.)
	----Данные сохраняются в кольцевой буфер и хранятся тут совсем недолго.
	----Эти данные нужно успеть захватить и обработать и положить в схему awr в базу sputnik.
	--	CREATE EVENT SESSION [xe_DiskInfo] ON SERVER 
	--		ADD EVENT sqlserver.perfobject_logicaldisk 
	--		ADD TARGET package0.ring_buffer(SET max_events_limit=(128),max_memory=(32768))
	--	WITH (MAX_MEMORY=4096 KB,EVENT_RETENTION_MODE=ALLOW_SINGLE_EVENT_LOSS,MAX_DISPATCH_LATENCY=10 SECONDS,MAX_EVENT_SIZE=0 KB,MEMORY_PARTITION_MODE=NONE,TRACK_CAUSALITY=OFF,STARTUP_STATE=ON);
	--	ALTER EVENT SESSION [xe_DiskInfo] ON SERVER STATE = START;
	--	--геренируем задержку в 30 сек, чтобы данные успелись собраться!
	--	--если не успеет собраться, тогда соберем в след. раз!
	--	waitfor delay '00:00:30.000';
	--END
	declare @xml_data xml, @tz_offset smallint=datepart(TZoffset,SYSDATETIMEOFFSET());
	SELECT @xml_data=CAST(xet.target_data AS xml)
			FROM sys.dm_xe_session_targets AS xet
			JOIN sys.dm_xe_sessions AS xe
			   ON (xe.address = xet.event_session_address)
			WHERE xe.name = 'xe_DiskInfo'
				and xet.target_name = 'ring_buffer';
	--select @xml_data;
	IF @xml_data is null
	begin
		--Если возвращен NULL, значит скорее всего Сессия не включена!
		--ALTER EVENT SESSION [xe_DiskInfo] ON SERVER STATE = START;
		select null as tt, null as counter_name, null as instance_name, null as value
		where 1=0;
	end
	else
	begin 
		;with data_xml as
		(	SELECT 
				xed.event_data.value('(@timestamp)[1]', 'datetime') AS [tt_utc],
				xed.event_data.value('(data[@name="instance_name"]/value)[1]', 'varchar(50)') AS instance_name,
				xed.event_data.value('(data[@name="free_megabytes"]/value)[1]', 'numeric(19,2)') AS free_megabytes,
				xed.event_data.value('(data[@name="disk_writes_per_second"]/value)[1]', 'numeric(19,2)') AS disk_writes_per_second,
				xed.event_data.value('(data[@name="disk_reads_per_second"]/value)[1]', 'numeric(19,2)') AS disk_reads_per_second,
				xed.event_data.value('(data[@name="disk_write_bytes_per_second"]/value)[1]', 'numeric(19,2)') AS disk_write_bytes_per_second,
				xed.event_data.value('(data[@name="disk_read_bytes_per_second"]/value)[1]', 'numeric(19,2)') AS disk_read_bytes_per_second,
				xed.event_data.value('(data[@name="current_disk_queue_length"]/value)[1]', 'numeric(19,2)') AS current_disk_queue_length,
				xed.event_data.value('(data[@name="percent_idle_time"]/value)[1]', 'numeric(38,2)') AS percent_idle_time,
				xed.event_data.value('(data[@name="percent_disk_read_time"]/value)[1]', 'numeric(38,2)') AS percent_disk_read_time,
				xed.event_data.value('(data[@name="percent_disk_write_time"]/value)[1]', 'numeric(38,2)') AS percent_disk_write_time
			FROM (select @xml_data as data) as data
				CROSS APPLY data.nodes('//RingBufferTarget/event') AS xed (event_data)
		),
		--SELECT * FROM @T_data;
		 data_tt_rank as (
			select distinct tt_utc, DENSE_RANK() over (order by tt_utc desc) as tt_rank
			from data_xml
		),
		data_tt as (
			select distinct
				max(tt_utc) over () as tt_max,
				min(tt_utc) over () as tt_p
			from data_tt_rank 
			where tt_rank between 1 and 4
		),
		data_results_1 as (
			select 
				t_max.tt_utc as tt_utc,
				datediff(second,t_p.tt_utc,t_max.tt_utc) as sec_delta,
				t_max.instance_name,
				t_max.free_megabytes as Free_Mb,
				t_max.disk_writes_per_second-t_p.disk_writes_per_second as disk_writes_sec_Delta,
				t_max.disk_reads_per_second-t_p.disk_reads_per_second as disk_reads_sec_Delta,
				(t_max.disk_write_bytes_per_second-t_p.disk_write_bytes_per_second) as disk_write_B_sec_Delta,
				(t_max.disk_read_bytes_per_second-t_p.disk_read_bytes_per_second) as disk_read_B_sec_Delta,
				t_max.current_disk_queue_length as cur_disk_queue_len,
				t_max.percent_idle_time-t_p.percent_idle_time as Disk_IdleTime,
				t_max.percent_disk_read_time-t_p.percent_disk_read_time as Disk_ReadTime,
				t_max.percent_disk_write_time-t_p.percent_disk_write_time as Disk_WriteTime
			from data_xml as t_max
			inner join data_xml as t_p
				on t_p.instance_name=t_max.instance_name
			where t_max.tt_utc=(select tt_max from data_tt)
				and t_p.tt_utc=(select tt_p from data_tt)
				and t_max.instance_name like '%:' 
		),
		data_result_2 as (
			select 
				dateadd(minute,@tz_offset,tt_utc) as tt,
				sec_delta, 
				instance_name, Free_Mb, 
				cast(disk_reads_sec_Delta/sec_delta as numeric(19,2)) as avg_disk_reads_sec, 
				cast(disk_writes_sec_Delta/sec_delta as numeric(19,2)) as avg_disk_writes_sec, 
				cast((disk_read_B_sec_Delta/sec_delta)/1024.00 as numeric(19,2)) as avg_disk_read_Kb_sec,
				cast((disk_write_B_sec_Delta/sec_delta)/1024.00 as numeric(19,2)) as avg_disk_write_Kb_sec,
				cur_disk_queue_len,
				cast(Disk_IdleTime/(Disk_IdleTime+Disk_ReadTime+Disk_WriteTime)*100.00 as numeric (19,2)) as Disk_IdleTime_perc,
				cast(Disk_ReadTime/(Disk_IdleTime+Disk_ReadTime+Disk_WriteTime)*100.00 as numeric (19,2)) as Disk_ReadTime_perc,
				cast(Disk_WriteTime/(Disk_IdleTime+Disk_ReadTime+Disk_WriteTime)*100.00 as numeric (19,2)) as Disk_WriteTime_perc
			from data_results_1
			where sec_delta>=44
		)
		select tt,counter_name,instance_name, value
		from data_result_2
		unpivot(value for counter_name in ([Free_Mb],[avg_disk_reads_sec],[avg_disk_writes_sec],[avg_disk_read_Kb_sec],[avg_disk_write_Kb_sec],
			[cur_disk_queue_len], [Disk_IdleTime_perc], [Disk_ReadTime_perc], [Disk_WriteTime_perc])
		)unpvt
		order by counter_name,instance_name
		;	
	end
end
GO
PRINT N'Creating Procedure [info].[usp_DBSizeReport]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 13.03.2014
	-- Description:	Эта процедура выдаёт информацию о размерах всех БД на сервере в разрезе: 
				ИмяБазыДанных
				Состояние
				РежимВосстановления
				РазмерВсейБД 
				КоличествоФайловДанных 
				РазмерВсехФайловДанных 
				НеиспользуемоеПространствоВФайлахДанных 
				КоличествоФайловЛогов 
				РазмерВсехФайловЛогов
				НеиспользуемоеПространствоВФайлахЛогов 
				
	-- Update:		28.07.2014 (1.1)
				В запросы добавлено условие: name NOT LIKE 201%(%)% , для того чтобы исключить
				базы данных Обмена. Из-за этих баз периодически возникают ошибки в этом Отчёте.

				04.10.2014 (1.3)
				Существенное изменение алгоритма! Во-первых, теперь вся информация полностью
				берётся из представления sys.database_files. Во-вторых, добавлен учет размеров FILESTREAM.
				В-третьих, добавлены параметры @DBFilter - возможность фильтра по конкретной базе,
				и @details - будет выводится детализация по файлам и файловым группам.

				29.10.2014 (1.31)
				В запросе, где получаем список БД добавлено ещё одно  условие name NOT LIKE 'S201%(%)%',
				чтобы исключить базы данных обмена (начинающихся на S).

				22.08.2015 (1.35)
				Добавлен новый параметр @GetFreeSpaceMb - возвращает свободное место в дата-файлах БД (в Мб).
				Нужно например для мониторинга свободного места в базе tempdb.

				10.09.2015 (1.36)
				Получение свободного места по базе tempdb переделано на получение информации из счетчика производительности.
				10.09.2015 (1.37)
				Добавлены новые параметры @GetLogFilesSize и @GetLogFilesSizeUsed для получения места занимаемого файлами журналами транзакций в БД.
				Причем размер указывается в Гб и берется из счетчика производительности.

				05.08.2016 (1.40)
				Новая версия. Изменён алгоритм: сначала отбираем общие данные из sys.master_files.
				Затем по каждой БД получаем инфо о ФГ и о неиспользуемом месте из sys.database_files.
				Также в вывод добавлен столбец LogBusy - показывает для лог-файлов причину
				распухания (это столбец log_reuse_wait_desc представления sys.databases).

				26.08.2016 (1.41)
				Небольшое исправление - изменены имена возвращаемых столбцов.
				Также в результат добавлен DISTINCT, чтобы исключить дубликаты.

				29.08.2016 (1.42)
				Небольшое исправление - связь между master_files и database_files теперь по FILE_ID
				(до этого было по FileName).

				08.11.2016 (1.430)
				Исправление IIF на CASE для обратной совместимости с 2008R2 (и младше!)

				26.12.2016 (1.435)
				Добавлен новый параметр @GetAllSizeGb - получение общего размера для указанной БД в Гб.
			
				16.01.2017 (1.440)
				Используемый размер файлов БД теперь получаем из sys.database_files. Если же база или файл недоступен, тогда берётся из sys.master_files

				28.03.2017 (1.450)
				В вывод добавлена информация об заданном лимите файлов (MaxSizeMb). Если лимит не задан, то будет 0.00.
				При выводе без детализации (@details=0), MaxSizeMb будет представлен, как СУММА по типу файлов. Но если 
				для какого-то файла с этим же типом MaxSize=0.00, то и вся сумма будет тоже 0.00 (то есть лимит не задан).
				При выводе с детализацией (@details=1),  MaxSizeMb выводится для каждого файла.

				11.04.2017 (1.455)
				Если задан параметр @GetAllSizeGb и @DBFilter не указан - то будет показан размер по всем базам.

				11.04.2017 (1.470)
				Добавлены новые параметры @DBList и @DBList_delimeter: первый параметр определяет список баз
				в виде строки, разделённых Разделителем @DBList_delimeter (по умолчанию это Запятая).
				Теперь можно получать размеры по списку баз. Старый параметр @DBFilter - отбор по конкретной базе.
			
				17.11.2017 (1.471)
				Увеличены размеры строковых переменных, связанных с именем БД до 1000 символов, а для переменной @Str до MAX.

				29.12.2017 (1.472)
				Увеличены размеры строковых переменных (имя БД) до 2000 символов.

				24.01.2018 (1.473)
				В вывод добавлена информация о владельце базы (DBOwner).

				01.02.2018 (1.500)
				Изменён алгоритм получения актуальных данных из sys.database_files. Теперь если нет данных из sys.database_files,
				то такие данные удаляем из общей таблицы!
				Также добавлен новый ВЫХОДНОЙ параметр @ReturnNum. Теперь через него можно вернуть значение для @GetFreeSpaceMb и @GetAllSizeGb 
				(при этом  @ReturnNum также должен быть задан при вызове процедуры).
			
				23.02.2018 (1.502)
				Для определения правильного имени сервера SQL теперь 
				используется процедура info.usp_getHostname	
			
				09.04.2018 (1.505)
				Возврат значений для @GetLogFilesSizeUsed и @GetLogFilesSize через выходной параметр @ReturnNum		
	-- ============================================= */
	CREATE PROCEDURE info.usp_DBSizeReport
		@DBFilter nvarchar(2000)=null,@details bit = 0,
		@GetFreeSpaceMb bit=0, @GetLogFilesSize bit=0,
		@GetLogFilesSizeUsed bit=0, @GetAllSizeGb bit=0,
		@DBList NVARCHAR(MAX) = NULL,
		@DBList_delimeter NVARCHAR(10)=',',
		@ReturnNum numeric(19,3)=NULL OUTPUT
	AS
	BEGIN
		SET NOCOUNT ON;
		declare @sql NVARCHAR(MAX), @dblist_fmt NVARCHAR(MAX);
		--Здесь получаем правильное имя SQL Server:
		declare @servername nvarchar(510);
		exec sputnik.info.usp_GetHostname @Servername=@Servername OUT;
		IF @DBList > N'' AND @DBList IS NOT NULL
		BEGIN
			--11.04.17 Новый алгоритм обработки @DBList (список БД в виде строки);
			set @dblist_fmt = 'N'''+REPLACE(@DBList, @DBList_delimeter,''' , N''')+'''';
			set @dblist_fmt = REPLACE(@dblist_fmt,'N'''' , ','');
			set @dblist_fmt = REPLACE(@dblist_fmt,' , N''''','');
		END
		CREATE TABLE #x(DB Nvarchar(2000));
		SET @sql = N'SELECT name FROM sys.databases WHERE 1=1'
		+ CASE WHEN @dblist_fmt IS NOT NULL THEN ' AND name IN (' + @dblist_fmt + ')'
			   ELSE '' 
		  END;
		INSERT #x EXEC sp_executesql @sql;

		IF (@GetFreeSpaceMb=1 /*OR @GetAllSizeGb=1*/) and (@DBFilter is null OR @DBFilter='')
			set @DBFilter='tempdb';
		--По базе TempDB быстро получаем свободное место из счетчика производительности:
		if @GetFreeSpaceMb=1 and @DBFilter='tempdb'
		begin
			select 
				cast(cast(cntr_value as numeric(19,2))/(1024.00*1024.00) as numeric(19,2)) as FreeSpaceGb
			from sys.dm_os_performance_counters
			where counter_name='Free Space in tempdb (KB)';
			return;
		end
		--Получаем информацию о размерах файлах журналов транзакций в базе из счетчика производительности
		if @GetLogFilesSize=1 or @GetLogFilesSizeUsed=1
		begin
			declare @logsize_res numeric(19,2);
			;with cte_src AS (
				select 
					QUOTENAME(@DBFilter)+' Log Files Size (Gb)' as counter_name,
					case rtrim(counter_name)
						when 'Log File(s) Size (KB)' then '_Total'
						when 'Log File(s) Used Size (KB)' then '_Used'
					end as instance_name,
					cast(cast(cntr_value as numeric(19,2))/(1024.00*1024.00) as numeric(19,2)) as value
				from sys.dm_os_performance_counters
				where counter_name like 'Log File(s)% Size (KB)%'
					and rtrim(instance_name)=@DBFilter
			)
			select @logsize_res=[value]
			from cte_src
			where instance_name=CASE WHEN @GetLogFilesSize=1 THEN '_Total' ELSE '_Used' END
			;	
			IF @ReturnNum is not null
				set @ReturnNum=@logsize_res;
			else
				select @logsize_res as [Gb];

			return;
		end

		--Первая часть: Создаем временную таблицу и в неё загружаем основную информацию о размерах из представлений sys.master_files и sys.Database_Files(в каждой базе своя).
		IF OBJECT_ID('tempdb..#FSizeAll') is not null
			DROP TABLE #FSizeAll;
		CREATE TABLE #FSizeAll
		(
	
			DB Nvarchar(2000),
			[DBID] int,
			F_ID int, -- File_ID
			FName SYSNAME,
			FType NVARCHAR(60),
			FState nvarchar(60),
			FG NVARCHAR(900),
			SizeMb DECIMAL(12,2),
			MaxSizeMb DECIMAL(12,2),
			FreeSpaceMB DECIMAL(12,2),
			LogBusy nvarchar(60),
			DBState nvarchar(60),
			DBCreateDate datetime,
			DBReadOnly bit,
			DBRecoveryModel nvarchar(60),
			DBOwner nvarchar(128)
		);

		--Сначала в итоговую таблицу запишем информацию из sys.master_files
		INSERT INTO #FSizeAll
			([DBID], DB, F_ID, FName, FType, [FState], FG, SizeMb, MaxSizeMB, FreeSpaceMB, LogBusy, [DBState], DBCreateDate, DBReadOnly, DBRecoveryModel,DBOwner)
		SELECT 
			DBinfo.database_id AS [DBID],
			DBinfo.name AS DB,
			mf.[file_id] as F_ID,
			mf.name as FName,
			type_desc AS FType,
			mf.[state_desc] AS [FState],
			NULL as FG,
			cast(size/128.0 as decimal(12,2)) as SizeMB,
			CASE 
				WHEN mf.max_size=-1 THEN 0 
				WHEN mf.type_desc='LOG' and mf.max_size=268435456 THEN 0
				ELSE cast(mf.max_size/128.0 as decimal(12,2))
			END as MaxSizeMB,
			NULL AS FreeSpaceMb,
			CASE 
				WHEN mf.type_desc<>'LOG' THEN ''
				WHEN DBinfo.log_reuse_wait_desc='NOTHING' THEN ''
				ELSE DBinfo.log_reuse_wait_desc
			END AS LogBusy,
			DBinfo.state_desc AS [DBState],
			DBinfo.create_date AS DBCreateDate,
			DBinfo.is_read_only AS DBReadOnly,
			DBinfo.recovery_model_desc AS DBRecoveryModel,
			suser_sname(DBinfo.owner_sid) as DBOwner
		FROM sys.master_files as mf 
		left join sys.databases as DBinfo
			ON mf.database_id=DBinfo.database_id
		inner join #x as DBList
			ON DBinfo.[name]=DBList.DB
		WHERE (DBinfo.name=@DBFilter OR @DBFilter is null)
			AND (DBinfo.name NOT LIKE '201%(%)%' and DBinfo.name NOT LIKE 'S201%(%)%')
		;

		IF @GetAllSizeGb=1
		BEGIN
			Select TOP 1 cast(SUM(SizeMB)/1024.0 as decimal(12,3)) AS AllSizeGb
			From #FSizeAll;
			IF @ReturnNum is not null
				Select TOP 1 @ReturnNum=cast(SUM(SizeMB)/1024.0 as decimal(12,3))
				From #FSizeAll;
			return;
		END

		--Теперь по каждой базе получаем информацию из sys.database_files (если база и файлы доступны)
		-- и обновляем временную таблицу #FSizeAll!
		DECLARE @db Nvarchar(2000), @Str NVARCHAR(MAX);
		DECLARE Db CURSOR FOR
		SELECT DISTINCT DB AS name
		FROM #FSizeAll F
		WHERE [FState]='ONLINE'
			AND [DBState]='ONLINE'
		OPEN Db
		FETCH NEXT FROM Db INTO @db
		WHILE @@FETCH_STATUS=0
		BEGIN
			SELECT @Str=N'USE ['+@db+N'];
			DECLARE @DBFiles TABLE (F_ID int, FName nvarchar(128), FG nvarchar(128), FreeSpaceMb decimal(19,2), SizeMb decimal(19,2),MaxSizeMB decimal(19,2));
			INSERT INTO @DBFiles (F_ID, FName, FG, FreeSpaceMb, SizeMb, MaxSizeMB)
			SELECT 
				[file_id] as F_ID,
				name as FName,
				ISNULL(FILEGROUP_NAME(data_space_id),'''') as FG,
				CASE
					WHEN type_desc=''FILESTREAM'' THEN 0.00
					ELSE cast(size/128.0 as decimal(19,2)) - cast(FILEPROPERTY(name,''SpaceUsed'')/128.0 as decimal(19,2))
				END AS FreeSpaceMb,
				cast(size/128.0 as decimal(12,2)) as SizeMb,
				CASE 
					WHEN max_size=-1 THEN 0 
					WHEN type_desc=''LOG'' and max_size=268435456 THEN 0
					ELSE cast(max_size/128.0 as decimal(19,2))
				END as MaxSizeMB
			FROM sys.database_files;
			--Обновляем существующие данные в таблице из sys.database_files:
			UPDATE Upd
			SET Upd.FG=F.FG, Upd.FreeSpaceMb=F.FreeSpaceMb, Upd.SizeMb=F.SizeMb, Upd.MaxSizeMB=F.MaxSizeMB
			FROM #FSizeAll Upd
			INNER JOIN @DBFiles F
				ON Upd.F_ID=F.F_ID
			WHERE Upd.DB='''+@db+N'''
			;
			--Удаляем данные в таблице, которых нет в sys.database_files
			DELETE Del
			FROM #FSizeAll Del
			LEFT JOIN @DBFiles F
				ON Del.F_ID=F.F_ID
			WHERE Del.DB='''+@db+N''' AND F.F_ID IS NULL
			;';
			EXEC sp_executesql @Str;
			FETCH NEXT FROM Db INTO @db
		END
		CLOSE Db;
		DEALLOCATE Db;
		--Часть вторая: строим результирующую выборку на основании полученных данных во временной таблицы.
		--Причем можно получить сгруппированную по типам файлов информацию или детализированную информацию (с выводом Файловых групп и имен файлов).
	
		IF @details=0
			IF @GetFreeSpaceMb=0
				select distinct
					@Servername as SQLServerName, 
					DBSize.DB, DBSize.DBCreateDate as CreateDate, 
					DBSize.DBState as [State], DBSize.DBReadOnly as [ReadOnly], 
					ISNULL(Mrr.mirroring_role_desc,'') as MirroringRole,
					cast(SUM(SizeMB) OVER (PARTITION BY DBSize.[DBID])/1024.0 as decimal(12,3)) AS AllSizeGb,
					DBSize.DBRecoveryModel as RecoveryModel, DBSize.FType as FilesType, 
					SUM(DBSize.SizeMb) OVER (PARTITION BY DBSize.[DBID], DBSize.FType ) AS SizeMb,
					SUM(DBSize.FreeSpaceMB) OVER (PARTITION BY DBSize.[DBID], DBSize.FType ) AS FreeSpaceMB,
					CASE 
						WHEN MIN(DBSize.MaxSizeMB) OVER (PARTITION BY DBSize.[DBID], DBSize.FType )=0.00 THEN 0.00
						ELSE SUM(DBSize.MaxSizeMB) OVER (PARTITION BY DBSize.[DBID], DBSize.FType )
					END AS MaxSizeMB,
					DBSize.LogBusy,
					DBSize.DBOwner
				from #FSizeAll as DBSize
				left join sys.database_mirroring Mrr
					ON Mrr.database_id=DBSize.[DBID] and mirroring_guid is not null
				order by DBSize.DB,DBSize.FType
			ELSE
			BEGIN
				Select distinct CAST((SUM(FreeSpaceMb) over (partition by DB, FType))/1024.00 as numeric(19,2)) as FreeSpaceGb
				From #FSizeAll
				Where FType='ROWS';
				IF @ReturnNum is not null
					Select TOP 1 @ReturnNum=CAST((SUM(FreeSpaceMb) over (partition by DB, FType))/1024.000 as numeric(19,3))
					From #FSizeAll
					Where FType='ROWS';	
			END
		ELSE
			select distinct
				@Servername as SQLServerName, 
				DBSize.DB, DBSize.DBCreateDate AS CreateDate, 
				DBSize.DBState AS [State], DBSize.DBReadOnly AS [ReadOnly], 
				ISNULL(Mrr.mirroring_role_desc,'') as MirroringRole,
				cast(SUM(SizeMB) OVER (PARTITION BY DBSize.[DBID])/1024.0 as decimal(12,3)) AS AllSizeGb,
				DBSize.DBRecoveryModel AS RecoveryModel, DBSize.FType as FilesType, 
				DBSize.FG, DBSize.FName, DBSize.FState,
				SUM(DBSize.SizeMb) OVER (PARTITION BY DBSize.[DBID], DBSize.FName ) AS SizeMb,
				SUM(DBSize.FreeSpaceMB) OVER (PARTITION BY DBSize.[DBID], DBSize.FName ) AS FreeSpaceMB,
				SUM(DBSize.MaxSizeMB) OVER (PARTITION BY DBSize.[DBID], DBSize.FName ) AS MaxSizeMB,
				DBSize.LogBusy,
				DBSize.DBOwner
			from #FSizeAll as DBSize
			left join sys.database_mirroring Mrr
				ON Mrr.database_id=DBSize.[DBID] and mirroring_guid is not null
			order by DBSize.DB,DBSize.FG,DBSize.FName
	END
GO
PRINT N'Creating Procedure [info].[usp_CheckMirror]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 24.01.2014
	-- Description:	Эта процедура возвращает информацию о зеркальном отображении БД. 
					Параметр @zabbix - если задан 1, тогда  будет возвращена информация о Сбоях в зеркалировании!
						Если ничего не возвращено, тогда всё ок. По умолчанию 0.
	-- Update:
					13.02.2013 (1.1)
					В результат добавлен ещё один столбец - Имя базы данных, для которой работает Зеркалирование.
					Также изменен алгоритм для получения ServerName (теперь получаем точное физическое имя сервера!
					т.к. свойство @@SERVERNAME - имя экземпляра SQL Server может быть неточным, после переименования Сервера)
					19.05.2015 (1.11)
					Исправлено определение имени сервера - теперь учитывается имя экземпляра!
					25.05.2015 (1.20)
					Новая версия алгоритма определения состояния Зеркала. Теперь учитывается Базы готовые к Зеркалированию,
					но у которых нет ни Log Shipping , ни Зеркалирования (в таком случае состояние помечается как Candidate)!
					26.05.2015 (1.25)
					Доработан механизм определения состояния Зеркала. 
					Теперь учитываются базы, для которых в данный момент настраиваются Зеркалирование! Исходя из состояния XLog
					в таблице BackConf и текущего состояния Job по настройке Зеркала.
					26.05.2015 (1.26)
					Исправлен алгоритм определения состояния Зеркалирования - теперь состояние XLog не учитывается, учитывается
					только текущее состояние Job по настройке Зеркала!
					02.06.2015 (1.27)
					Небольшое исправление в алгоритме определения состояния Зеркалирования - если результат Job Successfully,
					то состояние Зеркала должно быть Candidate!
					28.08.2015 (1.29)
					Добавлена поддежрка мониторинга AlwaysON AG с основной реплики!
					02.09.2015 (1.30)
					Исправлен алгоритм получения информации для мониторинга AlwaysON AG.
					28.07.2016 (1.31)
					Снова подправлен алгоритм получения информации для мониторинга AlwaysON AG!
					24.08.2016 (1.32)
					Исправлен алгоритм получения БД - в список исключения добавлены системные БД 'master','msdb','model'!
					23.01.2018 (1.36)
					Доработан алгоритм для zabbix(возвращает выходной параметр!)
					26.01.2018 (1.37)
					Исправление для zabbix - при вызове с параметром @ResState процедура usp_JobMonitor не вызывается! 
					23.02.2018 (1.381)
					Для определения правильного имени сервера SQL теперь 
					используется процедура info.usp_getHostname	 
	-- ============================================= */
	CREATE PROCEDURE info.usp_CheckMirror 
		@zabbix bit = 0,
		@dbfilter nvarchar(2000)=null,
		@ResState nvarchar(100)=null OUTPUT
	as
	begin
		set nocount on;	
		declare @SQLServer nvarchar(510);
		exec sputnik.info.usp_GetHostname @Servername=@SQLServer OUT;
		/* Старая версия
		select 
			@sqlserver  as ServerName, DB_NAME(database_id) as DBName, mirroring_role_desc as Role, mirroring_state_desc as State, mirroring_partner_instance as PartnerServerName
		from 
			sys.database_mirroring
		where
			mirroring_guid is not null
			and (@zabbix=0 or (mirroring_state_desc not in ('SYNCHRONIZING','SYNCHRONIZED')))
		*/
		--Выключаем параметр ANSI_WARNINGS чтобы вставлять длинные строки в таблицу с обрезанием!
		SET ANSI_WARNINGS OFF;
		DECLARE @T_Jobs TABLE (SQLServerName sql_variant, [Job] NVARCHAR(200), [Step] NVARCHAR(1), Info CHAR(1), RUN_STATUS VARCHAR(30), DateTimeRun DateTime, Duration VARCHAR(10));
		IF @ResState is null
			insert into @T_Jobs
			exec sputnik.info.usp_JobMonitor @Activity=1;

		Declare @T_Result TABLE (servername nvarchar(1000), DBName nvarchar(2000), [Role] nvarchar(100), [State] nvarchar(100), PartnerServerName nvarchar(1000));
		insert into @T_Result(servername,DBName,[Role],[State],PartnerServerName)
		SELECT 
			@sqlserver  as ServerName, 
			DB.DB as DBName, 
			CASE 
				WHEN alwayson_ag.[Role] IS NOT NULL AND alwayson_ag.[PrimaryReplica] COLLATE Cyrillic_General_CI_AS<>@sqlserver THEN N'AlwaysON '+QUOTENAME(alwayson_ag.[Role] COLLATE Cyrillic_General_CI_AS)
				WHEN alwayson_ag.[Role] IS NOT NULL AND alwayson_ag.[PrimaryReplica] COLLATE Cyrillic_General_CI_AS=@sqlserver THEN N'AlwaysON [PRIMARY]'
				WHEN Mir.mirroring_state_desc IS NULL THEN N'PRIMARY'
				ELSE Mir.mirroring_role_desc
			END AS [Role],
			CASE 
				WHEN alwayson_ag.[Role] IS NOT NULL AND alwayson_ag.health=N'HEALTHY' THEN alwayson_ag.sync_state
				WHEN alwayson_ag.[Role] IS NOT NULL AND alwayson_ag.health<>N'HEALTHY' THEN alwayson_ag.sync_state+' '+QUOTENAME(alwayson_ag.health COLLATE Cyrillic_General_CI_AS)
				WHEN Mir.mirroring_state_desc IS NULL AND (Jobs.[RUN_STATUS] IS NULL OR Jobs.[RUN_STATUS] COLLATE Cyrillic_General_CI_AS='Successfully') THEN 'Candidate'
				WHEN Mir.mirroring_state_desc IS NULL AND Jobs.[RUN_STATUS] IS NOT NULL THEN 'Setup '+Jobs.RUN_STATUS COLLATE Cyrillic_General_CI_AS
				ELSE Mir.mirroring_state_desc
			END AS [State],
			CASE
				WHEN alwayson_ag.[Role] IS NOT NULL AND (alwayson_ag.[PrimaryReplica] COLLATE Cyrillic_General_CI_AS=@sqlserver
					AND alwayson_ag.[PartnerReplica] COLLATE Cyrillic_General_CI_AS <> alwayson_ag.[PrimaryReplica] COLLATE Cyrillic_General_CI_AS) THEN N'SECONDARY: '+QUOTENAME(alwayson_ag.[PartnerReplica] COLLATE Cyrillic_General_CI_AS)
				WHEN alwayson_ag.[Role] IS NOT NULL AND (alwayson_ag.[PrimaryReplica] COLLATE Cyrillic_General_CI_AS<>@sqlserver
					OR alwayson_ag.[PartnerReplica] COLLATE Cyrillic_General_CI_AS = alwayson_ag.[PrimaryReplica] COLLATE Cyrillic_General_CI_AS) THEN N'PRIMARY: '+QUOTENAME(alwayson_ag.[PrimaryReplica] COLLATE Cyrillic_General_CI_AS)
				--WHEN alwayson_ag.[Role] IS NOT NULL AND alwayson_ag.[Role] COLLATE Cyrillic_General_CI_AS<>'PRIMARY' THEN N'Primary: '+QUOTENAME(alwayson_ag.PrimaryReplica)
				WHEN Mir.mirroring_state_desc IS NULL THEN ''
				ELSE Mir.mirroring_partner_instance
			END AS [PartnerServerName]
		FROM
		(
			SELECT DB --, CASE WHEN [Log]=0 THEN 'XLog' ELSE 'Candidate' END AS [Status] 
			FROM sputnik.info.vGetQuickBackConf
			WHERE [state]='ONLINE' AND RecoveryModel='FULL' AND DB NOT IN ('master','msdb','model')
			--Проверять Зеркало нужно для всех БД, у которых Full Recovery Model (ДАЖЕ ЕСЛИ НЕТ БЭКАПОВ В sputnik). Поэтому след.строка закоментирована:
			--AND (([Full]=1 OR [FullWeekly]=1) AND ([Log]=1 OR DB IN (SELECT DBName FROM sputnik.backups.BackConf WHERE [Kind] IN ('XLog', 'Log_Secondary'))))		
		) DB
		LEFT JOIN sys.database_mirroring Mir 
			ON DB.DB=DB_NAME(Mir.database_id)
		LEFT JOIN (
				SELECT
					DB_NAME(ag_db.database_id) as DB,
					ISNULL(arstates.role_desc, '') AS [Role],
					ISNULL(AR.replica_server_name, '') as [PartnerReplica],
					ISNULL(agstates.primary_replica, '') AS [PrimaryReplica],
					ag_db.synchronization_state_desc as sync_state,
					ag_db.synchronization_health_desc as health
				FROM sys.dm_hadr_database_replica_states ag_db
				LEFT JOIN sys.dm_hadr_availability_group_states as agstates
					on ag_db.group_id=agstates.group_id	
				LEFT JOIN sys.dm_hadr_availability_replica_states AS arstates
					ON ag_db.replica_id = arstates.replica_id
						and ag_db.group_id=arstates.group_id
				LEFT JOIN sys.availability_replicas as AR
					ON ag_db.replica_id=AR.replica_id
						and ag_db.group_id=AR.group_id
				--WHERE ag_db.is_local=1 OR
				--	ISNULL(AR.replica_server_name, '') COLLATE Cyrillic_General_CI_AS<>@sqlserver
			) as alwayson_ag
			ON DB.DB=alwayson_ag.DB
		LEFT JOIN (select REPLACE([Job],'RM ','') as DB,[RUN_STATUS] from @T_Jobs where [Job] LIKE 'RM %') as Jobs
			ON DB.DB=Jobs.DB-- AND DB.[Status]='XLog'
		WHERE
			(Mir.mirroring_state_desc IS NOT NULL OR alwayson_ag.[Role] IS NOT NULL OR DB.DB NOT IN (select DBNameTarget from sputnik.lse.SourceConfig))
			AND (@zabbix=0 or (Mir.mirroring_state_desc not in ('SYNCHRONIZING','SYNCHRONIZED')));
		if @ResState is null or @dbfilter is null
			select * from @T_Result where (DBName = @dbfilter or @dbfilter is null);
		else
		begin
			declare @restemp nvarchar(100);
		
			select top 1 @restemp='mi '+CASE WHEN [State] IN ('SYNCHRONIZING','SYNCHRONIZED') THEN '1' ELSE '2' END from @T_Result where (DBName = @dbfilter) and [State]<>'Candidate' and [Role] not like 'AlwaysON %';

			if @restemp is null
				select top 1 @restemp='ao 2'
				from @T_Result where (DBName = @dbfilter) and [Role] like 'AlwaysON %' and [state] NOT IN ('SYNCHRONIZING','SYNCHRONIZED');
			if @restemp is null
				select top 1 @restemp='ao 1'
				from @T_Result where (DBName = @dbfilter) and [Role] like 'AlwaysON %' and [state] IN ('SYNCHRONIZING','SYNCHRONIZED');
			if @restemp is null
				select top 1 @restemp='0'
				from @T_Result where (DBName = @dbfilter) and [State]='Candidate';			

			set @ResState=COALESCE(@restemp,'-1');
		end

	end
GO
PRINT N'Creating Procedure [info].[usp_BackupReport]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 29.11.2013 (1.0)
	-- Description: Возвращает информацию о последних бэкапах (полный и лога) из БД sputnik.
	-- Update:
					04.02.2014 (2.0)
					Полностью переписан алгоритм процедуры. Теперь показывает все данные, имена файлов бэкапов локально и копии в сети, а также производится проверка файла через спец. процедуру.
					Добавлен параметр @Backup_type, если задан, то отчёт будет только по указанному типу бэкапа.
					Расширенные возможности! Добавлен параметр @xp, если задан 1, то Отчёт строится не по базе sputnik. А по всем базам через системные таблицы базы msdb! 
						При этом если будет задан тип бэкапа, тогда Отчёт будет построен только по созданным бэкапам указанного типа.
					05.02.2014 (2.1)
					Добавлен новый параметр @OnlyProblems. Если задан 1, то в Отчёт будут попадать только Проблемы ( файла бэкапа нет, или дата бэкапа очень старая)!
					По умолчанию 0. Исправления в алгоритме отбора по виду бэкапа.
					17.02.2014 (2.2)
					Добавлен новый алгоритм для более точного определения информации при получении НЕрасширенного отчёта. Используется новая функция uf_GetWeekDay, которая
					определяет день недели для Даты бэкапа. А также доработан алгоритм существования Копии файла (если путь для копии НЕ задан, то определяется существование
					основного файла бэкапа). Кроме этого, доработан алгоритм получения Расширенного отчёта - теперь учитываются Дифф. бэкапы (на равне с полными).					18.02.2014 (2.21)
					Добавлена проверка на состояние базы ReadOnly=0 при получении расширенного отчёта.
					21.02.2014 (2.5)
					Полностью изменён алгоритм получения НЕрасширенного отчета. Теперь используется CTE и один большой запрос разбит на два.
					Всё это сделано, чтобы исправить задвоение в результатах (из-за использования таблицы Daily и Weekly).
					27.05.2014 (2.51) 
					Добавлено DISTINCT в запрос по базе sputnik (нерасширенный вариант). Чтобы исключить появление дубликатов 
					в результатах (когда в таблице реально есть дубликаты).
					10.07.2014 (2.55)
					Добавлен новый параметр @DBFilter - позволяет получить отчёт только по указанной БД.
					28.07.2014 (2.56)
					Добавлено DISTINCT в расширенный отчёт. Чтобы исключить появление дубликатов.
					30.07.2014 (2.7)
					Полностью переделан алгоритм получения НЕрасширенного отчёта (по данным из БД sputnik). Теперь получение всей информации
					происходит из новой ХП info.usp_GetLastBackups.
					30.07.2014 (2.72)
					Учтены входные параметры @DBFilter и @Backup_type при работе НЕрасширенного отчёта. При этом отбор происходит на самом
					раннем этапе (при получении данных из ХП info.usp_GetLastBackups), что ускоряет выполнение всего отчёта
					31.07.2014 (2.73)
					Изменен алгоритм получения имени сервера для НЕрасширенного отчёта: теперь используется SERVERPROPERTY + явная конвертация в nvarchar.
					31.07.2014 (2.74)
					Внесено небольшое изменение: для работы отчета из 1С, нужно чтобы возвращаемые поля с датами были СТАРОГО ТИПА datetime!
					17.11.2014 (2.75)
					В расширенный отчёт добавлен дополнительный отбор для исключения временных баз Обмена 1СПегас!
					20.11.2014 (2.76)
					В вызов ХП usp_GetLastBackups добавлен новый параметр @CheckOnline - чтобы проверять только существующие БД (причём у которых 
					состояние=Online и ReadOnly=False).
					01.12.2015 (2.78)
					SQLServer теперь формируется правильно из SERVERPROPERTY + учитывается именованный экземпляр.
					Также внесён небольшой FIX в расширенный отчет - получение самого последнего имени файла в разрезе БД,типа бэкапа и даты бэкапа.
					Чтобы исключить подобные задвоения.
					11.01.2016 (2.80)
					Расширены проверки и результаты при работе нерасширенного отчета!
					24.05.2016 (2.85)
					Добавлен новый режим @xp=2 - это нерасширенный отчет + дополнительные сведения по бэкапу (время выполнения, размер,
					коэфициент сжатия). Для этого изменён тип параметра @xp - c bit на tinyint.
					Также исправлено формирование имени сервера (теперь правильно учитывается имя сервера и имя экземпляра).
					16.06.2016 (2.86)
					Для режима @xp2 размер бэкапа возвращается теперь в Гб (ранее было в Мб).
					24.08.2016 (2.90)
					Доработан режим работы @xp2, теперь показывает полную информацию (в том числе теперь проверяется полный 
					бэкап для базы model!).
					29.09.2016 (2.92)
					Добавлено новое исключение - для вторичных реплик AlwaysOn теперь не требуется Полный бэкап.
					А для бэкапов Логов проверяем, что бэкапы должны выполняться на текущем сервере через
					функцию: fn_hadr_backup_is_preferred_replica.
					17.10.2016 (2.95)
					Алгоритм процедуры изменён - теперь есть возможность работы на старых экземплярах SQL Server 2008(R2).
					18.10.2016 (2.96)
					Небольшое исправление - фильтр по @Backup_type не работал в режиме @xp=2.
					24.11.2016 (2.963)
					Для расширенного решима (@xp1) теперь также выводиться размер последнего бэкапа.
					23.02.2018 (2.965)
					Для определения правильного имени сервера SQL теперь 
					используется процедура info.usp_getHostname	
	-- ============================================= */
	CREATE PROCEDURE info.usp_BackupReport
		@Backup_type varchar(4) = null,
		@xp tinyint = 0,
		@OnlyProblems bit = 0,
		@DBFilter nvarchar(200) = null
	AS
	BEGIN
		SET NOCOUNT ON;
		declare @SQLServer nvarchar(510);
		exec sputnik.info.usp_GetHostname @Servername=@SQLServer OUT;
		if OBJECT_ID('tempdb..DB') IS NOT NULL
			DROP TABLE #DB;
		CREATE TABLE #DB (name nvarchar(800), [id] int, model nvarchar(800), BackupTypeNeed nvarchar(800));
		if OBJECT_ID('tempdb..src_ag_db') IS NOT NULL
			DROP TABLE #src_ag_db;
		CREATE TABLE #src_ag_db (DB nvarchar(800), [db_id] int, [Role] nvarchar(800), [PartnerReplica] nvarchar(800), [PrimaryReplica] nvarchar(800), sync_state nvarchar(800), health nvarchar(800), DB_State nvarchar(800));
		IF CAST (LEFT (CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(2)),2) AS SMALLINT) >= 11
			--Информация о вторичных репликах AlwaysON AG на текущем сервере:
			INSERT INTO #src_ag_db (DB, [db_id], [Role], [PartnerReplica], [PrimaryReplica], sync_state, health, DB_State)
				SELECT
					DB_NAME(ag_db.database_id) as DB,
					ag_db.database_id as [db_id],
					ISNULL(arstates.role_desc, '') AS [Role],
					ISNULL(AR.replica_server_name, '') as [PartnerReplica],
					ISNULL(agstates.primary_replica, '') AS [PrimaryReplica],
					ag_db.synchronization_state_desc as sync_state,
					ag_db.synchronization_health_desc as health,
					ag_db.database_state_desc as DB_State 
				FROM sys.dm_hadr_database_replica_states ag_db
				LEFT JOIN sys.dm_hadr_availability_group_states as agstates
					on ag_db.group_id=agstates.group_id	
				LEFT JOIN sys.dm_hadr_availability_replica_states AS arstates
					ON ag_db.replica_id = arstates.replica_id
						and ag_db.group_id=arstates.group_id
				LEFT JOIN sys.availability_replicas as AR
					ON ag_db.replica_id=AR.replica_id
						and ag_db.group_id=AR.group_id
				WHERE ag_db.is_local=1 
					AND ISNULL(arstates.role_desc, '') = 'SECONDARY'
		IF CAST (LEFT (CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(2)),2) AS SMALLINT) >= 11
			INSERT INTO #DB(name,id,model,BackupTypeNeed)
			select 
				name,database_id as id,recovery_model_desc as model,'Full' as BackupTypeNeed
			from sys.databases db
			left join #src_ag_db as src_ag_db 
				ON db.database_id=src_ag_db.[db_id]
			where 
				/*state_desc='ONLINE' and */is_read_only=0 and name not in ('tempdb'/*, 'model'*/)
				AND (name NOT LIKE '201%(%)%' and name NOT LIKE 'S201%(%)%')
				AND src_ag_db.[db_id] IS NULL 
			UNION ALL
			select 
				name,database_id as id,recovery_model_desc as model,'Log' as BackupTypeNeed
			from sys.databases
			where 
				/*state_desc='ONLINE' and */ is_read_only=0 and name not in ('tempdb', 'model')	and recovery_model_desc<>'SIMPLE'
				AND (name NOT LIKE '201%(%)%' and name NOT LIKE 'S201%(%)%') 
				AND (sys.fn_hadr_backup_is_preferred_replica(name)=1);
		ELSE
			INSERT INTO #DB(name,id,model,BackupTypeNeed)
			select 
				name,database_id as id,recovery_model_desc as model,'Full' as BackupTypeNeed
			from sys.databases db
			left join #src_ag_db as src_ag_db 
				ON db.database_id=src_ag_db.[db_id]
			where 
				/*state_desc='ONLINE' and */is_read_only=0 and name not in ('tempdb'/*, 'model'*/)
				AND (name NOT LIKE '201%(%)%' and name NOT LIKE 'S201%(%)%')
				AND src_ag_db.[db_id] IS NULL 
			UNION ALL
			select 
				name,database_id as id,recovery_model_desc as model,'Log' as BackupTypeNeed
			from sys.databases
			where 
				/*state_desc='ONLINE' and */ is_read_only=0 and name not in ('tempdb', 'model')	and recovery_model_desc<>'SIMPLE'
				AND (name NOT LIKE '201%(%)%' and name NOT LIKE 'S201%(%)%')
	
		--select * from #DB

		if @xp in (0,2)
		begin
			IF DB_ID('sputnik') is not null
			BEGIN
				DECLARE @TT TABLE ([DB_name] NVARCHAR(400), Backup_Type VARCHAR(4), BackupFile NVARCHAR(500), ID INT, BackupDate DATETIME2(2), LocalDir NVARCHAR(500), NetDir NVARCHAR(500), CheckLocalDir BIT, CheckNetDir BIT, CheckLocalFile BIT, CheckLocalFileOnly BIT, CheckNetFile BIT);
				INSERT INTO @TT
					EXEC sputnik.info.usp_GetLastBackups @DBName=@DBFilter, @Backup_type=@Backup_type, @CheckOnline=1;

				IF @xp=0
					select DISTINCT 
						@SQLServer as SQLServer, 
						CAST(SYSDATETIME() AS datetime) AS ServerTime,
						[DB_name] AS DBName, 
						CAST(BackupDate AS datetime) as BackupDate, 
						Backup_Type, 
						CASE 
							WHEN CheckLocalDir=0 THEN 'Каталог "'+LocalDir+'" НЕДОСТУПЕН!'
							WHEN CheckLocalFile=0 AND CheckLocalFileOnly=1 THEN LocalDir+REPLACE(BackupFile,'.BAK','.ONLY')
							ELSE LocalDir+BackupFile 
						END AS LocalFile,
						CASE 
							WHEN CheckLocalFile=0 THEN CheckLocalFileOnly
							ELSE CheckLocalFile
						END AS CheckLocalFile,
						CASE
							WHEN NetDir is NULL OR NetDir='' OR LocalDir=NetDir THEN 'Копии бэкапа отключены'
							WHEN CheckNetDir=0 THEN 'Каталог "'+NetDir+'" НЕДОСТУПЕН!'
							WHEN CheckLocalFile=0 AND CheckLocalFileOnly=1 THEN 'Копия бэкапа НЕДОСТУПНА!'
							ELSE NetDir+BackupFile
						END AS NetFile,
						case
							when NetDir is NULL OR NetDir='' OR LocalDir=NetDir then CheckLocalFile
							else CheckNetFile
						end as [CheckNetFile],
						DATEDIFF(minute,BackupDate,SYSDATETIME()) as BackupAgeInMinutes
					from @TT t
					where LocalDir is not null
				ELSE IF @xp=2
					select DISTINCT 
						getdate() AS tt,
						@SQLServer as SQLServer, 
						Bases.name AS DBName, 
						CAST(t.BackupDate AS datetime) as BackupDate, 
						CASE
							WHEN t.Backup_Type IS NULL THEN Bases.BackupTypeNeed 
							ELSE t.Backup_Type
						END as Backup_Type, 
						CASE 
							WHEN t.[DB_name] IS NULL THEN '!Бэкапы не настроены/нет первого бэкапа!'
							WHEN t.CheckLocalDir=0 THEN 'Каталог "'+t.LocalDir+'" НЕДОСТУПЕН!'
							WHEN t.CheckLocalFile=0 AND t.CheckLocalFileOnly=1 THEN t.LocalDir+REPLACE(t.BackupFile,'.BAK','.ONLY')
							ELSE t.LocalDir+t.BackupFile 
						END AS LocalFile,
						CASE 
							WHEN t.CheckLocalFile=0 THEN t.CheckLocalFileOnly
							ELSE t.CheckLocalFile
						END AS CheckLocalFile,
						CASE
							WHEN t.[DB_name] IS NULL THEN NULL
							WHEN t.NetDir is NULL OR t.NetDir='' OR t.LocalDir=t.NetDir THEN 'Копии бэкапа отключены'
							WHEN t.CheckNetDir=0 THEN 'Каталог "'+t.NetDir+'" НЕДОСТУПЕН!'
							WHEN t.CheckLocalFile=0 AND t.CheckLocalFileOnly=1 THEN 'Копия бэкапа НЕДОСТУПНА!'
							ELSE t.NetDir+t.BackupFile
						END AS NetFile,
						case
							when t.NetDir is NULL OR t.NetDir='' OR t.LocalDir=t.NetDir then CheckLocalFile
							else t.CheckNetFile
						end as [CheckNetFile],
						--DATEDIFF(minute,BackupDate,SYSDATETIME()) as BackupAgeInMinutes
						CAST(AllBackups.backup_size_Mb/1024.000 as numeric(9,3)) AS backup_size_Gb,
						AllBackups.backup_compress_ratio,
						DATEDIFF(second, AllBackups.backup_start_date, AllBackups.backup_finish_date) as backup_elapsed_sec
					from #DB as Bases
					LEFT JOIN @TT t ON Bases.name=t.[DB_name] AND (Bases.BackupTypeNeed=t.Backup_Type OR (t.Backup_Type='DIFF' AND Bases.BackupTypeNeed='FULL'))
					LEFT JOIN [sputnik].[backups].[BackupHistory] AllBackups ON t.ID=AllBackups.ID
					WHERE (Bases.BackupTypeNeed=@Backup_type or @Backup_type is NULL) 
			END
		end
		else
		--Расширенный мониторинг для всех баз (а не только тех, что прописаны в базе sputnik).
		begin
			select DISTINCT
				@SQLServer as SQLServer, 
				CAST(SYSDATETIME() AS datetime) AS ServerTime,
				Bases.name as DBName, Bases.id as DBID, Bases.model, 
				BackupTypeNeed,
				Backups.BackupType as BackupTypeFact,
				Backups.BackupDate, REPLACE(Backups.BackupFile,'.Only','.BAK') as BackupFile,
				sputnik.info.uf_checkfile(REPLACE(Backups.BackupFile,'.Only','.BAK')) as CheckBackupFile,
				DATEDIFF(minute,Backups.BackupDate,getdate()) as BackupAgeInMinutes,
				CAST(Backups.backup_size_Mb/1024.000 as numeric(9,3)) AS backup_size_Gb
			from
			#DB as Bases
			left join
			(
				select DISTINCT
					BS.database_name as DBName,
					case BS.type 
						when 'D' then 'Full'
						when 'I' then 'Diff'
						when 'L' then 'Log'
					end as BackupType,
					BS.backup_finish_date as BackupDate,
					MAX(MF.physical_device_name) over (partition by BS.database_name,BS.[type],BS.backup_finish_date) as BackupFile,
					CASE 
						WHEN BS.compressed_backup_size IS NULL 
							THEN cast(BS.backup_size/(1024*1024) as decimal(19,3))
						ELSE cast(BS.compressed_backup_size/(1024*1024) as decimal(19,3)) 
					END backup_size_Mb
				from msdb.dbo.backupset BS
				inner join msdb.dbo.backupmediafamily MF
					on BS.media_set_id=MF.media_set_id
				inner join
					(
						select distinct
							database_name,type,max(backup_finish_date) as BackupDate
						from
							msdb.dbo.backupset
						group by
							database_name,type
					) BSmax
					on BS.database_name=BSmax.database_name 
						and (BS.type=BSmax.type)
						and BS.backup_finish_date=BSmax.BackupDate
			)Backups
				on Bases.name=Backups.DBName and (Bases.BackupTypeNeed=Backups.BackupType OR (Bases.BackupTypeNeed='Full' and Backups.BackupType='Diff'))
			where
				(@Backup_type is null or (Bases.BackupTypeNeed=@Backup_type))
				AND (@DBFilter is null or Bases.name=@DBFilter)
				AND (@OnlyProblems = 0 or sputnik.info.uf_checkfile(REPLACE(Backups.BackupFile,'.Only','.BAK')) <> 1 or ((Backups.BackupType='Log' and DATEDIFF(minute,Backups.BackupDate,getdate())>60) or (Backups.BackupType<>'Log' and DATEDIFF(minute,Backups.BackupDate,getdate())>1600)))

		end;	
	END
GO
PRINT N'Creating Procedure [info].[usp_GetDrives]...';


GO

/* =============================================
-- Author:		Андрей Иванов (sqland1c)
-- Create date: 18.02.2014 (1.0)
-- Description:	Эта функция возвращает информацию о локальных дисках и свободном месте в Гб на Них в виде Таблицы!
				
-- Update:		
				06.04.2014 (1.01)
				Новый параметр @GetMaxFree - если задан 1, тогда в выходном параметре @MaxFreeDrive будет буква диска,
				где больше всего свободного места.
				17.09.2015 (1.02)
				Новый параметр @DiskFilter показывает информацию только по указанному диску (нужно передавать только 1 букву диска)
-- ============================================= */
CREATE PROCEDURE info.usp_GetDrives 
	@GetMaxFree bit = 0, 
	@MaxFreeDrive char(1)=NULL OUTPUT,
	@DiskFilter varchar(1)=NULL
AS
BEGIN
	set nocount ON;
	declare  @Temp TABLE (Drive varchar(5),MB_Free decimal(12,3));

	insert into @Temp
	exec xp_fixeddrives

	IF @GetMaxFree=0
		select Drive, cast (MB_Free / 1024.000 as decimal (12,3)) as GB_Free
		from @Temp
		where (@DiskFilter is null OR Drive=@DiskFilter)
	ELSE
		SELECT TOP 1 @MaxFreeDrive=Drive
		FROM @Temp
		WHERE MB_Free= (SELECT MAX(MB_Free) FROM @Temp);
END
GO
PRINT N'Creating Procedure [info].[usp_GetHostname]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 23.02.2018
	-- Description:	Эта процедура возращает имя сервера (Hostname). Причём Full computername, то есть даже если имя сервера будет более 15 символов, то вернёт полное имя сервера (а не netbios computername)!

	-- Update:		23.03.2018 (1.010)
					Добавлен алгоритм проверки доступна ли роль sysadmin. Если недоступна, то получаем имя сервера старым методом (без вызова xp_cmdshell).
	-- ============================================= */
	CREATE PROC [info].[usp_GetHostname] 
		@Hostname nvarchar(255)='' OUTPUT,
		@Instancename nvarchar(255)='' OUTPUT,
		@Servername nvarchar(510)='' OUTPUT
	AS
	BEGIN
		set nocount on;
		if is_srvrolemember('sysadmin')=1
		begin
			declare @output table (line varchar(255));
			insert @output(line) 
			exec xp_cmdshell 'powershell "[System.Net.Dns]::GetHostName()"';
			select top 1 @Hostname=[line] from @output where [line] is not null;
		end
		else
			set @Hostname=cast(serverproperty('MachineName') as nvarchar(255));
		set @Instancename=COALESCE( cast(SERVERPROPERTY('InstanceName') as nvarchar(255)),'');
		set @Servername=COALESCE(@Hostname,'')+CASE WHEN @InstanceName > '' THEN '\' ELSE '' END +@Instancename;
	END
GO
PRINT N'Creating Procedure [info].[usp_JobMonitor]...';


GO

/* =============================================
-- Author:		Андрей Иванов (sqland1c)
-- Create date: 02.06.2014
-- Description:	
			Эта процедура выдаёт информацию о выполнении заданий (Job) SQL Server Agent 
			В двух вариантах: если не задан параметр @Activity (по умолчанию), то будут выбраны все ошибки заданий за последние @OldDay дней (по умолчанию 1);
			если параметр задан @Activity=1, то будет показана выборка подобно Job Activity Monitor.
-- Update:
				03.06.2014 (1.01)
				В результаты добавлен имя сервера(компьютера). Также изменено название столбца Duration.
				04.06.2014 (1.02)
				Для возвращаемого поле [message] задан Alias Info.
				15.08.2014 (1.1)
				В режим @Activity=1 добавлен алгоритм, который получает информацию о выполнении Job в текущий момент времени!
				При этом, если задание сейчас выполняется, то в поле Duration будет показано, сколько Времени оно выполняется!
				А в поле [DateTimeRun] дата и время запуска задания!
				Теперь это полноценный  Job Activity Monitor!
				19.08.2014 (1.12)
				Внесены исправления в алгоритм формирования отчета Job Activity Monitor.
				22.08.2014 (1.13)
				Добавлено ключевое слово DISTINCT для исключения дубликатов в отчете Job Activity Monitor.
				Такие дубликаты возникают, если задание выполняется в данный момент и у него несколько шагов (Step).
				11.08.2015 (1.20)
				Для активных заданий добавлена информация о текущем шаге задания
				19.01.2017 (1.300)
				Добавлен новый параметр @JobName - фильтр по имени Задания.
				Добавлен новый параметр @GetStatus - возвращает только 1 столбец RUN_STATUS. Требует чтобы параметр @JobName был также указан!
				19.04.2017 (1.316)
				Для параметра @JobName теперь можно задать маску %имя% (т.е. работает LIKE).
				Добавлен новый параметр @Lite. Возвращает 4 столбца: Job, Step, RUN_STATUS, Duration_min. Принудительно устанавливает параметр @Activity=1.
				Добавлен новый параметр @OnlyEnabled. По умолчанию 1. Возвращает только включенные Jobs. Если сделать 0, то увидим все Задания (включенные и отключенные).
-- ============================================= */
CREATE PROCEDURE info.usp_JobMonitor
	@OldDay tinyint = 1,
	@Activity bit = 0,
	@JobName nvarchar(2000)=null,
	@GetStatus bit=0,
	@Lite bit=0,
	@OnlyEnabled bit=1
AS
BEGIN
	SET NOCOUNT ON;
	IF @GetStatus=1
	BEGIN
		IF @JobName is null
		BEGIN
			SELECT 'Чтобы получить статус, укажите параметр @JobName' as RUN_STATUS;
			RETURN;
		END
		SET @Activity=1;		
	END
	IF @Lite=1 AND @Activity=0
		SET @Activity=1;
	
	IF @Activity=0 
	BEGIN
		SELECT 
			SERVERPROPERTY('ServerName') as SQLServerName,
			J.name as Job, 
			H.step_name as Step,
			H.[message] as Info,
			CASE H.run_status
				WHEN 0 THEN 'Failed'
				WHEN 1 THEN 'Successfully'
				WHEN 2 THEN 'Re-run'
				WHEN 3 THEN 'Canceled by user'
			END AS RUN_STATUS,
			MSDB.dbo.agent_datetime(run_date, run_time) AS [DateTimeRun],
			Duration=STUFF(STUFF(RIGHT('000000' + CONVERT(VARCHAR(6),H.run_duration),6 ),3,0,':'),6,0,':')
		FROM
			(	SELECT job_id,name
				FROM msdb.dbo.sysjobs
				WHERE [enabled]=1
					AND name<>'syspolicy_purge_history'
			) J
		INNER JOIN msdb.dbo.sysjobhistory H
			ON J.job_id=H.job_id  
				and H.run_status IN (0,3)  --Ошибка или Отмена пользователем.
				and step_id>0
		WHERE
			DATEDIFF(day,convert(datetime2(2),cast(H.run_date as varchar(8))),SYSDATETIME())<=1 --За один последний день
	END
	ELSE
	BEGIN
	--Job Activity Monitor
		DECLARE @TJ TABLE (SQLServerName varchar(128), Job nvarchar(2000), Step nvarchar(2000), Info nvarchar(max), RUN_STATUS varchar(50), [DateTimeRun] datetime, Duration varchar(100), Duration_min numeric(19,2));
		WITH TT
		AS
		(	SELECT 
				J.name as Job, 
				J.job_id,
				J.[enabled],
				H.Step_name as Step,
				H.[message] as Info,
				H.run_status,
				MSDB.dbo.agent_datetime(run_date, run_time) AS [DateTimeRun],
				H.run_duration
			FROM
				(	SELECT job_id,name,[enabled] 
					FROM msdb.dbo.sysjobs
					WHERE name<>'syspolicy_purge_history' 
						--and [enabled]=1					
						AND (name LIKE @JobName OR @JobName is null)
				) J
			LEFT JOIN msdb.dbo.sysjobhistory H
				ON J.job_id=H.job_id  
					and step_id>0 AND (H.run_status BETWEEN 0 AND 3)
		)
		INSERT INTO @TJ (SQLServerName,Job,Step,Info,RUN_STATUS,[DateTimeRun],Duration,Duration_min)
		SELECT DISTINCT
			CAST(SERVERPROPERTY('ServerName') as varchar(128)) as SQLServerName,
			GMAX.Job, 
			CASE
				WHEN ja.job_id IS NOT NULL THEN ja.step_name
				ELSE DET.Step
			END AS Step,
			CASE 
				WHEN ja.job_id IS NOT NULL THEN NULL
				ELSE DET.Info
			END AS Info,
			CASE 
				WHEN ja.job_id IS NOT NULL THEN 'Running'
				WHEN DET.run_status=0 THEN 'Failed'
				WHEN DET.run_status=1 THEN 'Successfully'
				WHEN DET.run_status=2 THEN 'Re-run'
				WHEN DET.run_status=3 THEN 'Canceled by user'
			END AS RUN_STATUS,
			CASE
				WHEN ja.job_id IS NOT NULL THEN ja.start_execution_date
				ELSE DET.DateTimeRun
			END AS [DateTimeRun],
			CASE 
				WHEN ja.job_id IS NOT NULL THEN 
						RIGHT('00'+CAST ((DATEDIFF(SECOND, ja.start_execution_date, SYSDATETIME())/3600) AS VARCHAR (2)),2)
						+':'+ RIGHT('00'+CAST ((DATEDIFF(SECOND, ja.start_execution_date, SYSDATETIME()) % 3600) / 60 AS VARCHAR(2)),2)
						+':'+ RIGHT('00'+CAST (((DATEDIFF(SECOND, ja.start_execution_date, SYSDATETIME()) % 3600) % 60 ) % 60 AS VARCHAR(2)),2)
				ELSE STUFF(STUFF(RIGHT('000000' + CONVERT(VARCHAR(6),DET.run_duration),6 ),3,0,':'),6,0,':')
			END AS Duration,
			CASE 
				WHEN ja.job_id IS NOT NULL THEN 
						CAST((CAST(DATEDIFF(SECOND, ja.start_execution_date, SYSDATETIME()) AS NUMERIC(19,2))) / 60 AS NUMERIC(19,2))
				ELSE
					CAST(((DET.run_duration/10000) * 60) as numeric(19,2))+ --Hours
					CAST((DET.run_duration/100%100 ) as numeric(19,2))+		--Mins
					CAST((DET.run_duration%100/60.00) as numeric(19,2))		--Secs
			END AS Duration_min
		FROM 
		(
			SELECT 
				job_id, Step, [enabled], Job, MAX(DateTimeRun) AS LastDateTimeRun
			FROM TT
			GROUP BY
				job_id, Step, [enabled], Job
		)GMAX
		LEFT JOIN TT DET 
			ON GMAX.job_id=DET.job_id AND GMAX.Step=DET.Step AND GMAX.LastDateTimeRun=DET.DateTimeRun
		--отсюда получим информацию о работе Job в текущий момент времени:
		LEFT JOIN 
			(
				SELECT
					ja.job_id,
					ja.start_execution_date,      
					-- ISNULL(last_executed_step_id,0)+1 AS current_executed_step_id,
					ja.last_executed_step_date,
					Js.step_name
				FROM msdb.dbo.sysjobactivity ja 
				LEFT JOIN msdb.dbo.sysjobhistory jh 
					ON ja.job_history_id = jh.instance_id
				JOIN msdb.dbo.sysjobsteps js
					ON ja.job_id = js.job_id
					AND ISNULL(ja.last_executed_step_id,0)+1 = js.step_id
				WHERE ja.session_id = (SELECT TOP 1 session_id FROM msdb.dbo.syssessions ORDER BY agent_start_date DESC)
				AND start_execution_date is not null
				AND stop_execution_date is null
			)ja ON GMAX.job_id=ja.job_id
		WHERE ((GMAX.[enabled]=1 AND DET.run_status IS NOT NULL) OR ja.job_id IS NOT NULL) OR (@OnlyEnabled=0)
		
		IF @GetStatus=1
			SELECT TOP 1 RUN_STATUS FROM @TJ WHERE Job LIKE @JobName;
		ELSE IF @Lite=1
			SELECT Job, Step, RUN_STATUS, Duration_min FROM @TJ;
		ELSE
			SELECT SQLServerName,Job,Step,Info,RUN_STATUS,[DateTimeRun],Duration FROM @TJ;
		
	END
END
GO
PRINT N'Creating Procedure [info].[usp_GetIP]...';


GO

/* =============================================
-- Author:		Андрей Иванов (sqland1c)
-- Create date: 23.07.2014 (1.0)
-- Description:	Эта процедура возвращает IP адрес сервера (где выполняется).
				Для получения нужных данных используется команда операционной системы IPConfig.
-- Update:		18.08.2014 (1.01)
				Исправлена строка с получением IP адреса из результатов команды IPConfig:
				вместо '%IPv4%' теперь получаем '   IPv4%' (чтобы получить именно IPv4 адрес).
-- ============================================= */
CREATE PROCEDURE info.usp_GetIP
AS
BEGIN
	SET NOCOUNT ON;
	DECLARE @T TABLE (Output NVARCHAR(300));
	DECLARE @str NVARCHAR(20);
	INSERT INTO @T
	EXEC xp_cmdshell 'IPCONFIG';
	SELECT TOP 1 @str=SUBSTRING(Output,CHARINDEX(':',Output)+1,20) FROM @T
	WHERE Output LIKE '   IPv4%'
	SELECT LTRIM(@str) as IP;
END
GO
PRINT N'Creating Procedure [info].[usp_CheckCatalog]...';


GO

/* =============================================
-- Author:		Андрей Иванов (sqland1c)
-- Create date: 26.07.2014
-- Description:	Эта процедура проверяет наличие (существование) указанного каталога.
				Если каталог существует, будет возвращен 1. Иначе 2.
				Параметр @Catalog - полный путь к файлу, который нужно проверить.	
-- Update:		
-- ============================================= */
CREATE PROCEDURE info.usp_CheckCatalog
(
	@Catalog nvarchar(500)
)
AS
BEGIN
	SET NOCOUNT ON;
	declare @Return tinyint=0;
	Declare @DIR NVARCHAR(550);
	declare @TableCheck TABLE ([File Exists] bit, [File is a Directory] bit, [Parent Directory Exists] bit);
	--Сначала проверим существование каталога;
	INSERT INTO @TableCheck
	EXEC xp_fileexist @Catalog;
	SELECT @Return=[File is a Directory] FROM @TableCheck;
	if @Return=0
		SELECT @Return=[Parent Directory Exists] FROM @TableCheck;
	--Теперь, если каталог не существует попробуем его создать!	
	if @Return=0
	begin
		SET @DIR='MKDIR '+@Catalog;
		exec @Return= xp_cmdshell @DIR , NO_OUTPUT;
		IF @Return=0 
			SET @Return=1;
		ELSE
			SET @Return=2;
	end
	else
		if @Return=0
			SET @Return=2;
	SELECT @Catalog AS 'Dir', @Return AS 'Exist';
END
GO
PRINT N'Creating Procedure [info].[usp_GetLastBackups]...';


GO

/* =============================================
-- Author:		Андрей Иванов (sqland1c)
-- Create date: 29.07.2014 (1.0)
-- Description:	Эта процедура возвращает информацию по последним выполненным бэкапам из БД Спутник!
				При этом сразу проверяется доступность файлов бэкапов!
-- Update:		25.08.2014 (1.01)
				Добавлена проверка: БД, по которой получаем Инфо существует на сервере и её
				состояние = Online и эта БД не для чтения.
				20.11.2014 (1.05)
				Изменен алгоритм дополнительной проверки БД (база online и не для чтения!). Во-первых, теперь по-умолчанию
				это проверка не производится. Во-вторых, чтобы проверка производилась, нужно задать новый параметр @CheckOnline!
				11.01.2016 (1.10)
				Расширен алгоритм проверки бэкапов: добавлены проверки существования каталогов и файла ONLY.
-- ============================================= */
CREATE PROCEDURE info.usp_GetLastBackups
	@DBName NVARCHAR(400) = NULL,
	@Backup_Type VARCHAR(4) = NULL,
	@ToDate DATETIME2(2) = NULL,
	@CheckOnline bit = 0
AS
BEGIN
	SET NOCOUNT ON;
	;with cte_1 AS
	(
		SELECT
			  AllBackups.[DB_name],
			  LastBackups.Backup_Type, 
			  AllBackups.Backup_File+'.BAK' AS BackupFile, 
			  LastBackups.ID, 
			  LastBackups.backup_finish_date as BackupDate,
			  CatalogInfo.LocalDir,
			  CatalogInfo.NetDir,
			  sputnik.info.uf_checkfile(CatalogInfo.LocalDir) as CheckLocalDir,
			  sputnik.info.uf_checkfile(CatalogInfo.NetDir) as CheckNetDir,
			  sputnik.info.uf_checkfile(CatalogInfo.LocalDir + AllBackups.Backup_File+'.BAK') as CheckLocalFile,
			  sputnik.info.uf_checkfile(CatalogInfo.LocalDir + AllBackups.Backup_File+'.ONLY') as CheckLocalFileOnly, 
			  sputnik.info.uf_checkfile(CatalogInfo.NetDir + AllBackups.Backup_File+'.BAK') as CheckNetFile
		FROM
		(
			SELECT [Backup_Type], 
				MAX(ID) AS [ID],
				MAX(backup_finish_date) AS [backup_finish_date]
			FROM
				[sputnik].[backups].[BackupHistory] bh
			WHERE
				(@DBName IS NULL OR [DB_Name]=@DBName)
				AND (@CheckOnline=0 OR [DB_Name] IN (select name from sys.databases where [state]=0 and is_read_only=0))
				AND (@Backup_Type IS NULL OR [Backup_Type]=@Backup_Type)
				AND (@ToDate IS NULL OR [backup_finish_date] <= @ToDate)
			GROUP BY [DB_Name], [Backup_Type]
		) LastBackups
		INNER JOIN
			[sputnik].[backups].[BackupHistory] AllBackups ON LastBackups.ID=AllBackups.ID
		CROSS APPLY
			sputnik.info.uf_GetBackConf(AllBackups.[DB_Name], LastBackups.Backup_Type, AllBackups.backup_start_date) AS CatalogInfo
	)
	SELECT 
		[DB_name],Backup_Type,BackupFile,ID,BackupDate,
		LocalDir,NetDir,
		CheckLocalDir,CheckNetDir,
		CheckLocalFile,
		CheckLocalFileOnly,
		CheckNetFile
	FROM cte_1
	ORDER BY
		[DB_name], BackupDate
END
GO
PRINT N'Creating Procedure [info].[usp_GetChainLogs]...';


GO

/* =============================================
-- Author:		Андрей Иванов (sqland1c)
-- Create date: 04.08.2014
-- Description:	Эта процедура возвращает цепочку Бэкапов Логов из БД Спутник Начиная с указанного Полного Бэкапа (Если задан @BackupFullID).
				Чтобы учесть, что мог быть сделан Дифф. бэкап, или для отбора бэкапов Лога для наката в LSE 
				производится дополнительный отбор: отбираются более поздние бэкапы Логов, чем бэкап, заданный в @FilterBackupID.
				
-- Update:		21.10.2015 (1.03)
				Добавлен параметр @top - позволяет вывести только указанное количество строк.
				Также добавлен параметр @GetBackupFile - позволяет в результате в столбце BackupFile вывести только имя файла (без полного пути и расширения).
-- ============================================= */
CREATE PROCEDURE info.usp_GetChainLogs
	@DBName NVARCHAR(300),
	@BackupFullID INT = NULL,
	@FilterBackupID INT = NULL,
	@top INT = NULL,
	@ToDate DATETIME2(2) = NULL,
	@fromcopy bit = 0,
	@GetBackupFile bit = 0
AS
BEGIN
	SET NOCOUNT ON;
	declare @DB_LSN numeric(25,0)=NULL;
	IF @BackupFullID IS NOT NULL
	BEGIN
		SELECT @DB_LSN=MIN(database_backup_lsn)
		FROM [sputnik].[backups].[BackupHistory]
		WHERE DB_NAME=@DBName
		AND database_backup_lsn>
			(
				SELECT [database_backup_LSN]
				FROM [sputnik].[backups].[BackupHistory]
				WHERE ID=@BackupFullID
			)
	END
	IF @top IS NULL
		SET @top=1000000000;
	select TOP (@top) 
		case 
			when @GetBackupFile=1 then BACKUP_File					
			when @fromcopy=0 or CatalogInfo.NetDir is null or CatalogInfo.NetDir='' then CatalogInfo.LocalDir+BACKUP_File+'.BAK' 
			else CatalogInfo.NetDir+BACKUP_File+'.BAK' 
		end as BackupFile,
		'Log' as BackupType,
		[ID],
		Backup_Finish_Date
	from
	(
		SELECT DB_NAME, BACKUP_File, Backup_Finish_Date, backup_start_date, ID, last_LSN
		FROM [sputnik].[backups].[BackupHistory]
		WHERE
			DB_NAME=@DBName 
			AND [Backup_Type]='Log'
			AND ([database_backup_lsn]=@DB_LSN OR @DB_LSN IS NULL)
			AND ([ID]>@FilterBackupID OR @FilterBackupID IS NULL) 
			AND ([Backup_Finish_Date]<=@ToDate or @ToDate IS NULL)
	) AS LogBackups
	CROSS APPLY sputnik.info.uf_GetBackConf(LogBackups.[DB_Name], 'Log', LogBackups.backup_start_date) AS CatalogInfo
	order by LogBackups.last_LSN;
END
GO
PRINT N'Creating Procedure [info].[usp_dbmail_DrivesFreeSpace]...';


GO

CREATE PROCEDURE [info].[usp_dbmail_DrivesFreeSpace]
AS
BEGIN
	SET NOCOUNT ON;
	create table #DriveSpaceLeft (Drive varchar(10),
								  [MB Free] bigint )

	insert #DriveSpaceLeft (Drive, [MB Free])
	   EXEC master.dbo.xp_fixeddrives;

	create table #DrivesWithIssue(Drive varchar(10),
								  [MB Free] bigint )

	insert into #DrivesWithIssue
	  select Drive, [MB Free] from #DriveSpaceLeft
	  where [MB Free] < 10*1024

	drop table #DriveSpaceLeft

	declare @cnt int  
	select @cnt=COUNT(1) from #DrivesWithIssue
	if (@cnt > 0)
	begin

		declare @strsubject varchar(100)
		select @strsubject='Check drive space on ' + @@SERVERNAME

		declare @tableHTML  nvarchar(max);
		set @tableHTML =
			N'<H1>Drives with less that 10GB Free  - ' + @@SERVERNAME + '</H1>' +
			N'<table border="1">' +
			N'<tr><th>Drive</th>' +
			N'<th>MB Free</th></tr>' +
			CAST ( ( SELECT td = [Drive], '',
							td = [MB Free]
					  FROM #DrivesWithIssue
					  FOR XML PATH('tr'), TYPE 
			) AS NVARCHAR(MAX) ) +
			N'</table>' ;

		 EXEC msdb.dbo.sp_send_dbmail
		 --@from_address='test@test.com',
		 @recipients='dba-info@ntsmail.ru',
		 @subject = @strsubject,
		 @body = @tableHTML,
		 @body_format = 'HTML' ,
		 @profile_name='sql-info'
	end

	drop table #DrivesWithIssue;
END
GO
PRINT N'Creating Procedure [info].[usp_dbmail_MemoryUse]...';


GO

CREATE PROCEDURE [info].[usp_dbmail_MemoryUse]
AS
BEGIN
	SET NOCOUNT ON;
	create table #MemoryInfo (
		[Total Memory MB] bigint NOT NULL,
		[Available Memory MB] bigint NOT NULL,
		[% Memory Free] decimal(5,2) NOT NULL)

	insert into #MemoryInfo
	SELECT total_physical_memory_kb/1024 as "Total Memory MB",
		   available_physical_memory_kb/1024 as "Available Memory MB",
		   available_physical_memory_kb/(total_physical_memory_kb*1.0)*100 AS "% Memory Free"
	FROM sys.dm_os_sys_memory;

	declare @memfree float  
	select @memfree=[Available Memory MB] from #MemoryInfo    
	if (@memfree < 700)
	begin

		declare @strsubject varchar(100)
		select @strsubject='Check memory usage on ' + @@SERVERNAME

		declare @tableHTML  nvarchar(max);
		set @tableHTML =
			N'<H1>Server Memory Information - ' + @@SERVERNAME +'</H1>' +
			N'<table border="1">' +
			N'<tr><th>TotalMemory MB</th><th>Available Memory MB</th>' +
			N'<th>% Memory Free</th></tr>' +
			CAST ( ( SELECT td = [Total Memory MB], '',
							td = [Available Memory MB], '',
							td = [% Memory Free]
					  FROM #MemoryInfo
					  FOR XML PATH('tr'), TYPE 
			) AS NVARCHAR(MAX) ) +
			N'</table>' ;

		 EXEC msdb.dbo.sp_send_dbmail
		 --@from_address='test@test.com',
		 @recipients='dba-info@ntsmail.ru',
		 @subject = @strsubject,
		 @body = @tableHTML,
		 @body_format = 'HTML' ,
		 @profile_name='sql-info'
	end

	drop table #MemoryInfo;
END
GO
PRINT N'Creating Procedure [info].[usp_dbmail_FailedJobs]...';


GO

CREATE PROCEDURE [info].[usp_dbmail_FailedJobs]
AS
BEGIN
	SET NOCOUNT ON;

	declare @tt float;
	--за последние 12 часов:
	declare @lastxhours smallint = 12;
	set @tt=cast(convert(varchar(8),dateadd(hour,-@lastxhours,getdate()), 112) as float)*1000000+cast(replace(convert(varchar(8), dateadd(hour,-@lastxhours,getdate()), 108),':','') as float);
	--select @tt
	IF object_Id('tempdb.dbo.#Failed_Jobs') is not null
		drop table #Failed_Jobs;
	create table #Failed_Jobs (
		[Status] [varchar](10) NOT NULL,
		[JobId] [uniqueidentifier] NULL,
		[Job Name] [varchar](100) NULL,
		[Step ID] [varchar](5) NULL,
		[Step Name] [varchar](30) NULL,
		--[Start Date Time] [varchar](30) NULL,
		[Start Date Time] [datetime] NULL,
		[Message] [nvarchar](4000) NULL)

	IF object_Id('tempdb.dbo.#Failed_Jobs_agr') is not null
		drop table #Failed_Jobs_agr;
	create table #Failed_Jobs_agr (
		[Job Fails] [int] NOT NULL,
		[Step Status] [varchar](10) NOT NULL,
		[Job Name] [varchar](100) NULL,
		[Step ID] [varchar](5) NULL,
		[Step Name] [varchar](30) NULL,
		--[Start Date Time] [varchar](30) NULL,
		[Step Fails] [int] NULL,
		[Last Start Date] [datetime] NULL,
		[Last Message] [nvarchar](4000) NULL)


	insert into #Failed_Jobs
	select DISTINCT
			'FAILED' as [Status], sjh.job_id as [JobId], cast(sj.name as varchar(100)) as "Job Name",
		   CASE WHEN sjh.step_id=0 THEN NULL ELSE cast(sjs.step_id as varchar(5)) END as "Step ID",
		   CASE WHEN sjh.step_id=0 THEN NULL ELSE cast(sjs.step_name as varchar(30)) END as "Step Name",
		   cast(REPLACE(CONVERT(varchar,convert(datetime,convert(varchar,sjh.run_date)),102),'.','-')+' '+SUBSTRING(RIGHT('000000'+CONVERT(varchar,sjh.run_time),6),1,2)+':'+SUBSTRING(RIGHT('000000'+CONVERT(varchar,sjh.run_time),6),3,2)+':'+SUBSTRING(RIGHT('000000'+CONVERT(varchar,sjh.run_time),6),5,2) as varchar(30)) 'Start Date Time',
		   sjh.message as "Message"
	from msdb.dbo.sysjobs sj
	LEFT join msdb.dbo.sysjobsteps sjs 
	 on sj.job_id = sjs.job_id
	join msdb.dbo.sysjobhistory sjh 
	 on sj.job_id = sjh.job_id and (sjs.step_id = sjh.step_id OR sjh.step_id=0)
	where sjh.run_status <> 1
		and cast(sjh.run_date as float)*1000000+sjh.run_time > @tt
		and sj.name <> '**Monitor DBMail'
	
	
	--union
	--select 'FAILED',cast(sj.name as varchar(100)) as "Job Name",
	--	   'MAIN' as "Step ID",
	--	   'MAIN' as "Step Name",
	--	   cast(REPLACE(CONVERT(varchar,convert(datetime,convert(varchar,sjh.run_date)),102),'.','-')+' '+SUBSTRING(RIGHT('000000'+CONVERT(varchar,sjh.run_time),6),1,2)+':'+SUBSTRING(RIGHT('000000'+CONVERT(varchar,sjh.run_time),6),3,2)+':'+SUBSTRING(RIGHT('000000'+CONVERT(varchar,sjh.run_time),6),5,2) as varchar(30)) 'Start Date Time',
	--	   sjh.message as "Message"
	--from msdb.dbo.sysjobs sj
	--join msdb.dbo.sysjobhistory sjh 
	-- on sj.job_id = sjh.job_id
	--where sjh.run_status <> 1 and sjh.step_id=0
	--  and cast(sjh.run_date as float)*1000000+sjh.run_time > @tt
	--	and sj.name <> '**Monitor DBMail'

	;WITH cte_01 as (
		SELECT DISTINCT 
			[Status],[JobID],[Job Name],
			dense_rank() OVER (partition by [Status],[JobID],[Step ID],[Step Name] order by [JobId], [Start Date Time],[Step ID]) as rn,
			[Step ID],[Step Name],
			[Start Date Time]
		FROM #Failed_Jobs
	)
	,cte_02 as (
		SELECT DISTINCT 
			[Status],[JobID],[Job Name],
			[Step ID],[Step Name],
			COUNT_BIG(*) OVER (partition by [Status],[JobID],[Step ID],[Step Name]) as [Step Fails],
			MAX([Start Date Time]) OVER (partition by [Status],[JobID],[Step ID],[Step Name]) as [Last Start Date],
			rn
		FROM cte_01
		WHERE [Step ID] IS NOT NULL
	)
	,cte_03 as (
		SELECT DISTINCT 
			[Status],[JobID],[Job Name],
			[Step ID],[Step Name],
			COUNT_BIG(*) OVER (partition by [Status],[JobID],[Step ID],[Step Name]) as [Job Fails],
			MAX([Start Date Time]) OVER (partition by [Status],[JobID],[Step ID],[Step Name]) as [Last Start Date],
			rn
		FROM cte_01
		WHERE [Step ID] IS NULL
	)
	
	INSERT INTO #Failed_Jobs_agr
	select DISTINCT 
		COALESCE(j.[Job Fails],0), s.[Status],s.[Job Name],s.[Step ID],s.[Step Name],s.[Step Fails], s.[Last Start Date], dt.[Message] AS [Last Message]
	from cte_02 s
	left join cte_03 j
		ON s.[JobId]=j.[JobId] and (s.rn=j.rn)
	inner join #Failed_Jobs dt
		ON s.[JobId]=dt.[JobId] and s.[Step ID]=dt.[Step ID] and s.[Last Start Date]=dt.[Start Date Time]
	--Дополнительная проверка: в уведомление попадут те Джобы, которые завершились с ошибкой больше 2 раз
	WHERE s.[Step Fails]>2
	;



	declare @cnt int  
	--select @cnt=COUNT(1) from #Failed_Jobs    
	--if (@cnt > 0)
	if exists(
		SELECT TOP 1 *
		FROM #Failed_Jobs_agr 
	)	
	begin

		declare @strsubject varchar(100)
		select @strsubject='Check the following failed jobs on ' + @@SERVERNAME

		declare @tableHTML  nvarchar(max);
		set @tableHTML =
			N'<H1>Failed Jobs Listing - ' + @@SERVERNAME +'</H1>' +
			N'<H3>in last 12 hours</H3>' +
			N'<table border="1">' +
			N'<tr><th>Job Fails</th><th>Step Fails</th><th>Job Name</th>' +
			N'<th>Step ID</th><th>Step Name</th><th>Last Start Date</th>' +
			N'<th>Last Message</th></tr>' +
			CAST ( ( SELECT td = FJ.[Job Fails], '',
							td = FJ.[Step Fails], '',
							td = FJ.[Job Name], '',
							td = FJ.[Step ID], '',
							td = FJ.[Step Name], '',
							td = FJ.[Last Start Date], '',
							td = FJ.[Last Message]
					  FROM #Failed_Jobs_agr FJ
					  ORDER BY FJ.[Step Fails] DESC
					  FOR XML PATH('tr'), TYPE 
			) AS NVARCHAR(MAX) ) +
			N'</table>' ;

		 EXEC msdb.dbo.sp_send_dbmail
		 --@from_address='test@test.com',
		 @recipients='dba-info@ntsmail.ru',
		 @subject = @strsubject,
		 @body = @tableHTML,
		 @body_format = 'HTML' ,
		 @profile_name='sql-info'
	end

	drop table #Failed_Jobs;
	drop table #Failed_Jobs_agr;
END
GO
PRINT N'Creating Procedure [info].[usp_dbmail_MissingBackups]...';


GO

CREATE PROCEDURE [info].[usp_dbmail_MissingBackups]
AS
BEGIN
	SET NOCOUNT ON;

	if object_id('tempdb.dbo.#Missing_Backups') is not null
		drop table #Missing_Backups;

	create table #Missing_Backups (
		[DB Name] [varchar](1000) NOT NULL,
		[Type] [varchar] (5) NOT NULL,
		[Last Backup] [varchar](100) NULL,
		[RecoveryModel] NVARCHAR(20),
		create_date VARCHAR(20),
		dbowner NVARCHAR(300)
		
		)

	DECLARE @T TABLE ([Database] NVARCHAR(2000), [TYPE] VARCHAR(4), [Last Backup] DATETIME, [RecoveryModel] NVARCHAR(20),create_date VARCHAR(20), dbowner NVARCHAR(300));
	INSERT INTO @T([Database],[TYPE],[Last Backup], RecoveryModel, create_date, dbowner)	
	SELECT 
		d.name AS [Database],
		CASE WHEN b.type = 'D' THEN 'FULL' ELSE 'DIFF' END as [Type],
		b.backupdate as [Last Backup],
		CAST(d.recovery_model_desc  COLLATE Cyrillic_General_CI_AS as NVARCHAR(20)) as RecoveryModel,
		CONVERT(VARCHAR(20),d.create_date,120) as create_date,
		suser_sname(d.owner_sid) as DBOwner
	FROM sys.databases d
	LEFT JOIN (SELECT database_name,type,MAX(backup_finish_date) backupdate 
				FROM msdb.dbo.backupset
				WHERE type IN ('D','I')
				GROUP BY database_name,type
				) b
		ON d.name=b.database_name
	WHERE d.name <> 'tempdb' and d.state_desc='online';

	;with cte_src01 as(
		SELECT Mx.[Database],CASE WHEN Det.[Type] IS NULL THEN 'FULL' ELSE Det.[Type] END [Type],
			   ISNULL(CONVERT(VARCHAR,Mx.[Last Backup],120),'NEVER') AS [Last Backup],
			   Mx.RecoveryModel,Mx.create_date,Mx.dbowner
		FROM 
			(SELECT [Database], MAX([Last Backup]) [Last Backup],RecoveryModel,create_date, dbowner  FROM @T GROUP BY [Database],RecoveryModel,create_date, dbowner) AS Mx
		LEFT JOIN 
			@T as Det
		ON Mx.[Database]=Det.[Database]	AND Mx.[Last Backup]=Det.[Last Backup]
		WHERE (Mx.[Last Backup] IS NULL OR Det.[Last Backup] < getdate()-8)	--для Full/Diff бэкапов 8 дней.
		UNION ALL
		SELECT d.name AS [Database],'Log' as [Type],
			   ISNULL(CONVERT(VARCHAR,b.backupdate,120),'NEVER') AS [Last Backup],
			   CAST(d.recovery_model_desc  COLLATE Cyrillic_General_CI_AS as NVARCHAR(20)) as RecoveryModel,
				CONVERT(VARCHAR(20),d.create_date,120) AS create_date,
				suser_sname(d.owner_sid) as dbowner
		FROM sys.databases d
		LEFT JOIN (SELECT database_name,type,MAX(backup_finish_date) backupdate 
				   FROM msdb.dbo.backupset
				   WHERE type LIKE 'L'
				   GROUP BY database_name,type
				  ) b on d.name=b.database_name
		WHERE recovery_model = 1
		  AND (backupdate IS NULL OR backupdate < getdate()-1)	--для бэкапов Логов 1 день.
		  AND d.name NOT IN ('tempdb','model')
		  AND d.state_desc='online'
	)
	insert into #Missing_Backups([DB Name],[Type],[Last Backup], RecoveryModel, create_date, dbowner)
	SELECT mb.[Database],mb.[Type],mb.[Last Backup], mb.RecoveryModel, mb.create_date, mb.dbowner
	FROM cte_src01 mb
	--Дополнительно перед отправкой сверим список исключений в базе sputnik.
	LEFT JOIN sputnik.backups.NoBackupList NBL
	ON mb.[Database]=NBL.DBName
		AND (mb.[Type]=NBL.TypeBackup OR NBL.TypeBackup IS NULL)
		AND (NBL.ExpDate>cast(getdate() as date) OR NBL.ExpDate IS NULL)
	WHERE 
		NBL.DBName IS NULL	  
	;
	--select * from #Missing_Backups;
	declare @cnt int  
	select @cnt=COUNT(1) from #Missing_Backups    
	if (@cnt > 0)
	begin

		declare @strsubject varchar(100)
		select @strsubject='Check for missing backups on ' + @@SERVERNAME

		declare @tableHTML  nvarchar(max);
		set @tableHTML =
			N'<H1>Databases Missing Backups Listing - ' + @@SERVERNAME +'</H1>' +
			N'<table border="1">' +
			N'<tr><th>DB Name&nbsp;&nbsp;&nbsp;</th><th>Type&nbsp;&nbsp;&nbsp;</th>' +
			N'<th>Last Backup&nbsp;&nbsp;&nbsp;</th>' +
			N'<th>Recovery_Model&nbsp;&nbsp;&nbsp;</th>' +
			N'<th>create_date&nbsp;&nbsp;&nbsp;</th>' +
			N'<th>DB Owner&nbsp;&nbsp;&nbsp;</th></tr>' +
			CAST ( ( SELECT td = [DB Name], '',
							td = [Type], '',
							td = [Last Backup], '',
							td = RecoveryModel, '',
							td = create_date, '',
							td = dbowner
					  FROM #Missing_Backups mb
					  FOR XML PATH('tr'), TYPE 
			) AS NVARCHAR(MAX) ) +
			N'</table>' ;

		 EXEC msdb.dbo.sp_send_dbmail
		 --@from_address='test@test.com',
		 @recipients='dba-info@ntsmail.ru',
		 @subject = @strsubject,
		 @body = @tableHTML,
		 @body_format = 'HTML' ,
		 @profile_name='sql-info'
	end

	drop table #Missing_Backups
END
GO
PRINT N'Creating Procedure [info].[sp_who3]...';


GO

/* =============================================
-- Author:		Андрей Иванов (sqland1c)
-- Create date: 28.11.2013
-- Description:	Эта процедура возвращает зависшие активные процессы. Параметр @busy_minutes - позволяет задать в минутах
--				сколько висит процесс (в результатах будут только с этим временем и больше!)
-- Update:
--				1.1 ( 28.11.2013) Добавлен параметр @blocks. По умолчанию = 0.
--			    Если @blocks=1 то процедура выполнит запрос по блокирующим друг друга процессам.				
--				1.2 ( 29.11.2013) Добавлен ServerTime в результаты.
--				1.3 ( 23.12.2013) Добавлен параметр @zabbix для мониторинга за долго выполняющимися процессами через систему zabbix!
				1.35 (25.12.2013) Для отчёта Забикса добавлено текстовое поле ForZabbix со значением BusyQuery (чтобы Забикс мог легко определить 
				что есть долгоиграющие запросы!
				1.40 (03.03.2015) Совершенно новый метод для получения информации о блокировщиках (основан на новом скрипте). 
				Будет использован для сбора данных о блокировщиках в новую схему awr!
				2.00 (20.05.2015) Совершенно новый метод для получения информации об активных запросах. Теперь результат подобен процедуре sp_whoisactive.
				Также как и sp_whoisactive выводит информацию о НЕактивных запросах (status=sleeping), у которых Open_Tran>0.
				Будет использован для сбора данных об активных запросах в новую схему awr!
				2.10 (25.05.2015) Для метода получения информации по блокировщикам реализован новый метод сбора!
				Теперь этот сбор полностью аналогичен сбору об активных запросах. Причем Текст запроса сохраняются также в отдельную таблицу!
				Чтобы выполнить сбор информации по блокировщикам нужно задать параметры @blocks и @collect_sql.
				2.11 (18.06.2015) Доработана информация по блокировщикам: добавлено новое поле в результаты - trn_iso_lvl - параметр уровень изоляции транзакции!
				2.12 (24.06.2015) Алгоритм сбора информации "Медленные запросы" для Заббикса перенесен из начала модуля в новый алгоритм сбора по запросам.
				Также добавлено исключение для служебного диагностического запроса в AlwaysOn: sp_server_diagnostics
				2.15 (19.07.2015) Добавлен сбор информации о текущей выполняемой инструкции запроса с помощью полей statement_start_offset и statement_end_offset.
				Теперь собирается и сохраняется информация о всем пакете запросов и о конкретном текущем запросе (как в sp_whoisactive).
				Если sp_who3 выполняется в оперативном режиме (без сбора) то сразу высчитывается текущая инструкция в столбце [Exec_Statement].
				2.17 (19.07.2015) Добавлен сбор информации об использовании tempdb запросами. Это 4 новых столбца:
				tempdb_current_query - используемый объем страниц для текущего запроса, tempdb_allocation_query - весь объем страниц выделененный для текущего запроса (без учета освобожденных страниц),
				tempdb_current_session - используемый объем страниц для текущего сеанса, tempdb_allocation_session - весь объем страниц выделененный для текущего сеанса (без учета освобожденных страниц).
				2.18 (04.08.2015) Добавлено исключение для диагностического запроса AlwaysON от Windows-Кластера SP_SERVER_DIAGNOSTICS
				2.20 (24.08.2015) Добавлен новый параметр @get_count - в результате возвращает 1 столбец - кол-во найденных строк (блокировок или активных сессий).
				2.21 (26.08.2015) Небольшое исправление в исключении диагностического запроса AlwaysOn.
				2.215 (01.12.2017) Исправление в алгоритме выборки для zabbix - теперь разный порог для разных сервисов.
				2.221 (15.02.2018) Изменён алгоритм для получения SQLHandle - теперь получаем "SQLHashID", алгоритм следующий: берём HASH от начала и от конца текста запроса(из-за ограничений входного параметра для функции HASHBYTES) + берём длину текста запроса. И всё это хэшируем. Это оптимизация хранения текстов запросов: когда для 1-го текста запроса получаем несколько разных sqlhandle.
				2.222 (23.03.2018) Добавлен новый параметр @only_sleep_tran - если включен, то будет отобраны только зависшие сессии с открытыми транзакциями. По умолчанию выключен.
				2.251 (17.05.2021) fix for datediff error: The datediff function resulted in an overflow																																		 																							
-- ============================================= */
CREATE PROCEDURE info.sp_who3 
	@busy_minutes int = NULL, @blocks bit = 0 , @zabbix bit = 0,
	@collect_sql bit = 0, @get_count bit = 0, @only_sleep_tran bit=0
AS
BEGIN
	SET NOCOUNT ON;
	declare @time datetime;
						 
																						
	/*
		Старый алгоритм сбора для Заббикса "Медленные запросы"!
	*/
	--set @time=getdate();
	--if @zabbix=1
	--begin
	--	select 'BusyQuery' as [ForZabbix], S.login_name, Q.SPID, Q.command, Q.wait_type, datediff(hour,start_time,@time) as RunningHours
	--	From
	--	(
	--		select session_id as SPID,DB_NAME(database_id) as DB, start_time,status,command,blocking_session_id,
	--			wait_type,wait_time,last_wait_type,wait_resource,
	--			cpu_time,reads,writes,logical_reads,row_count,query_hash
	--		from sys.dm_exec_requests
	--		where status<>'background' 
	--		and command<>'TASK MANAGER'
	--		and datediff(hour,start_time,@time) >= @busy_hours
	--	)Q
	--	inner join sys.dm_exec_sessions S
	--		on Q.SPID=S.session_id
	--	order by start_time
	--end
	--else 
	if @blocks=1
	BEGIN
		/*
			Новый метод! Старый ниже закомментирован!
			Быстрый сбор данных о заблокированных: кто и кем заблокирован!
			Работает на основе нескольких DMV.
			Выдаёт данные только если есть заблокированные
		*/
		if object_id('tempdb..#blk_collect') is not null
			drop table #blk_collect;
		SELECT 
			blk_rs.session_id as spid, blk_rs.command, blk_rs.[status], blk_rs.start_time, blk_rs.blocking_session_id as BlkBy, blk_rs.wait_type, blk_rs.wait_time, blk_rs.wait_resource, 
			blk_rs.[TEXT] as [SQLTEXT], 
			HASHBYTES('SHA2_256',(HASHBYTES('SHA2_256',LEFT(blk_rs.[TEXT],4000))+HASHBYTES('SHA2_256',RIGHT(blk_rs.[TEXT],4000))+cast(LEN(blk_rs.[TEXT]) as varbinary(30)))) AS [SQLHandle],
			blk_rs.DB, dm_ss.host_name as Host, dm_ss.login_name as [Login], dm_ss.program_name as Program, dm_ss.host_process_id as Host_pid,
			CASE 
				WHEN blk_rs.transaction_isolation_level IS NULL then dm_ss.transaction_isolation_level
				WHEN blk_rs.transaction_isolation_level = 0 then dm_ss.transaction_isolation_level
				ELSE blk_rs.transaction_isolation_level 
			END AS trn_iso_lvl,
			statement_start, statement_end
		INTO #blk_collect
		FROM
		(
			--Заблокированные (ожидающие)
			SELECT session_id, command, [status], start_time, blocking_session_id, wait_type, wait_time, wait_resource, DB_NAME(database_id) DB, t.TEXT, sql_handle as SQLHandle, transaction_isolation_level,
				statement_start_offset as statement_start, statement_end_offset as statement_end
			FROM sys.dm_exec_requests 
			CROSS apply sys.dm_exec_sql_text(sql_handle) AS t
			WHERE blocking_session_id > 0
			UNION
			--Блокировщики (активные)
			SELECT session_id, command, [status], start_time, NULL, wait_type, wait_time, wait_resource, DB_NAME(database_id) DB, t.TEXT, sql_handle as SQLHandle, transaction_isolation_level,
				statement_start_offset as statement_start, statement_end_offset as statement_end
			FROM sys.dm_exec_requests 
			CROSS apply sys.dm_exec_sql_text(sql_handle) AS t
			WHERE session_id IN (SELECT blocking_session_id 
								FROM sys.dm_exec_requests 
								WHERE blocking_session_id > 0)
					AND blocking_session_id=0
					AND (@only_sleep_tran=0)
			UNION
			--Блокировщики (зависшие)
			SELECT session_id, NULL, 'sleeping', NULL, NULL, NULL, NULL, NULL, NULL as DB, t.TEXT, most_recent_sql_handle as SQLHandle, NULL as transaction_isolation_level,
				NULL as statement_start, NULL as statement_end
			FROM sys.dm_exec_connections 
			CROSS apply sys.dm_exec_sql_text(most_recent_sql_handle) AS t
			WHERE session_id IN (SELECT blocking_session_id 
								FROM sys.dm_exec_requests 
								WHERE blocking_session_id not in (select session_id from sys.dm_exec_requests))
		) blk_rs
		LEFT JOIN sys.dm_exec_sessions as dm_ss
			ON blk_rs.session_id=dm_ss.session_id;

		IF (@collect_sql=0)
		BEGIN
			IF (@get_count=0)
				SELECT spid, command, [status], start_time, BlkBy, wait_type, wait_time, wait_resource, [SQLTEXT],
					CASE WHEN [statement_start] > 0 THEN 
						CASE [statement_end] 
							WHEN -1 THEN SUBSTRING([SQLTEXT], ([statement_start]/2) + 1, 2147483647)
							ELSE SUBSTRING([SQLTEXT], ([statement_start]/2) + 1, ([statement_end] - [statement_start])/2)  
						END 
					ELSE CASE [statement_end] 
							WHEN -1 THEN RTRIM(LTRIM([SQLTEXT])) 
							ELSE LEFT([SQLTEXT], ([statement_end]/2) +1) 
						END 
					END AS [Exec_Statement],			
					/*[SQLHandle],*/	DB, Host, [Login], Program, Host_pid, trn_iso_lvl
				FROM #blk_collect;
			ELSE
				SELECT Count_Big(*) as cnt
				FROM #blk_collect
				WHERE BlkBy is Not null and BlkBy<>0;

		END	
		ELSE
		BEGIN
			SET @time=GETDATE();
			/* Сбор данных об блокировщиках в две таблицы sputnik.awr.blk_handle_collect и sputnik.awr.sql_text_collect
				blk_handle_collect - содержит всю информацию о блокировщиках и блокируемых, кроме текста запроса.
				sql_text_collect - содержит текст запроса. */
			IF OBJECT_ID('sputnik.awr.blk_handle_collect') IS NOT NULL AND OBJECT_ID('sputnik.awr.sql_text_collect') IS NOT NULL 
			BEGIN
				SET XACT_ABORT ON;
				BEGIN TRAN
					INSERT INTO [awr].[blk_handle_collect]
						(
							[tt], SPID, command, [status], start_time, BlkBy, wait_type, wait_time, wait_resource, [SQLHandle],	DB, Host, [Login], Program, Host_pid, trn_iso_lvl,
							[statement_start],[statement_end]		
						)
					SELECT 
						@time as [tt], SPID, command, [status], start_time, BlkBy, wait_type, wait_time, wait_resource, 
							[SQLHandle], 
						DB, Host, [Login], Program, Host_pid, trn_iso_lvl,
						[statement_start],[statement_end]
					FROM #blk_collect;
					
					MERGE 
						[awr].[sql_text_collect] as target_table
						USING (
								SELECT  DISTINCT @time,[SQLHandle], [SQLText], COUNT(*) OVER (PARTITION BY [SQLHandle])
								FROM	#blk_collect
						) AS source_table ([tt],[SQLHandle], [SQLText], [NumLocks])
						ON (target_table.[SQLHandle]=source_table.[SQLHandle])
						WHEN NOT MATCHED THEN
							INSERT([tt],[SQLHandle], [SQLText], [NumLocks])
							VALUES(source_table.[tt],source_table.[SQLHandle],source_table.[SQLText],source_table.[NumLocks])
						WHEN MATCHED THEN
							UPDATE 
								SET target_table.[tt] = source_table.[tt],
									target_table.[NumLocks] += source_table.[NumLocks]
					;
				COMMIT;
				SET XACT_ABORT OFF;
			END
			ELSE
				PRINT('Сбор данных невозможен: таблица awr.blk_handle_collect или таблица awr.sql_text_collect не определена!');
		END
		
		--Старый метод:
		--select 
		--	BS.host_name as BlockHost, BS.login_name as BlockLogin,Q.blocking_session_id as SPID_Block, BInfo.start_time as BlockStart,
		--	BInfo.status as BlockStatus, BInfo.command as BlockCommand,
		--	S.host_name as WaitHost,S.login_name as WaitLogin,Q.session_id as WaitSPID,DB_NAME(Q.database_id) as DB,
		--	Q.start_time as WaitStart, Q.status as WaitStatus, Q.command as WaitCommand

		--from sys.dm_exec_requests Q
		--inner join sys.dm_exec_sessions S
		--	on Q.session_id=S.session_id
		--left join sys.dm_exec_requests BInfo
		--	on Q.blocking_session_id=BInfo.session_id
		--left join sys.dm_exec_sessions BS
		--	on BInfo.session_id=BS.session_id							
		--where
		--	Q.blocking_session_id<>0
	END
	else
	BEGIN
		/*-------Старый Метод (до версии 2.00)
		select getdate() as ServerTime,S.host_name,S.login_name,S.login_time,Q.*
		From
		(
			select session_id as SPID,DB_NAME(database_id) as DB, start_time,status,command,blocking_session_id,
				wait_type,wait_time,last_wait_type,wait_resource,
				cpu_time,reads,writes,logical_reads,row_count,query_hash
			from sys.dm_exec_requests
			where status<>'sleeping' 
			and status<>'background' 
			and datediff(minute,start_time,@time) >= @busy_minutes
		)Q
		inner join sys.dm_exec_sessions S
			on Q.SPID=S.session_id
		order by start_time
		*/
		
		/* Новый метод (начиная с версии 2.00)! Результаты похожи на sp_whoisactive 
			Будет работать только на SQL Server 2012 и старше (т.к. используется новые возможности T-SQL).	
		*/
		if object_id('tempdb..#qinfo_collect') is not null
			drop table #qinfo_collect;

		  
						  
		select  S.host_name as [Host],S.program_name as Program,
			IIF(S.login_name='',(select name from sys.server_principals where [sid]=S.Security_id),S.login_name) as [Login],
				  
			S.login_time,  S.open_transaction_count as Open_Tran,
		Q.*
		into #qinfo_collect
		From
		(
			select q.session_id as SPID,DB_NAME(q.database_id) as DB, start_time,status,
				command,blocking_session_id as blk_by, percent_complete as perc_complete, 
				wait_type,wait_time,wait_resource,
				cast(cast(total_elapsed_time as decimal(15,3))/1000.000 as decimal(15,3)) as RunTime_sec,
				cast(cast(CPU_Time as decimal(14,2))/1000.000 as decimal(15,3)) as CPU_sec,
				cast(cast(granted_query_memory as decimal(14,2))/128.00 as decimal(14,2)) as MemoryMb,reads as IO_Reads,writes as IO_Writes,Logical_Reads,row_count as [RowCount],
				st.text as SQLText, 
				HASHBYTES('SHA2_256',(HASHBYTES('SHA2_256',LEFT(st.[TEXT],4000))+HASHBYTES('SHA2_256',RIGHT(st.[TEXT],4000))+cast(LEN(st.[TEXT]) as varbinary(30)))) AS [SQLHandle], 
				query_hash as SQLHash,
				q.statement_start_offset as [statement_start] , q.statement_end_offset as [statement_end],
				SUM(COALESCE(tsu.user_objects_alloc_page_count,0)+COALESCE(tsu.internal_objects_alloc_page_count,0)-COALESCE(tsu.user_objects_dealloc_page_count,0)-COALESCE(tsu.internal_objects_dealloc_page_count,0)) over (partition by tsu.session_id,tsu.request_id) as tempdb_current_query,
				SUM(COALESCE(tsu.user_objects_alloc_page_count,0)+COALESCE(tsu.internal_objects_alloc_page_count,0)) over (partition by tsu.session_id,tsu.request_id) as tempdb_allocation_query,
				SUM(COALESCE(ssu.user_objects_alloc_page_count,0)+COALESCE(ssu.internal_objects_alloc_page_count,0)-COALESCE(ssu.user_objects_dealloc_page_count,0)-COALESCE(ssu.internal_objects_dealloc_page_count,0)) over (partition by ssu.session_id) as tempdb_current_session,
				SUM(COALESCE(ssu.user_objects_alloc_page_count,0)+COALESCE(ssu.internal_objects_alloc_page_count,0)) over (partition by ssu.session_id) as tempdb_allocation_session
			from sys.dm_exec_requests q
			CROSS APPLY sys.dm_exec_sql_text(q.sql_handle) AS st
			left join sys.dm_db_task_space_usage tsu
				on q.request_id=tsu.request_id and q.session_id=tsu.session_id
			left join sys.dm_db_session_space_usage ssu
				on q.session_id=ssu.session_id
			where [status] NOT IN('background'/*,'sleeping'*/)
			and q.session_id<>@@SPID 
		)Q
		inner join sys.dm_exec_sessions S on Q.SPID=S.session_id
		WHERE
			--Исключаем диагностический запрос для AlwaysOn от Windows-Кластера
			(S.program_name <> 'Microsoft® Windows® Operating System' AND Q.wait_type<>'SP_SERVER_DIAGNOSTICS_SLEEP' OR Q.wait_type IS NULL OR S.program_name IS NULL)
			AND (@only_sleep_tran=0)
		UNION
		select s.host_name as [Host], s.program_name as [Program],  
			IIF(S.login_name='',(select name from sys.server_principals where [sid]=S.Security_id),S.login_name) as [Login], 
			s.login_time, s.open_transaction_count as Open_Tran,
			s.session_id as SPID, DB_NAME(s.database_id) as DB, s.last_request_start_time as start_time,  s.[status],  
			NULL as command, NULL as blk_by, NULL as perc_complete, 
			'BUSY_SLEEPING_TASK' as wait_type, NULL as wait_time, 'Open_Tran>0' wait_resource, 
			cast(DATEDIFF(SECOND,s.last_request_start_time,s.last_request_end_time) as decimal(15,3)) as RunTime_sec, 
			cast(cast(s.CPU_Time as decimal(14,2))/1000.000 as decimal(15,3)) as CPU_sec,
			cast(cast(s.memory_usage as decimal(14,2))/128.00 as decimal(14,2)) as MemoryMb, s.reads as IO_Reads,s.writes as IO_Writes,s.Logical_Reads,s.row_count as [RowCount],
																		 
			sqltext.text as SQLText,
			HASHBYTES('SHA2_256',(HASHBYTES('SHA2_256',LEFT(sqltext.[TEXT],4000))+HASHBYTES('SHA2_256',RIGHT(sqltext.[TEXT],4000))+cast(LEN(sqltext.[TEXT]) as varbinary(30)))) AS [SQLHandle],
			NULL as SQLHash,
			NULL as [statement_start] , NULL as [statement_end],
			NULL as tempdb_current_query, NULL as tempdb_allocation_query,
			SUM(COALESCE(ssu.user_objects_alloc_page_count,0)+COALESCE(ssu.internal_objects_alloc_page_count,0)-COALESCE(ssu.user_objects_dealloc_page_count,0)-COALESCE(ssu.internal_objects_dealloc_page_count,0)) over (partition by ssu.session_id) as tempdb_current_session,
			SUM(COALESCE(ssu.user_objects_alloc_page_count,0)+COALESCE(ssu.internal_objects_alloc_page_count,0)) over (partition by ssu.session_id) as tempdb_allocation_session
		from sys.dm_exec_sessions s
		inner join sys.dm_exec_connections c on c.session_id=s.session_id
		cross apply sys.dm_exec_sql_text(c.most_recent_sql_handle) as sqltext
		left join sys.dm_db_session_space_usage ssu
			on s.session_id=ssu.session_id
		where (s.open_transaction_count>0 and s.[status]='sleeping');

		SET @time=GETDATE();
		IF @zabbix=1
		BEGIN
			/*
				Новый алгоритм сбора для Заббикса "Медленные запросы"!
			*/
			DECLARE
				@MachineName varchar(300)=CAST(SERVERPROPERTY('MachineName') as varchar(128)),
				@InstanceName varchar(300)=COALESCE(CAST(SERVERPROPERTY('InstanceName') as varchar(128)),''),
				@SQLServer varchar(300),
				@busy_minutes_zabbix smallint;;
			SET @SQLServer=LOWER(@MachineName+CASE WHEN @InstanceName > '' THEN '\' ELSE '' END + @InstanceName);
			SELECT @busy_minutes_zabbix=CASE
				WHEN CHARINDEX('-bi-',@SQLServer)>0 THEN 8*60
				WHEN EXISTS (select top 1 database_id from sys.databases where name IN ('pegasus2008ms','pegasus2008bb')) THEN 1*60
				WHEN (EXISTS (select top 1 database_id from sys.databases where name like 'pegasus2008%') AND CHARINDEX('dev',@SQLServer)=0 AND CHARINDEX('test',@SQLServer)=0 AND CHARINDEX('qc',@SQLServer)=0) THEN 2*60
				ELSE 4*60
			END;
			--SELECT 'BusyQuery' as ForZabbix, [Login] as login_name, SPID, command, wait_type, datediff(hour,start_time,@time) as RunningHours
			SELECT TOP 1 CASE WHEN Count_Big(*)>=1 THEN 'BusyQuery' ELSE 'Its OK' END as ForZabbix, Count_Big(*) as cnt, sputnik.info.uf_FormatTime(SUM(datediff(second,start_time,@time))) as SumDuration, sputnik.info.uf_FormatTime(MAX(datediff(second,start_time,@time))) as MaxDuration
			FROM #qinfo_collect
			WHERE datediff(minute,start_time,@time) >= @busy_minutes_zabbix
				and (wait_type<>'SP_SERVER_DIAGNOSTICS_SLEEP' OR wait_type IS NULL)
		END			
		ELSE IF @collect_sql=0
			IF @get_count=0
				SELECT 
					/*@time as [tt],*/ SPID, SQLText,
					CASE WHEN [statement_start] > 0 THEN 
						CASE [statement_end] 
							WHEN -1 THEN SUBSTRING([SQLTEXT], ([statement_start]/2) + 1, 2147483647)
							ELSE SUBSTRING([SQLTEXT], ([statement_start]/2) + 1, ([statement_end] - [statement_start])/2)  
						END 
					ELSE CASE [statement_end] 
							WHEN -1 THEN RTRIM(LTRIM([SQLTEXT])) 
							ELSE LEFT([SQLTEXT], ([statement_end]/2) +1) 
						END 
					END AS [Exec_Statement],
	--CAST('<?query --
	--'+SQLText+'
	----?>' as xml) as SQLText, 
					[Host], [Program],  [Login], login_time, [Open_Tran],
					DB, [start_time],  [status], command, blk_by, perc_complete, 
					wait_type, IIF(wait_type='BUSY_SLEEPING_TASK',cast(DATEDIFF(SECOND,[start_time],@time) as bigint)*1000,wait_time) as wait_time, wait_resource, 
					RunTime_sec, CPU_sec,MemoryMb, IO_Reads, IO_Writes, Logical_Reads, [RowCount],
					tempdb_current_query, tempdb_allocation_query, tempdb_current_session, tempdb_allocation_session
					/*, SQLHandle, SQLHash*/
				FROM #qinfo_collect
				WHERE ((wait_type='BUSY_SLEEPING_TASK' and DATEDIFF(SECOND,[start_time],@time)>=1) OR wait_type<>'BUSY_SLEEPING_TASK' OR wait_type IS NULL)
					AND (@busy_minutes IS NULL OR @busy_minutes=0 OR DATEDIFF(MINUTE,[start_time],@time)>=@busy_minutes)
											   
				ORDER BY [start_time];
			ELSE
				SELECT Count_Big(*) as cnt
				FROM #qinfo_collect
				WHERE ((wait_type='BUSY_SLEEPING_TASK' and DATEDIFF(SECOND,[start_time],@time)>=1) OR wait_type<>'BUSY_SLEEPING_TASK' OR wait_type IS NULL)
					AND (@busy_minutes IS NULL OR @busy_minutes=0 OR DATEDIFF(MINUTE,[start_time],@time)>=@busy_minutes);	
											   
	   
		ELSE 
		BEGIN
			/* Сбор данных об активных запросах в две таблицы sputnik.awr.sql_handle_collect и sputnik.awr.sql_text_collect
				sql_handle_collect - содержит всю информацию об активных запросах,кроме текста запроса.
				sql_text_collect - содержит текст запроса. */
			IF OBJECT_ID('sputnik.awr.sql_handle_collect') IS NOT NULL AND OBJECT_ID('sputnik.awr.sql_text_collect') IS NOT NULL 
			BEGIN
				SET XACT_ABORT ON;
				BEGIN TRAN
					INSERT INTO [awr].[sql_handle_collect]
						(
							[tt], [Host], [Program],  [Login], login_time, [Open_Tran],
							SPID, DB, [start_time],  [status], command, blk_by, perc_complete, 
							wait_type, wait_time, wait_resource, 
							RunTime_sec, CPU_sec,MemoryMb, IO_Reads, IO_Writes, Logical_Reads, [RowCount],
							[SQLHandle], [statement_start], [statement_end],
							tempdb_current_query, tempdb_allocation_query, tempdb_current_session, tempdb_allocation_session			
						)
					SELECT 
						@time as [tt], [Host], [Program],  [Login], login_time, [Open_Tran],
						SPID, DB, [start_time],  [status], command, blk_by, perc_complete, 
						wait_type, IIF(wait_type='BUSY_SLEEPING_TASK',cast(DATEDIFF(SECOND,[start_time],@time) as bigint)*1000,wait_time) as wait_time, wait_resource, 
						RunTime_sec, CPU_sec,MemoryMb, IO_Reads, IO_Writes, Logical_Reads, [RowCount],
						SQLHandle, [statement_start], [statement_end], 
						tempdb_current_query, tempdb_allocation_query, tempdb_current_session, tempdb_allocation_session
					FROM #qinfo_collect
					WHERE ((wait_type='BUSY_SLEEPING_TASK' and DATEDIFF(SECOND,[start_time],@time)>=1) OR wait_type<>'BUSY_SLEEPING_TASK' OR wait_type IS NULL);
					
					MERGE 
						[awr].[sql_text_collect] as target_table
						USING (
								SELECT  DISTINCT @time,[SQLHandle], [SQLText], COUNT(*) OVER (PARTITION BY [SQLHandle])
								FROM	#qinfo_collect
								WHERE ((wait_type='BUSY_SLEEPING_TASK' and DATEDIFF(SECOND,[start_time],@time)>=1) OR wait_type<>'BUSY_SLEEPING_TASK' OR wait_type IS NULL)
						) AS source_table ([tt],[SQLHandle], [SQLText], [NumRuns])
						ON (target_table.[SQLHandle]=source_table.[SQLHandle])
						WHEN NOT MATCHED THEN
							INSERT([tt],[SQLHandle], [SQLText], [NumRuns])
							VALUES(source_table.[tt],source_table.[SQLHandle],source_table.[SQLText],source_table.[NumRuns])
						WHEN MATCHED THEN
							UPDATE 
								SET target_table.[tt] = source_table.[tt],
									target_table.[NumRuns] += source_table.[NumRuns]
					;
				COMMIT;
				SET XACT_ABORT OFF;
			END
			ELSE
				PRINT('Сбор данных невозможен: таблица awr.sql_handle_collect или таблица awr.sql_text_collect не определена!');
		END
	END
END
GO
PRINT N'Creating Procedure [lse].[usp_RunRolling]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 04.08.2014 (1.0)
	-- Description: Эта процедура используется как часть модуля lse - Log Shipping Easy.
					Воспроизводит (накатывает) бэкапы логов на конкретную целевую БД. Непосредственное восстановление происходит через ХП [usp_RestoreDB_simple].

	-- Update:		05.08.2014 (1.1)
					Оптимизирован алгоритм восстановления через процедуру usp_RestoreDB_simple. Теперь при восстановления БД 
					используется новый параметр @NoFileList=1, который говорит о том, что все данные о файлах целевой БД будут получены 
					из системного представления sys.master_files, а не из бэкапов. Это должно ускорить восстановление каждого бэкапа!
				
					07.08.2014 (1.11) Добавлен новый параметр @pp - если задан, значит процесс запущен в многопоточном режиме через модуль pp.
					В этом случае нужно выводить как можно меньше сообщений пользователю!				

					19.08.2014 (1.2) Новый параметр @Maxi, который регулирует количество бэкапов логов обрабатываемых за 1 сеанс.
					По умолчанию 8. Для того, чтобы избежать высокой и постоянной нагрузки на сервере БД.

					18.03.2015 (1.23) Добавлен новая переменная @StandBy_File - для поддержки режима STANDBY (read-only) для восстанавливаемой БД.
					Это полный путь к файлу отката standby. Соответственно в таблице sputnik.lse.TargetConfig должен быть новый столбец StandBy_File.

					21.10.2015 (1.25) Добавлена дополнительная проверка и защита - если файл бэкапа не обнаружен в каталоге Копий, то 
					вызывается его повторное копирование.

					15.12.2015 (1.27) При накате логов, если происходит ошибка нужно вернуть базу в режим MULTI_USER!
					Также в этот режим база возвращается в самом конце успешного восстановления.
					Чтобы не было включение MULTI_USER после каждого наката лога используется параметр @NoSetMultiUser.

					25.07.2016 (1.28) Новый параметр @MoveLogFilesTo - теперь файлы логов можно расположить на отдельным диске.

					10.09.2016 (1.29) Исправлен алгоритм оптимизации при включении параметра Standby - теперь этот параметр
					будет включен только при накате последнего бэкапа лога. Также исправлен алгоритм при передаче параметра
					@NoSetMultiUser.

					12.03.2018 (1.305) 
					1.Параметр @Maxi: значение по умолчанию увеличено до 15. 
					2.Для определения правильного имени сервера MSSQL теперь используется процедура info.usp_getHostname		
	-- ============================================= */
	CREATE PROCEDURE [lse].[usp_RunRolling]  
		@ConfigID int,
		@BackupID int,
		@MoveFilesTo nvarchar(800),
		@MoveLogFilesTo nvarchar(800),
		@pp bit = 0,
		@Maxi smallint=15
	AS
		SET NOCOUNT ON;
		DECLARE @LocalServer NVARCHAR(510);
		exec sputnik.info.usp_GetHostname @Servername=@LocalServer OUT;
		--Получаем настройки для конкретной целевой БД из таблицы настроек lse
		declare @ServerSource nvarchar(300), @DBNameSource nvarchar(300), @DBNameTarget nvarchar(300), @FromCopy bit, @CatalogFilesDB nvarchar(800), @CatalogLogFiles nvarchar(800), @StandBy_File nvarchar(500)=null,@user_access_desc nvarchar(50), @state_desc nvarchar(100);
		select  @ServerSource=ServerSource, @DBNameSource=DBNameSource, @DBNameTarget=DBNameTarget, @FromCopy=FromCopy, @CatalogFilesDB=CatalogFilesDB, @CatalogLogFiles=CatalogLogFiles, @StandBy_File=StandBy_File
		from sputnik.lse.TargetConfig 
		where ID=@ConfigID AND [Suspend]=0 AND [InitDate] IS NOT NULL;

		--Получаем цепочку бэкапов логов для наката!
		DECLARE @ChainBack TABLE (BackupFile NVARCHAR(800), BackupType VARCHAR(4), ID INT, BackupDate DATETIME2(2));	
		IF @ServerSource IS NULL OR @ServerSource=@LocalServer
			INSERT INTO @ChainBack (BackupFile, BackupType, ID, BackupDate)
				EXEC sputnik.info.usp_GetChainLogs @DBName=@DBNameSource, @BackupFullID=null, @FilterBackupID=@BackupID, @ToDate=null, @fromcopy=@fromcopy;
		ELSE
		BEGIN
			DECLARE @strP VARCHAR(300);
			SET @strP='@ToDate=null, @BackupFullID=null, @FilterBackupID='+CAST(@BackupID AS NVARCHAR(40))+', @fromcopy='+CAST(@fromcopy AS VARCHAR(1));
			INSERT INTO @ChainBack (BackupFile, BackupType, ID, BackupDate)
				EXEC ('	SELECT *
						FROM OPENQUERY(['+@ServerSource+'], '' EXEC sputnik.info.usp_GetChainLogs @DBName=N'''''+@DBNameSource+''''','+@strP+';'')
					 ');
		END
		--Восстановление из полученной цепочки бэкапов.
		declare @str nvarchar(800);
		DECLARE @BF nvarchar(800), @BT varchar(4), @RestoreStart datetime2(2), @BackupLogID int, @CheckFile bit, @BackupDate datetime2(2);
		DECLARE RE CURSOR FOR
			SELECT TOP (@Maxi) BackupFile, BackupType, ID, sputnik.info.uf_CheckFile(BackupFile) as CheckFile, BackupDate
			FROM @ChainBack
			--ORDER BY ID;
		OPEN RE;
		declare @cur_cnt int, @cur_i int = 1;
		SET @cur_cnt=@@CURSOR_ROWS;
		FETCH NEXT FROM RE INTO @BF, @BT, @BackupLogID, @CheckFile, @BackupDate;
		WHILE @@FETCH_STATUS=0
		BEGIN
		
			if @CheckFile=0
			begin
				if @FromCopy=1
				begin
					begin try
						SET @strP='@DBFilter=N'''''+@DBNameSource+''''', @FilterBackupID='+CAST(@BackupID AS NVARCHAR(40))+', @Force=1';
						EXEC ('
							  EXEC(''
									EXEC sputnik.backups.usp_CopyBack '+@strP+';
							  '') AT ['+@ServerSource+']
						');
					end try
					begin catch
						set @str=N'Ошибка в ХП [usp_RunRolling]: не удалось скопировать файл бэкапа '+@BF+' (ИД='+CAST(@BackupID AS NVARCHAR(40))+')! Возможно соединение было сброшено!';
						if @pp=0
							PRINT(@str);
						RAISERROR(@str,11,1) WITH LOG
					end catch
				end
				else
				begin
					set @str=N'Ошибка в ХП [usp_RunRolling]: не обнаружен файл бэкапа '+@BF+' ! Возможно бэкап был удален или у SQL Server нет доступа!';
					if @pp=0
						PRINT(@str);
					RAISERROR(@str,11,1) WITH LOG
				end				
			end
			begin try
				set @RestoreStart=sysdatetime();
				IF @cur_i<@cur_cnt
					EXEC [sputnik].[backups].[usp_RestoreDB_simple] 
						@DBNameTarget=@DBNameTarget, 
						@FromLog=@BF,
						@MoveFilesTo=@CatalogFilesDB,
						@MoveLogFilesTo=@CatalogLogFiles,
						@NoRecovery=1,
						@NoFileList=1,
						@NoStats=@pp
						--,@StandBy_File=@StandBy_File
						,@NoSetMultiUser=1
					;
				ELSE
					EXEC [sputnik].[backups].[usp_RestoreDB_simple] 
						@DBNameTarget=@DBNameTarget, 
						@FromLog=@BF,
						@MoveFilesTo=@CatalogFilesDB,
						@MoveLogFilesTo=@CatalogLogFiles,
						@NoRecovery=1,
						@NoFileList=1,
						@NoStats=@pp
						,@StandBy_File=@StandBy_File
						,@NoSetMultiUser=1
					;
				insert into sputnik.lse.HS (config_id, BackupHS_id, StartRestore, CompleteRestore)
				values(@ConfigID, @BackupLogID, @RestoreStart, sysdatetime());
			end try
			begin catch
				--В случае Ошибки при восстановлении бэкапа лога, нужно вернуть базу в состояние MULTI_USER
				--Или в режим StandBy
				select top 1 @user_access_desc=user_access_desc, @state_desc=state_desc 
				from sys.databases
				where name=@DBNameTarget;
				IF @user_access_desc='SINGLE_USER' AND @state_desc='ONLINE'
					EXEC('ALTER DATABASE ['+@DBNameTarget+'] SET MULTI_USER;');
				--IF @state_desc<>'ONLINE' AND @StandBy_File IS NOT NULL
				--	EXEC [sputnik].[backups].[usp_RestoreDB_simple] 
				--		@DBNameTarget=@DBNameTarget, 
				--		@NoRecovery=1,
				--		@NoFileList=1,
				--		@NoStats=@pp,
				--		@StandBy_File=@StandBy_File,
				--		@ContinueRecovery=1;	
				set @str=N'Ошибка в ХП [usp_RunRolling]: при попытке накатить бэкап лога '+@BF+' на целевую БД ['+@DBNameTarget+']! Текст ошибки: '+ERROR_MESSAGE();
				if @pp=0
					PRINT(@str);
				RAISERROR(@str,11,1) WITH LOG;
			end catch
			set @cur_i+=1;
			FETCH NEXT FROM RE INTO @BF, @BT, @BackupLogID, @CheckFile, @BackupDate;
		END
		close RE;
		deallocate RE;
		--В самом конце вернем базу в MULTI_USER...Или в режим StandBy
		select top 1 @user_access_desc=user_access_desc, @state_desc=state_desc 
		from sys.databases
		where name=@DBNameTarget;
		IF @user_access_desc='SINGLE_USER' AND @state_desc='ONLINE'
			EXEC('ALTER DATABASE ['+@DBNameTarget+'] SET MULTI_USER;');
GO
PRINT N'Creating Procedure [lse].[usp_SetLseConf]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 04.08.2014 (1.0)
	-- Description: Процедура управления настройками по Log Shipping Easy (не стандартному, а работающему через спутник).
					Параметры: @ServerSource - имя сервера источника (где лежит БД источник), 
					@DBNameSource - имя БД источника, 
					@DBNameTarget - имя БД назначения (в эту базу будет выполняться восстановление).
					@FromCopy - Указывает из какого каталога будет выполняться восстановление: из самих бэкапов или из копий бэкапов.
					@ForceDelete - если 1, тогда заданная настройка удаляется!
					@ReInit - Если параметр указан, то для указанной настроки будет установлена Инициализация (процесс восстановления начнётся заново с полного бэкапа).
					@CatalogFilesDB - задаёт расположение (каталог) для всех Файлов целевой БД.
					@Suspend - Признак приостановки/паузы. Если задан 1, тогда накат бэкапов не будет выполняться для этой целевой БД.

					Алгоритм следующий: Процедура будет работать, только если на целевом Сервере правильно настроен Linked Server на сервер Primary!
					Так что перед запуском этой процедуры нужно настроить Linked Server! Но можно не указывать Linked Server - тогда LSE будет работать в
					рамках одного сервера SQL Server!
					Когда задан @ForceDelete -удаляем все настройки и историю, а также настройки на первичном сервере.
					В противном случае добавляем настройки (если этих нет). А если они есть обновляем значение FromCopy в настройках. При этом если значение параметра
					@ReInit=1 , тогда настраивается процесс Инициализации (обновляются соответствующие столбцы в таблице [TargetConfig].
					При успешном выполнении процедура должна вернуть 1.
	-- Update:		
					08.10.2014 (1.05)
					В блоки исключений добавлен вывод подробных ошибок через команду print! Также в алгоритме добавления новых настроек изменен порядок:
					сначала выполняется операция на удаленном сервере-источнике, затем уже локально.
					В алгоритме удаления конфигурации lse изменен порядок: сначала операция выполняется на удаленном сервере-источнике, а затем локально.
					Также в блок исключения добавлена проверка на открытые транзакции перед ROLLBACK (@@TRANCOUNT).
					И исправлен алгоритм удаления на удаленном сервере-источнике (были лишние кавычки в строке).
					19.03.2015 (1.06)
					Добавлен новый столбец и новый параметр @StandBy_File - реализует режим StandBy (read-only) для восстанавливаемой БД.
					25.07.2016 (1.07)
					Добавлен новый столбец и новый параметр @CatalogLogFiles - теперь можно расположить лог-файлы на отдельный диск.
					01.02.2017 (1.075)
					При удалении конфигурации добавлен алгоритм очистки неактуальных конфигураций на серверах источнике и приемнике.
					13.11.2017 (1.080)
					Добавлен новый параметр @UseFreshDiffBack - Разрешает использовать требование "свежести" к дифф.бэкапу, а также разрешает создать свежий дифф.бэкап, если его ещё нет!
	-- ============================================= */
	CREATE PROCEDURE [lse].[usp_SetLseConf]
		@ServerSource nvarchar(300) = null,
		@DBNameSource nvarchar(500) = null,
		@DBNameTarget nvarchar(500),
		@FromCopy bit = null,
		@ForceDelete bit = 0,
		@ReInit bit = 0,
		@CatalogFilesDB nvarchar(800) = null,
		@CatalogLogFiles nvarchar(800) = null,
		@Suspend bit = null,
		@StandBy_File nvarchar(600)=null,
		@UseFreshDiffBack bit = 1
	AS
	BEGIN
		SET NOCOUNT ON;
		DECLARE @errmsg NVARCHAR(600);
		IF EXISTS(select server_id from sys.servers where data_source=@ServerSource) OR @ServerSource IS NULL 
		BEGIN
			IF @ServerSource IS NULL
				SET @ServerSource=CAST(SERVERPROPERTY('ServerName') AS NVARCHAR(500));
			DECLARE @ServerTarget nvarchar(500)=CAST(SERVERPROPERTY('ServerName') AS NVARCHAR(500));
			IF @ForceDelete=1
			BEGIN
				declare @res bit;
				begin try
					EXEC('
								DELETE FROM ['+@ServerSource+'].sputnik.lse.SourceConfig
								WHERE ServerTarget='''+@ServerTarget+''' AND DBNameTarget='''+@DBNameTarget+''';
								--Дополнительно почистим НЕАКТУАЛЬНЫЕ конфигурации:
								DELETE FROM ['+@ServerSource+'].sputnik.lse.SourceConfig
								WHERE ServerTarget=(select [data_source] from ['+@ServerSource+'].master.sys.servers where is_linked=0);
								DELETE FROM ['+@ServerSource+'].sputnik.lse.TargetConfig
								WHERE ServerSource=(select [data_source] from ['+@ServerSource+'].master.sys.servers where is_linked=0);
								DELETE DelTab FROM ['+@ServerSource+'].sputnik.lse.HS DelTab
								LEFT JOIN ['+@ServerSource+'].sputnik.lse.TargetConfig tc
								ON DelTab.config_id=tc.id
								WHERE tc.id IS NULL;
							');
					begin tran
						DELETE 
						FROM [lse].[hs]
						WHERE config_id IN (SELECT id FROM [lse].[TargetConfig] WHERE DBNameTarget=@DBNameTarget);
						DELETE 
						FROM [lse].[TargetConfig]
						WHERE DBNameTarget=@DBNameTarget;
						--Дополнительно почистим НЕАКТУАЛЬНЫЕ конфигурации:
						DELETE FROM lse.SourceConfig
						WHERE ServerTarget=(select [data_source] from sys.servers where is_linked=0);
						DELETE FROM lse.TargetConfig
						WHERE ServerSource=(select [data_source] from sys.servers where is_linked=0);
						DELETE DelTab FROM lse.HS DelTab
						LEFT JOIN lse.TargetConfig tc
						ON DelTab.config_id=tc.id
						WHERE tc.id IS NULL;

					commit tran;
					set @res=1;
				end try
				begin catch
					IF @@TRANCOUNT > 0 
						rollback;
					set @res=0;
					set @errmsg=N'Ошибка при удалении старой конфигурации lse. Описание: '+ERROR_MESSAGE();
					print(@errmsg);
				end catch
				return @res;
			END;
			declare @t table (id smallint);
			INSERT INTO @t (id)
			SELECT id FROM sputnik.lse.TargetConfig WHERE DBNameTarget=@DBNameTarget
			IF EXISTS(select id from @t)
			BEGIN
				begin try
					IF @ReInit=1
					begin
						UPDATE sputnik.lse.TargetConfig
						SET InitDate=NULL, InitBackupHS_id=NULL, [Suspend]=0, UseFreshDiffBack=@UseFreshDiffBack
						WHERE DBNameTarget=@DBNameTarget;
						IF @CatalogFilesDB IS NOT NULL
							UPDATE sputnik.lse.TargetConfig
							SET CatalogFilesDB=@CatalogFilesDB,
								CatalogLogFiles=@CatalogLogFiles
							WHERE DBNameTarget=@DBNameTarget;
					end
					IF @FromCopy IS NOT NULL
						UPDATE sputnik.lse.TargetConfig
						SET FromCopy=@FromCopy
						WHERE DBNameTarget=@DBNameTarget;
					IF @Suspend IS NOT NULL
						UPDATE sputnik.lse.TargetConfig
						SET [Suspend]=@Suspend
						WHERE DBNameTarget=@DBNameTarget;	
					IF @StandBy_File IS NOT NULL
						UPDATE sputnik.lse.TargetConfig
						SET [StandBy_File]=@StandBy_File
						WHERE DBNameTarget=@DBNameTarget;
				end try
				begin catch
					set @errmsg=N'Ошибка при обновлении конфигурации lse (ReInit). Описание: '+ERROR_MESSAGE();
					print(@errmsg);
					return 0;
				end catch
			END;
			ELSE
			BEGIN
				begin try
					exec('
							DELETE FROM ['+@ServerSource+'].sputnik.lse.SourceConfig
								WHERE ServerTarget='''+@ServerTarget+''' AND DBNameTarget='''+@DBNameTarget+''';
							INSERT INTO ['+@ServerSource+'].sputnik.lse.SourceConfig (ServerTarget, DBNameSource, DBNameTarget)
								VALUES ('''+@ServerTarget+''', '''+@DBNameSource+''' ,'''+@DBNameTarget+''');
					');
					INSERT INTO sputnik.lse.TargetConfig (ServerSource, DBNameSource, DBNameTarget, FromCopy, CatalogFilesDB, CatalogLogFiles, [StandBy_File], UseFreshDiffBack)
					VALUES (@ServerSource, @DBNameSource,@DBNameTarget,@FromCopy, @CatalogFilesDB, @CatalogLogFiles, @StandBy_File, @UseFreshDiffBack);
				end try
				begin catch
					set @errmsg=N'Ошибка при добавлении новой конфигурации lse. Описание: '+ERROR_MESSAGE();
					print(@errmsg);
					return 0;
				end catch
			END	
			return 1;
		END;
		ELSE
			return -1;
	END
GO
PRINT N'Creating Procedure [dbo].[sp_WhoIsActive]...';


GO

/*********************************************************************************************
Who Is Active? v11.32 (2018-07-03)
(C) 2007-2018, Adam Machanic

Feedback: mailto:adam@dataeducation.com
Updates: http://whoisactive.com
Blog: http://dataeducation.com

License: 
	Who is Active? is free to download and use for personal, educational, and internal 
	corporate purposes, provided that this header is preserved. Redistribution or sale 
	of Who is Active?, in whole or in part, is prohibited without the author's express 
	written consent.
*********************************************************************************************/
CREATE PROC dbo.sp_WhoIsActive
(
--~
	--Filters--Both inclusive and exclusive
	--Set either filter to '' to disable
	--Valid filter types are: session, program, database, login, and host
	--Session is a session ID, and either 0 or '' can be used to indicate "all" sessions
	--All other filter types support % or _ as wildcards
	@filter sysname = '',
	@filter_type VARCHAR(10) = 'session',
	@not_filter sysname = '',
	@not_filter_type VARCHAR(10) = 'session',

	--Retrieve data about the calling session?
	@show_own_spid BIT = 0,

	--Retrieve data about system sessions?
	@show_system_spids BIT = 0,

	--Controls how sleeping SPIDs are handled, based on the idea of levels of interest
	--0 does not pull any sleeping SPIDs
	--1 pulls only those sleeping SPIDs that also have an open transaction
	--2 pulls all sleeping SPIDs
	@show_sleeping_spids TINYINT = 1,

	--If 1, gets the full stored procedure or running batch, when available
	--If 0, gets only the actual statement that is currently running in the batch or procedure
	@get_full_inner_text BIT = 0,

	--Get associated query plans for running tasks, if available
	--If @get_plans = 1, gets the plan based on the request's statement offset
	--If @get_plans = 2, gets the entire plan based on the request's plan_handle
	@get_plans TINYINT = 0,

	--Get the associated outer ad hoc query or stored procedure call, if available
	@get_outer_command BIT = 0,

	--Enables pulling transaction log write info and transaction duration
	@get_transaction_info BIT = 0,

	--Get information on active tasks, based on three interest levels
	--Level 0 does not pull any task-related information
	--Level 1 is a lightweight mode that pulls the top non-CXPACKET wait, giving preference to blockers
	--Level 2 pulls all available task-based metrics, including: 
	--number of active tasks, current wait stats, physical I/O, context switches, and blocker information
	@get_task_info TINYINT = 1,

	--Gets associated locks for each request, aggregated in an XML format
	@get_locks BIT = 0,

	--Get average time for past runs of an active query
	--(based on the combination of plan handle, sql handle, and offset)
	@get_avg_time BIT = 0,

	--Get additional non-performance-related information about the session or request
	--text_size, language, date_format, date_first, quoted_identifier, arithabort, ansi_null_dflt_on, 
	--ansi_defaults, ansi_warnings, ansi_padding, ansi_nulls, concat_null_yields_null, 
	--transaction_isolation_level, lock_timeout, deadlock_priority, row_count, command_type
	--
	--If a SQL Agent job is running, an subnode called agent_info will be populated with some or all of
	--the following: job_id, job_name, step_id, step_name, msdb_query_error (in the event of an error)
	--
	--If @get_task_info is set to 2 and a lock wait is detected, a subnode called block_info will be
	--populated with some or all of the following: lock_type, database_name, object_id, file_id, hobt_id, 
	--applock_hash, metadata_resource, metadata_class_id, object_name, schema_name
	@get_additional_info BIT = 0,

	--Walk the blocking chain and count the number of 
	--total SPIDs blocked all the way down by a given session
	--Also enables task_info Level 1, if @get_task_info is set to 0
	@find_block_leaders BIT = 0,

	--Pull deltas on various metrics
	--Interval in seconds to wait before doing the second data pull
	@delta_interval TINYINT = 0,

	--List of desired output columns, in desired order
	--Note that the final output will be the intersection of all enabled features and all 
	--columns in the list. Therefore, only columns associated with enabled features will 
	--actually appear in the output. Likewise, removing columns from this list may effectively
	--disable features, even if they are turned on
	--
	--Each element in this list must be one of the valid output column names. Names must be
	--delimited by square brackets. White space, formatting, and additional characters are
	--allowed, as long as the list contains exact matches of delimited valid column names.
	@output_column_list VARCHAR(8000) = '[dd%][session_id][sql_text][sql_command][login_name][wait_info][tasks][tran_log%][cpu%][temp%][block%][reads%][writes%][context%][physical%][query_plan][locks][%]',

	--Column(s) by which to sort output, optionally with sort directions. 
		--Valid column choices:
		--session_id, physical_io, reads, physical_reads, writes, tempdb_allocations, 
		--tempdb_current, CPU, context_switches, used_memory, physical_io_delta, reads_delta, 
		--physical_reads_delta, writes_delta, tempdb_allocations_delta, tempdb_current_delta, 
		--CPU_delta, context_switches_delta, used_memory_delta, tasks, tran_start_time, 
		--open_tran_count, blocking_session_id, blocked_session_count, percent_complete, 
		--host_name, login_name, database_name, start_time, login_time, program_name
		--
		--Note that column names in the list must be bracket-delimited. Commas and/or white
		--space are not required. 
	@sort_order VARCHAR(500) = '[start_time] ASC',

	--Formats some of the output columns in a more "human readable" form
	--0 disables outfput format
	--1 formats the output for variable-width fonts
	--2 formats the output for fixed-width fonts
	@format_output TINYINT = 1,

	--If set to a non-blank value, the script will attempt to insert into the specified 
	--destination table. Please note that the script will not verify that the table exists, 
	--or that it has the correct schema, before doing the insert.
	--Table can be specified in one, two, or three-part format
	@destination_table VARCHAR(4000) = '',

	--If set to 1, no data collection will happen and no result set will be returned; instead,
	--a CREATE TABLE statement will be returned via the @schema parameter, which will match 
	--the schema of the result set that would be returned by using the same collection of the
	--rest of the parameters. The CREATE TABLE statement will have a placeholder token of 
	--<table_name> in place of an actual table name.
	@return_schema BIT = 0,
	@schema VARCHAR(MAX) = NULL OUTPUT,

	--Help! What do I do?
	@help BIT = 0
--~
)
/*
OUTPUT COLUMNS
--------------
Formatted/Non:	[session_id] [smallint] NOT NULL
	Session ID (a.k.a. SPID)

Formatted:		[dd hh:mm:ss.mss] [varchar](15) NULL
Non-Formatted:	<not returned>
	For an active request, time the query has been running
	For a sleeping session, time since the last batch completed

Formatted:		[dd hh:mm:ss.mss (avg)] [varchar](15) NULL
Non-Formatted:	[avg_elapsed_time] [int] NULL
	(Requires @get_avg_time option)
	How much time has the active portion of the query taken in the past, on average?

Formatted:		[physical_io] [varchar](30) NULL
Non-Formatted:	[physical_io] [bigint] NULL
	Shows the number of physical I/Os, for active requests

Formatted:		[reads] [varchar](30) NULL
Non-Formatted:	[reads] [bigint] NULL
	For an active request, number of reads done for the current query
	For a sleeping session, total number of reads done over the lifetime of the session

Formatted:		[physical_reads] [varchar](30) NULL
Non-Formatted:	[physical_reads] [bigint] NULL
	For an active request, number of physical reads done for the current query
	For a sleeping session, total number of physical reads done over the lifetime of the session

Formatted:		[writes] [varchar](30) NULL
Non-Formatted:	[writes] [bigint] NULL
	For an active request, number of writes done for the current query
	For a sleeping session, total number of writes done over the lifetime of the session

Formatted:		[tempdb_allocations] [varchar](30) NULL
Non-Formatted:	[tempdb_allocations] [bigint] NULL
	For an active request, number of TempDB writes done for the current query
	For a sleeping session, total number of TempDB writes done over the lifetime of the session

Formatted:		[tempdb_current] [varchar](30) NULL
Non-Formatted:	[tempdb_current] [bigint] NULL
	For an active request, number of TempDB pages currently allocated for the query
	For a sleeping session, number of TempDB pages currently allocated for the session

Formatted:		[CPU] [varchar](30) NULL
Non-Formatted:	[CPU] [int] NULL
	For an active request, total CPU time consumed by the current query
	For a sleeping session, total CPU time consumed over the lifetime of the session

Formatted:		[context_switches] [varchar](30) NULL
Non-Formatted:	[context_switches] [bigint] NULL
	Shows the number of context switches, for active requests

Formatted:		[used_memory] [varchar](30) NOT NULL
Non-Formatted:	[used_memory] [bigint] NOT NULL
	For an active request, total memory consumption for the current query
	For a sleeping session, total current memory consumption

Formatted:		[physical_io_delta] [varchar](30) NULL
Non-Formatted:	[physical_io_delta] [bigint] NULL
	(Requires @delta_interval option)
	Difference between the number of physical I/Os reported on the first and second collections. 
	If the request started after the first collection, the value will be NULL

Formatted:		[reads_delta] [varchar](30) NULL
Non-Formatted:	[reads_delta] [bigint] NULL
	(Requires @delta_interval option)
	Difference between the number of reads reported on the first and second collections. 
	If the request started after the first collection, the value will be NULL

Formatted:		[physical_reads_delta] [varchar](30) NULL
Non-Formatted:	[physical_reads_delta] [bigint] NULL
	(Requires @delta_interval option)
	Difference between the number of physical reads reported on the first and second collections. 
	If the request started after the first collection, the value will be NULL

Formatted:		[writes_delta] [varchar](30) NULL
Non-Formatted:	[writes_delta] [bigint] NULL
	(Requires @delta_interval option)
	Difference between the number of writes reported on the first and second collections. 
	If the request started after the first collection, the value will be NULL

Formatted:		[tempdb_allocations_delta] [varchar](30) NULL
Non-Formatted:	[tempdb_allocations_delta] [bigint] NULL
	(Requires @delta_interval option)
	Difference between the number of TempDB writes reported on the first and second collections. 
	If the request started after the first collection, the value will be NULL

Formatted:		[tempdb_current_delta] [varchar](30) NULL
Non-Formatted:	[tempdb_current_delta] [bigint] NULL
	(Requires @delta_interval option)
	Difference between the number of allocated TempDB pages reported on the first and second 
	collections. If the request started after the first collection, the value will be NULL

Formatted:		[CPU_delta] [varchar](30) NULL
Non-Formatted:	[CPU_delta] [int] NULL
	(Requires @delta_interval option)
	Difference between the CPU time reported on the first and second collections. 
	If the request started after the first collection, the value will be NULL

Formatted:		[context_switches_delta] [varchar](30) NULL
Non-Formatted:	[context_switches_delta] [bigint] NULL
	(Requires @delta_interval option)
	Difference between the context switches count reported on the first and second collections
	If the request started after the first collection, the value will be NULL

Formatted:		[used_memory_delta] [varchar](30) NULL
Non-Formatted:	[used_memory_delta] [bigint] NULL
	Difference between the memory usage reported on the first and second collections
	If the request started after the first collection, the value will be NULL

Formatted:		[tasks] [varchar](30) NULL
Non-Formatted:	[tasks] [smallint] NULL
	Number of worker tasks currently allocated, for active requests

Formatted/Non:	[status] [varchar](30) NOT NULL
	Activity status for the session (running, sleeping, etc)

Formatted/Non:	[wait_info] [nvarchar](4000) NULL
	Aggregates wait information, in the following format:
		(Ax: Bms/Cms/Dms)E
	A is the number of waiting tasks currently waiting on resource type E. B/C/D are wait
	times, in milliseconds. If only one thread is waiting, its wait time will be shown as B.
	If two tasks are waiting, each of their wait times will be shown (B/C). If three or more 
	tasks are waiting, the minimum, average, and maximum wait times will be shown (B/C/D).
	If wait type E is a page latch wait and the page is of a "special" type (e.g. PFS, GAM, SGAM), 
	the page type will be identified.
	If wait type E is CXPACKET, the nodeId from the query plan will be identified

Formatted/Non:	[locks] [xml] NULL
	(Requires @get_locks option)
	Aggregates lock information, in XML format.
	The lock XML includes the lock mode, locked object, and aggregates the number of requests. 
	Attempts are made to identify locked objects by name

Formatted/Non:	[tran_start_time] [datetime] NULL
	(Requires @get_transaction_info option)
	Date and time that the first transaction opened by a session caused a transaction log 
	write to occur.

Formatted/Non:	[tran_log_writes] [nvarchar](4000) NULL
	(Requires @get_transaction_info option)
	Aggregates transaction log write information, in the following format:
	A:wB (C kB)
	A is a database that has been touched by an active transaction
	B is the number of log writes that have been made in the database as a result of the transaction
	C is the number of log kilobytes consumed by the log records

Formatted:		[open_tran_count] [varchar](30) NULL
Non-Formatted:	[open_tran_count] [smallint] NULL
	Shows the number of open transactions the session has open

Formatted:		[sql_command] [xml] NULL
Non-Formatted:	[sql_command] [nvarchar](max) NULL
	(Requires @get_outer_command option)
	Shows the "outer" SQL command, i.e. the text of the batch or RPC sent to the server, 
	if available

Formatted:		[sql_text] [xml] NULL
Non-Formatted:	[sql_text] [nvarchar](max) NULL
	Shows the SQL text for active requests or the last statement executed
	for sleeping sessions, if available in either case.
	If @get_full_inner_text option is set, shows the full text of the batch.
	Otherwise, shows only the active statement within the batch.
	If the query text is locked, a special timeout message will be sent, in the following format:
		<timeout_exceeded />
	If an error occurs, an error message will be sent, in the following format:
		<error message="message" />

Formatted/Non:	[query_plan] [xml] NULL
	(Requires @get_plans option)
	Shows the query plan for the request, if available.
	If the plan is locked, a special timeout message will be sent, in the following format:
		<timeout_exceeded />
	If an error occurs, an error message will be sent, in the following format:
		<error message="message" />

Formatted/Non:	[blocking_session_id] [smallint] NULL
	When applicable, shows the blocking SPID

Formatted:		[blocked_session_count] [varchar](30) NULL
Non-Formatted:	[blocked_session_count] [smallint] NULL
	(Requires @find_block_leaders option)
	The total number of SPIDs blocked by this session,
	all the way down the blocking chain.

Formatted:		[percent_complete] [varchar](30) NULL
Non-Formatted:	[percent_complete] [real] NULL
	When applicable, shows the percent complete (e.g. for backups, restores, and some rollbacks)

Formatted/Non:	[host_name] [sysname] NOT NULL
	Shows the host name for the connection

Formatted/Non:	[login_name] [sysname] NOT NULL
	Shows the login name for the connection

Formatted/Non:	[database_name] [sysname] NULL
	Shows the connected database

Formatted/Non:	[program_name] [sysname] NULL
	Shows the reported program/application name

Formatted/Non:	[additional_info] [xml] NULL
	(Requires @get_additional_info option)
	Returns additional non-performance-related session/request information
	If the script finds a SQL Agent job running, the name of the job and job step will be reported
	If @get_task_info = 2 and the script finds a lock wait, the locked object will be reported

Formatted/Non:	[start_time] [datetime] NOT NULL
	For active requests, shows the time the request started
	For sleeping sessions, shows the time the last batch completed

Formatted/Non:	[login_time] [datetime] NOT NULL
	Shows the time that the session connected

Formatted/Non:	[request_id] [int] NULL
	For active requests, shows the request_id
	Should be 0 unless MARS is being used

Formatted/Non:	[collection_time] [datetime] NOT NULL
	Time that this script's final SELECT ran
*/
AS
BEGIN;
	SET NOCOUNT ON; 
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	SET QUOTED_IDENTIFIER ON;
	SET ANSI_PADDING ON;
	SET CONCAT_NULL_YIELDS_NULL ON;
	SET ANSI_WARNINGS ON;
	SET NUMERIC_ROUNDABORT OFF;
	SET ARITHABORT ON;

	IF
		@filter IS NULL
		OR @filter_type IS NULL
		OR @not_filter IS NULL
		OR @not_filter_type IS NULL
		OR @show_own_spid IS NULL
		OR @show_system_spids IS NULL
		OR @show_sleeping_spids IS NULL
		OR @get_full_inner_text IS NULL
		OR @get_plans IS NULL
		OR @get_outer_command IS NULL
		OR @get_transaction_info IS NULL
		OR @get_task_info IS NULL
		OR @get_locks IS NULL
		OR @get_avg_time IS NULL
		OR @get_additional_info IS NULL
		OR @find_block_leaders IS NULL
		OR @delta_interval IS NULL
		OR @format_output IS NULL
		OR @output_column_list IS NULL
		OR @sort_order IS NULL
		OR @return_schema IS NULL
		OR @destination_table IS NULL
		OR @help IS NULL
	BEGIN;
		RAISERROR('Input parameters cannot be NULL', 16, 1);
		RETURN;
	END;
	
	IF @filter_type NOT IN ('session', 'program', 'database', 'login', 'host')
	BEGIN;
		RAISERROR('Valid filter types are: session, program, database, login, host', 16, 1);
		RETURN;
	END;
	
	IF @filter_type = 'session' AND @filter LIKE '%[^0123456789]%'
	BEGIN;
		RAISERROR('Session filters must be valid integers', 16, 1);
		RETURN;
	END;
	
	IF @not_filter_type NOT IN ('session', 'program', 'database', 'login', 'host')
	BEGIN;
		RAISERROR('Valid filter types are: session, program, database, login, host', 16, 1);
		RETURN;
	END;
	
	IF @not_filter_type = 'session' AND @not_filter LIKE '%[^0123456789]%'
	BEGIN;
		RAISERROR('Session filters must be valid integers', 16, 1);
		RETURN;
	END;
	
	IF @show_sleeping_spids NOT IN (0, 1, 2)
	BEGIN;
		RAISERROR('Valid values for @show_sleeping_spids are: 0, 1, or 2', 16, 1);
		RETURN;
	END;
	
	IF @get_plans NOT IN (0, 1, 2)
	BEGIN;
		RAISERROR('Valid values for @get_plans are: 0, 1, or 2', 16, 1);
		RETURN;
	END;

	IF @get_task_info NOT IN (0, 1, 2)
	BEGIN;
		RAISERROR('Valid values for @get_task_info are: 0, 1, or 2', 16, 1);
		RETURN;
	END;

	IF @format_output NOT IN (0, 1, 2)
	BEGIN;
		RAISERROR('Valid values for @format_output are: 0, 1, or 2', 16, 1);
		RETURN;
	END;
	
	IF @help = 1
	BEGIN;
		DECLARE 
			@header VARCHAR(MAX),
			@params VARCHAR(MAX),
			@outputs VARCHAR(MAX);

		SELECT 
			@header =
				REPLACE
				(
					REPLACE
					(
						CONVERT
						(
							VARCHAR(MAX),
							SUBSTRING
							(
								t.text, 
								CHARINDEX('/' + REPLICATE('*', 93), t.text) + 94,
								CHARINDEX(REPLICATE('*', 93) + '/', t.text) - (CHARINDEX('/' + REPLICATE('*', 93), t.text) + 94)
							)
						),
						CHAR(13)+CHAR(10),
						CHAR(13)
					),
					'	',
					''
				),
			@params =
				CHAR(13) +
					REPLACE
					(
						REPLACE
						(
							CONVERT
							(
								VARCHAR(MAX),
								SUBSTRING
								(
									t.text, 
									CHARINDEX('--~', t.text) + 5, 
									CHARINDEX('--~', t.text, CHARINDEX('--~', t.text) + 5) - (CHARINDEX('--~', t.text) + 5)
								)
							),
							CHAR(13)+CHAR(10),
							CHAR(13)
						),
						'	',
						''
					),
				@outputs = 
					CHAR(13) +
						REPLACE
						(
							REPLACE
							(
								REPLACE
								(
									CONVERT
									(
										VARCHAR(MAX),
										SUBSTRING
										(
											t.text, 
											CHARINDEX('OUTPUT COLUMNS'+CHAR(13)+CHAR(10)+'--------------', t.text) + 32,
											CHARINDEX('*/', t.text, CHARINDEX('OUTPUT COLUMNS'+CHAR(13)+CHAR(10)+'--------------', t.text) + 32) - (CHARINDEX('OUTPUT COLUMNS'+CHAR(13)+CHAR(10)+'--------------', t.text) + 32)
										)
									),
									CHAR(9),
									CHAR(255)
								),
								CHAR(13)+CHAR(10),
								CHAR(13)
							),
							'	',
							''
						) +
						CHAR(13)
		FROM sys.dm_exec_requests AS r
		CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) AS t
		WHERE
			r.session_id = @@SPID;

		WITH
		a0 AS
		(SELECT 1 AS n UNION ALL SELECT 1),
		a1 AS
		(SELECT 1 AS n FROM a0 AS a, a0 AS b),
		a2 AS
		(SELECT 1 AS n FROM a1 AS a, a1 AS b),
		a3 AS
		(SELECT 1 AS n FROM a2 AS a, a2 AS b),
		a4 AS
		(SELECT 1 AS n FROM a3 AS a, a3 AS b),
		numbers AS
		(
			SELECT TOP(LEN(@header) - 1)
				ROW_NUMBER() OVER
				(
					ORDER BY (SELECT NULL)
				) AS number
			FROM a4
			ORDER BY
				number
		)
		SELECT
			RTRIM(LTRIM(
				SUBSTRING
				(
					@header,
					number + 1,
					CHARINDEX(CHAR(13), @header, number + 1) - number - 1
				)
			)) AS [------header---------------------------------------------------------------------------------------------------------------]
		FROM numbers
		WHERE
			SUBSTRING(@header, number, 1) = CHAR(13);

		WITH
		a0 AS
		(SELECT 1 AS n UNION ALL SELECT 1),
		a1 AS
		(SELECT 1 AS n FROM a0 AS a, a0 AS b),
		a2 AS
		(SELECT 1 AS n FROM a1 AS a, a1 AS b),
		a3 AS
		(SELECT 1 AS n FROM a2 AS a, a2 AS b),
		a4 AS
		(SELECT 1 AS n FROM a3 AS a, a3 AS b),
		numbers AS
		(
			SELECT TOP(LEN(@params) - 1)
				ROW_NUMBER() OVER
				(
					ORDER BY (SELECT NULL)
				) AS number
			FROM a4
			ORDER BY
				number
		),
		tokens AS
		(
			SELECT 
				RTRIM(LTRIM(
					SUBSTRING
					(
						@params,
						number + 1,
						CHARINDEX(CHAR(13), @params, number + 1) - number - 1
					)
				)) AS token,
				number,
				CASE
					WHEN SUBSTRING(@params, number + 1, 1) = CHAR(13) THEN number
					ELSE COALESCE(NULLIF(CHARINDEX(',' + CHAR(13) + CHAR(13), @params, number), 0), LEN(@params)) 
				END AS param_group,
				ROW_NUMBER() OVER
				(
					PARTITION BY
						CHARINDEX(',' + CHAR(13) + CHAR(13), @params, number),
						SUBSTRING(@params, number+1, 1)
					ORDER BY 
						number
				) AS group_order
			FROM numbers
			WHERE
				SUBSTRING(@params, number, 1) = CHAR(13)
		),
		parsed_tokens AS
		(
			SELECT
				MIN
				(
					CASE
						WHEN token LIKE '@%' THEN token
						ELSE NULL
					END
				) AS parameter,
				MIN
				(
					CASE
						WHEN token LIKE '--%' THEN RIGHT(token, LEN(token) - 2)
						ELSE NULL
					END
				) AS description,
				param_group,
				group_order
			FROM tokens
			WHERE
				NOT 
				(
					token = '' 
					AND group_order > 1
				)
			GROUP BY
				param_group,
				group_order
		)
		SELECT
			CASE
				WHEN description IS NULL AND parameter IS NULL THEN '-------------------------------------------------------------------------'
				WHEN param_group = MAX(param_group) OVER() THEN parameter
				ELSE COALESCE(LEFT(parameter, LEN(parameter) - 1), '')
			END AS [------parameter----------------------------------------------------------],
			CASE
				WHEN description IS NULL AND parameter IS NULL THEN '----------------------------------------------------------------------------------------------------------------------'
				ELSE COALESCE(description, '')
			END AS [------description-----------------------------------------------------------------------------------------------------]
		FROM parsed_tokens
		ORDER BY
			param_group, 
			group_order;
		
		WITH
		a0 AS
		(SELECT 1 AS n UNION ALL SELECT 1),
		a1 AS
		(SELECT 1 AS n FROM a0 AS a, a0 AS b),
		a2 AS
		(SELECT 1 AS n FROM a1 AS a, a1 AS b),
		a3 AS
		(SELECT 1 AS n FROM a2 AS a, a2 AS b),
		a4 AS
		(SELECT 1 AS n FROM a3 AS a, a3 AS b),
		numbers AS
		(
			SELECT TOP(LEN(@outputs) - 1)
				ROW_NUMBER() OVER
				(
					ORDER BY (SELECT NULL)
				) AS number
			FROM a4
			ORDER BY
				number
		),
		tokens AS
		(
			SELECT 
				RTRIM(LTRIM(
					SUBSTRING
					(
						@outputs,
						number + 1,
						CASE
							WHEN 
								COALESCE(NULLIF(CHARINDEX(CHAR(13) + 'Formatted', @outputs, number + 1), 0), LEN(@outputs)) < 
								COALESCE(NULLIF(CHARINDEX(CHAR(13) + CHAR(255) COLLATE Latin1_General_Bin2, @outputs, number + 1), 0), LEN(@outputs))
								THEN COALESCE(NULLIF(CHARINDEX(CHAR(13) + 'Formatted', @outputs, number + 1), 0), LEN(@outputs)) - number - 1
							ELSE
								COALESCE(NULLIF(CHARINDEX(CHAR(13) + CHAR(255) COLLATE Latin1_General_Bin2, @outputs, number + 1), 0), LEN(@outputs)) - number - 1
						END
					)
				)) AS token,
				number,
				COALESCE(NULLIF(CHARINDEX(CHAR(13) + 'Formatted', @outputs, number + 1), 0), LEN(@outputs)) AS output_group,
				ROW_NUMBER() OVER
				(
					PARTITION BY 
						COALESCE(NULLIF(CHARINDEX(CHAR(13) + 'Formatted', @outputs, number + 1), 0), LEN(@outputs))
					ORDER BY
						number
				) AS output_group_order
			FROM numbers
			WHERE
				SUBSTRING(@outputs, number, 10) = CHAR(13) + 'Formatted'
				OR SUBSTRING(@outputs, number, 2) = CHAR(13) + CHAR(255) COLLATE Latin1_General_Bin2
		),
		output_tokens AS
		(
			SELECT 
				*,
				CASE output_group_order
					WHEN 2 THEN MAX(CASE output_group_order WHEN 1 THEN token ELSE NULL END) OVER (PARTITION BY output_group)
					ELSE ''
				END COLLATE Latin1_General_Bin2 AS column_info
			FROM tokens
		)
		SELECT
			CASE output_group_order
				WHEN 1 THEN '-----------------------------------'
				WHEN 2 THEN 
					CASE
						WHEN CHARINDEX('Formatted/Non:', column_info) = 1 THEN
							SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info)+1, CHARINDEX(']', column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info)+2) - CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info))
						ELSE
							SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info)+2, CHARINDEX(']', column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info)+2) - CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info)-1)
					END
				ELSE ''
			END AS formatted_column_name,
			CASE output_group_order
				WHEN 1 THEN '-----------------------------------'
				WHEN 2 THEN 
					CASE
						WHEN CHARINDEX('Formatted/Non:', column_info) = 1 THEN
							SUBSTRING(column_info, CHARINDEX(']', column_info)+2, LEN(column_info))
						ELSE
							SUBSTRING(column_info, CHARINDEX(']', column_info)+2, CHARINDEX('Non-Formatted:', column_info, CHARINDEX(']', column_info)+2) - CHARINDEX(']', column_info)-3)
					END
				ELSE ''
			END AS formatted_column_type,
			CASE output_group_order
				WHEN 1 THEN '---------------------------------------'
				WHEN 2 THEN 
					CASE
						WHEN CHARINDEX('Formatted/Non:', column_info) = 1 THEN ''
						ELSE
							CASE
								WHEN SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info))+1, 1) = '<' THEN
									SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info))+1, CHARINDEX('>', column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info))+1) - CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info)))
								ELSE
									SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info))+1, CHARINDEX(']', column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info))+1) - CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info)))
							END
					END
				ELSE ''
			END AS unformatted_column_name,
			CASE output_group_order
				WHEN 1 THEN '---------------------------------------'
				WHEN 2 THEN 
					CASE
						WHEN CHARINDEX('Formatted/Non:', column_info) = 1 THEN ''
						ELSE
							CASE
								WHEN SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info))+1, 1) = '<' THEN ''
								ELSE
									SUBSTRING(column_info, CHARINDEX(']', column_info, CHARINDEX('Non-Formatted:', column_info))+2, CHARINDEX('Non-Formatted:', column_info, CHARINDEX(']', column_info)+2) - CHARINDEX(']', column_info)-3)
							END
					END
				ELSE ''
			END AS unformatted_column_type,
			CASE output_group_order
				WHEN 1 THEN '----------------------------------------------------------------------------------------------------------------------'
				ELSE REPLACE(token, CHAR(255) COLLATE Latin1_General_Bin2, '')
			END AS [------description-----------------------------------------------------------------------------------------------------]
		FROM output_tokens
		WHERE
			NOT 
			(
				output_group_order = 1 
				AND output_group = LEN(@outputs)
			)
		ORDER BY
			output_group,
			CASE output_group_order
				WHEN 1 THEN 99
				ELSE output_group_order
			END;

		RETURN;
	END;

	WITH
	a0 AS
	(SELECT 1 AS n UNION ALL SELECT 1),
	a1 AS
	(SELECT 1 AS n FROM a0 AS a, a0 AS b),
	a2 AS
	(SELECT 1 AS n FROM a1 AS a, a1 AS b),
	a3 AS
	(SELECT 1 AS n FROM a2 AS a, a2 AS b),
	a4 AS
	(SELECT 1 AS n FROM a3 AS a, a3 AS b),
	numbers AS
	(
		SELECT TOP(LEN(@output_column_list))
			ROW_NUMBER() OVER
			(
				ORDER BY (SELECT NULL)
			) AS number
		FROM a4
		ORDER BY
			number
	),
	tokens AS
	(
		SELECT 
			'|[' +
				SUBSTRING
				(
					@output_column_list,
					number + 1,
					CHARINDEX(']', @output_column_list, number) - number - 1
				) + '|]' AS token,
			number
		FROM numbers
		WHERE
			SUBSTRING(@output_column_list, number, 1) = '['
	),
	ordered_columns AS
	(
		SELECT
			x.column_name,
			ROW_NUMBER() OVER
			(
				PARTITION BY
					x.column_name
				ORDER BY
					tokens.number,
					x.default_order
			) AS r,
			ROW_NUMBER() OVER
			(
				ORDER BY
					tokens.number,
					x.default_order
			) AS s
		FROM tokens
		JOIN
		(
			SELECT '[session_id]' AS column_name, 1 AS default_order
			UNION ALL
			SELECT '[dd hh:mm:ss.mss]', 2
			WHERE
				@format_output IN (1, 2)
			UNION ALL
			SELECT '[dd hh:mm:ss.mss (avg)]', 3
			WHERE
				@format_output IN (1, 2)
				AND @get_avg_time = 1
			UNION ALL
			SELECT '[avg_elapsed_time]', 4
			WHERE
				@format_output = 0
				AND @get_avg_time = 1
			UNION ALL
			SELECT '[physical_io]', 5
			WHERE
				@get_task_info = 2
			UNION ALL
			SELECT '[reads]', 6
			UNION ALL
			SELECT '[physical_reads]', 7
			UNION ALL
			SELECT '[writes]', 8
			UNION ALL
			SELECT '[tempdb_allocations]', 9
			UNION ALL
			SELECT '[tempdb_current]', 10
			UNION ALL
			SELECT '[CPU]', 11
			UNION ALL
			SELECT '[context_switches]', 12
			WHERE
				@get_task_info = 2
			UNION ALL
			SELECT '[used_memory]', 13
			UNION ALL
			SELECT '[physical_io_delta]', 14
			WHERE
				@delta_interval > 0	
				AND @get_task_info = 2
			UNION ALL
			SELECT '[reads_delta]', 15
			WHERE
				@delta_interval > 0
			UNION ALL
			SELECT '[physical_reads_delta]', 16
			WHERE
				@delta_interval > 0
			UNION ALL
			SELECT '[writes_delta]', 17
			WHERE
				@delta_interval > 0
			UNION ALL
			SELECT '[tempdb_allocations_delta]', 18
			WHERE
				@delta_interval > 0
			UNION ALL
			SELECT '[tempdb_current_delta]', 19
			WHERE
				@delta_interval > 0
			UNION ALL
			SELECT '[CPU_delta]', 20
			WHERE
				@delta_interval > 0
			UNION ALL
			SELECT '[context_switches_delta]', 21
			WHERE
				@delta_interval > 0
				AND @get_task_info = 2
			UNION ALL
			SELECT '[used_memory_delta]', 22
			WHERE
				@delta_interval > 0
			UNION ALL
			SELECT '[tasks]', 23
			WHERE
				@get_task_info = 2
			UNION ALL
			SELECT '[status]', 24
			UNION ALL
			SELECT '[wait_info]', 25
			WHERE
				@get_task_info > 0
				OR @find_block_leaders = 1
			UNION ALL
			SELECT '[locks]', 26
			WHERE
				@get_locks = 1
			UNION ALL
			SELECT '[tran_start_time]', 27
			WHERE
				@get_transaction_info = 1
			UNION ALL
			SELECT '[tran_log_writes]', 28
			WHERE
				@get_transaction_info = 1
			UNION ALL
			SELECT '[open_tran_count]', 29
			UNION ALL
			SELECT '[sql_command]', 30
			WHERE
				@get_outer_command = 1
			UNION ALL
			SELECT '[sql_text]', 31
			UNION ALL
			SELECT '[query_plan]', 32
			WHERE
				@get_plans >= 1
			UNION ALL
			SELECT '[blocking_session_id]', 33
			WHERE
				@get_task_info > 0
				OR @find_block_leaders = 1
			UNION ALL
			SELECT '[blocked_session_count]', 34
			WHERE
				@find_block_leaders = 1
			UNION ALL
			SELECT '[percent_complete]', 35
			UNION ALL
			SELECT '[host_name]', 36
			UNION ALL
			SELECT '[login_name]', 37
			UNION ALL
			SELECT '[database_name]', 38
			UNION ALL
			SELECT '[program_name]', 39
			UNION ALL
			SELECT '[additional_info]', 40
			WHERE
				@get_additional_info = 1
			UNION ALL
			SELECT '[start_time]', 41
			UNION ALL
			SELECT '[login_time]', 42
			UNION ALL
			SELECT '[request_id]', 43
			UNION ALL
			SELECT '[collection_time]', 44
		) AS x ON 
			x.column_name LIKE token ESCAPE '|'
	)
	SELECT
		@output_column_list =
			STUFF
			(
				(
					SELECT
						',' + column_name as [text()]
					FROM ordered_columns
					WHERE
						r = 1
					ORDER BY
						s
					FOR XML
						PATH('')
				),
				1,
				1,
				''
			);
	
	IF COALESCE(RTRIM(@output_column_list), '') = ''
	BEGIN;
		RAISERROR('No valid column matches found in @output_column_list or no columns remain due to selected options.', 16, 1);
		RETURN;
	END;
	
	IF @destination_table <> ''
	BEGIN;
		SET @destination_table = 
			--database
			COALESCE(QUOTENAME(PARSENAME(@destination_table, 3)) + '.', '') +
			--schema
			COALESCE(QUOTENAME(PARSENAME(@destination_table, 2)) + '.', '') +
			--table
			COALESCE(QUOTENAME(PARSENAME(@destination_table, 1)), '');
			
		IF COALESCE(RTRIM(@destination_table), '') = ''
		BEGIN;
			RAISERROR('Destination table not properly formatted.', 16, 1);
			RETURN;
		END;
	END;

	WITH
	a0 AS
	(SELECT 1 AS n UNION ALL SELECT 1),
	a1 AS
	(SELECT 1 AS n FROM a0 AS a, a0 AS b),
	a2 AS
	(SELECT 1 AS n FROM a1 AS a, a1 AS b),
	a3 AS
	(SELECT 1 AS n FROM a2 AS a, a2 AS b),
	a4 AS
	(SELECT 1 AS n FROM a3 AS a, a3 AS b),
	numbers AS
	(
		SELECT TOP(LEN(@sort_order))
			ROW_NUMBER() OVER
			(
				ORDER BY (SELECT NULL)
			) AS number
		FROM a4
		ORDER BY
			number
	),
	tokens AS
	(
		SELECT 
			'|[' +
				SUBSTRING
				(
					@sort_order,
					number + 1,
					CHARINDEX(']', @sort_order, number) - number - 1
				) + '|]' AS token,
			SUBSTRING
			(
				@sort_order,
				CHARINDEX(']', @sort_order, number) + 1,
				COALESCE(NULLIF(CHARINDEX('[', @sort_order, CHARINDEX(']', @sort_order, number)), 0), LEN(@sort_order)) - CHARINDEX(']', @sort_order, number)
			) AS next_chunk,
			number
		FROM numbers
		WHERE
			SUBSTRING(@sort_order, number, 1) = '['
	),
	ordered_columns AS
	(
		SELECT
			x.column_name +
				CASE
					WHEN tokens.next_chunk LIKE '%asc%' THEN ' ASC'
					WHEN tokens.next_chunk LIKE '%desc%' THEN ' DESC'
					ELSE ''
				END AS column_name,
			ROW_NUMBER() OVER
			(
				PARTITION BY
					x.column_name
				ORDER BY
					tokens.number
			) AS r,
			tokens.number
		FROM tokens
		JOIN
		(
			SELECT '[session_id]' AS column_name
			UNION ALL
			SELECT '[physical_io]'
			UNION ALL
			SELECT '[reads]'
			UNION ALL
			SELECT '[physical_reads]'
			UNION ALL
			SELECT '[writes]'
			UNION ALL
			SELECT '[tempdb_allocations]'
			UNION ALL
			SELECT '[tempdb_current]'
			UNION ALL
			SELECT '[CPU]'
			UNION ALL
			SELECT '[context_switches]'
			UNION ALL
			SELECT '[used_memory]'
			UNION ALL
			SELECT '[physical_io_delta]'
			UNION ALL
			SELECT '[reads_delta]'
			UNION ALL
			SELECT '[physical_reads_delta]'
			UNION ALL
			SELECT '[writes_delta]'
			UNION ALL
			SELECT '[tempdb_allocations_delta]'
			UNION ALL
			SELECT '[tempdb_current_delta]'
			UNION ALL
			SELECT '[CPU_delta]'
			UNION ALL
			SELECT '[context_switches_delta]'
			UNION ALL
			SELECT '[used_memory_delta]'
			UNION ALL
			SELECT '[tasks]'
			UNION ALL
			SELECT '[tran_start_time]'
			UNION ALL
			SELECT '[open_tran_count]'
			UNION ALL
			SELECT '[blocking_session_id]'
			UNION ALL
			SELECT '[blocked_session_count]'
			UNION ALL
			SELECT '[percent_complete]'
			UNION ALL
			SELECT '[host_name]'
			UNION ALL
			SELECT '[login_name]'
			UNION ALL
			SELECT '[database_name]'
			UNION ALL
			SELECT '[start_time]'
			UNION ALL
			SELECT '[login_time]'
			UNION ALL
			SELECT '[program_name]'
		) AS x ON 
			x.column_name LIKE token ESCAPE '|'
	)
	SELECT
		@sort_order = COALESCE(z.sort_order, '')
	FROM
	(
		SELECT
			STUFF
			(
				(
					SELECT
						',' + column_name as [text()]
					FROM ordered_columns
					WHERE
						r = 1
					ORDER BY
						number
					FOR XML
						PATH('')
				),
				1,
				1,
				''
			) AS sort_order
	) AS z;

	CREATE TABLE #sessions
	(
		recursion SMALLINT NOT NULL,
		session_id SMALLINT NOT NULL,
		request_id INT NOT NULL,
		session_number INT NOT NULL,
		elapsed_time INT NOT NULL,
		avg_elapsed_time INT NULL,
		physical_io BIGINT NULL,
		reads BIGINT NULL,
		physical_reads BIGINT NULL,
		writes BIGINT NULL,
		tempdb_allocations BIGINT NULL,
		tempdb_current BIGINT NULL,
		CPU INT NULL,
		thread_CPU_snapshot BIGINT NULL,
		context_switches BIGINT NULL,
		used_memory BIGINT NOT NULL, 
		tasks SMALLINT NULL,
		status VARCHAR(30) NOT NULL,
		wait_info NVARCHAR(4000) NULL,
		locks XML NULL,
		transaction_id BIGINT NULL,
		tran_start_time DATETIME NULL,
		tran_log_writes NVARCHAR(4000) NULL,
		open_tran_count SMALLINT NULL,
		sql_command XML NULL,
		sql_handle VARBINARY(64) NULL,
		statement_start_offset INT NULL,
		statement_end_offset INT NULL,
		sql_text XML NULL,
		plan_handle VARBINARY(64) NULL,
		query_plan XML NULL,
		blocking_session_id SMALLINT NULL,
		blocked_session_count SMALLINT NULL,
		percent_complete REAL NULL,
		host_name sysname NULL,
		login_name sysname NOT NULL,
		database_name sysname NULL,
		program_name sysname NULL,
		additional_info XML NULL,
		start_time DATETIME NOT NULL,
		login_time DATETIME NULL,
		last_request_start_time DATETIME NULL,
		PRIMARY KEY CLUSTERED (session_id, request_id, recursion) WITH (IGNORE_DUP_KEY = ON),
		UNIQUE NONCLUSTERED (transaction_id, session_id, request_id, recursion) WITH (IGNORE_DUP_KEY = ON)
	);

	IF @return_schema = 0
	BEGIN;
		--Disable unnecessary autostats on the table
		CREATE STATISTICS s_session_id ON #sessions (session_id)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;
		CREATE STATISTICS s_request_id ON #sessions (request_id)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;
		CREATE STATISTICS s_transaction_id ON #sessions (transaction_id)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;
		CREATE STATISTICS s_session_number ON #sessions (session_number)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;
		CREATE STATISTICS s_status ON #sessions (status)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;
		CREATE STATISTICS s_start_time ON #sessions (start_time)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;
		CREATE STATISTICS s_last_request_start_time ON #sessions (last_request_start_time)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;
		CREATE STATISTICS s_recursion ON #sessions (recursion)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;

		DECLARE @recursion SMALLINT;
		SET @recursion = 
			CASE @delta_interval
				WHEN 0 THEN 1
				ELSE -1
			END;

		DECLARE @first_collection_ms_ticks BIGINT;
		DECLARE @last_collection_start DATETIME;
		DECLARE @sys_info BIT;
		SET @sys_info = ISNULL(CONVERT(BIT, SIGN(OBJECT_ID('sys.dm_os_sys_info'))), 0);

		--Used for the delta pull
		REDO:;
		
		IF 
			@get_locks = 1 
			AND @recursion = 1
			AND @output_column_list LIKE '%|[locks|]%' ESCAPE '|'
		BEGIN;
			SELECT
				y.resource_type,
				y.database_name,
				y.object_id,
				y.file_id,
				y.page_type,
				y.hobt_id,
				y.allocation_unit_id,
				y.index_id,
				y.schema_id,
				y.principal_id,
				y.request_mode,
				y.request_status,
				y.session_id,
				y.resource_description,
				y.request_count,
				s.request_id,
				s.start_time,
				CONVERT(sysname, NULL) AS object_name,
				CONVERT(sysname, NULL) AS index_name,
				CONVERT(sysname, NULL) AS schema_name,
				CONVERT(sysname, NULL) AS principal_name,
				CONVERT(NVARCHAR(2048), NULL) AS query_error
			INTO #locks
			FROM
			(
				SELECT
					sp.spid AS session_id,
					CASE sp.status
						WHEN 'sleeping' THEN CONVERT(INT, 0)
						ELSE sp.request_id
					END AS request_id,
					CASE sp.status
						WHEN 'sleeping' THEN sp.last_batch
						ELSE COALESCE(req.start_time, sp.last_batch)
					END AS start_time,
					sp.dbid
				FROM sys.sysprocesses AS sp
				OUTER APPLY
				(
					SELECT TOP(1)
						CASE
							WHEN 
							(
								sp.hostprocess > ''
								OR r.total_elapsed_time < 0
							) THEN
								r.start_time
							ELSE
								DATEADD
								(
									ms, 
									1000 * (DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())) / 500) - DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())), 
									DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())
								)
						END AS start_time
					FROM sys.dm_exec_requests AS r
					WHERE
						r.session_id = sp.spid
						AND r.request_id = sp.request_id
				) AS req
				WHERE
					--Process inclusive filter
					1 =
						CASE
							WHEN @filter <> '' THEN
								CASE @filter_type
									WHEN 'session' THEN
										CASE
											WHEN
												CONVERT(SMALLINT, @filter) = 0
												OR sp.spid = CONVERT(SMALLINT, @filter)
													THEN 1
											ELSE 0
										END
									WHEN 'program' THEN
										CASE
											WHEN sp.program_name LIKE @filter THEN 1
											ELSE 0
										END
									WHEN 'login' THEN
										CASE
											WHEN sp.loginame LIKE @filter THEN 1
											ELSE 0
										END
									WHEN 'host' THEN
										CASE
											WHEN sp.hostname LIKE @filter THEN 1
											ELSE 0
										END
									WHEN 'database' THEN
										CASE
											WHEN DB_NAME(sp.dbid) LIKE @filter THEN 1
											ELSE 0
										END
									ELSE 0
								END
							ELSE 1
						END
					--Process exclusive filter
					AND 0 =
						CASE
							WHEN @not_filter <> '' THEN
								CASE @not_filter_type
									WHEN 'session' THEN
										CASE
											WHEN sp.spid = CONVERT(SMALLINT, @not_filter) THEN 1
											ELSE 0
										END
									WHEN 'program' THEN
										CASE
											WHEN sp.program_name LIKE @not_filter THEN 1
											ELSE 0
										END
									WHEN 'login' THEN
										CASE
											WHEN sp.loginame LIKE @not_filter THEN 1
											ELSE 0
										END
									WHEN 'host' THEN
										CASE
											WHEN sp.hostname LIKE @not_filter THEN 1
											ELSE 0
										END
									WHEN 'database' THEN
										CASE
											WHEN DB_NAME(sp.dbid) LIKE @not_filter THEN 1
											ELSE 0
										END
									ELSE 0
								END
							ELSE 0
						END
					AND 
					(
						@show_own_spid = 1
						OR sp.spid <> @@SPID
					)
					AND 
					(
						@show_system_spids = 1
						OR sp.hostprocess > ''
					)
					AND sp.ecid = 0
			) AS s
			INNER HASH JOIN
			(
				SELECT
					x.resource_type,
					x.database_name,
					x.object_id,
					x.file_id,
					CASE
						WHEN x.page_no = 1 OR x.page_no % 8088 = 0 THEN 'PFS'
						WHEN x.page_no = 2 OR x.page_no % 511232 = 0 THEN 'GAM'
						WHEN x.page_no = 3 OR (x.page_no - 1) % 511232 = 0 THEN 'SGAM'
						WHEN x.page_no = 6 OR (x.page_no - 6) % 511232 = 0 THEN 'DCM'
						WHEN x.page_no = 7 OR (x.page_no - 7) % 511232 = 0 THEN 'BCM'
						WHEN x.page_no IS NOT NULL THEN '*'
						ELSE NULL
					END AS page_type,
					x.hobt_id,
					x.allocation_unit_id,
					x.index_id,
					x.schema_id,
					x.principal_id,
					x.request_mode,
					x.request_status,
					x.session_id,
					x.request_id,
					CASE
						WHEN COALESCE(x.object_id, x.file_id, x.hobt_id, x.allocation_unit_id, x.index_id, x.schema_id, x.principal_id) IS NULL THEN NULLIF(resource_description, '')
						ELSE NULL
					END AS resource_description,
					COUNT(*) AS request_count
				FROM
				(
					SELECT
						tl.resource_type +
							CASE
								WHEN tl.resource_subtype = '' THEN ''
								ELSE '.' + tl.resource_subtype
							END AS resource_type,
						COALESCE(DB_NAME(tl.resource_database_id), N'(null)') AS database_name,
						CONVERT
						(
							INT,
							CASE
								WHEN tl.resource_type = 'OBJECT' THEN tl.resource_associated_entity_id
								WHEN tl.resource_description LIKE '%object_id = %' THEN
									(
										SUBSTRING
										(
											tl.resource_description, 
											(CHARINDEX('object_id = ', tl.resource_description) + 12), 
											COALESCE
											(
												NULLIF
												(
													CHARINDEX(',', tl.resource_description, CHARINDEX('object_id = ', tl.resource_description) + 12),
													0
												), 
												DATALENGTH(tl.resource_description)+1
											) - (CHARINDEX('object_id = ', tl.resource_description) + 12)
										)
									)
								ELSE NULL
							END
						) AS object_id,
						CONVERT
						(
							INT,
							CASE 
								WHEN tl.resource_type = 'FILE' THEN CONVERT(INT, tl.resource_description)
								WHEN tl.resource_type IN ('PAGE', 'EXTENT', 'RID') THEN LEFT(tl.resource_description, CHARINDEX(':', tl.resource_description)-1)
								ELSE NULL
							END
						) AS file_id,
						CONVERT
						(
							INT,
							CASE
								WHEN tl.resource_type IN ('PAGE', 'EXTENT', 'RID') THEN 
									SUBSTRING
									(
										tl.resource_description, 
										CHARINDEX(':', tl.resource_description) + 1, 
										COALESCE
										(
											NULLIF
											(
												CHARINDEX(':', tl.resource_description, CHARINDEX(':', tl.resource_description) + 1), 
												0
											), 
											DATALENGTH(tl.resource_description)+1
										) - (CHARINDEX(':', tl.resource_description) + 1)
									)
								ELSE NULL
							END
						) AS page_no,
						CASE
							WHEN tl.resource_type IN ('PAGE', 'KEY', 'RID', 'HOBT') THEN tl.resource_associated_entity_id
							ELSE NULL
						END AS hobt_id,
						CASE
							WHEN tl.resource_type = 'ALLOCATION_UNIT' THEN tl.resource_associated_entity_id
							ELSE NULL
						END AS allocation_unit_id,
						CONVERT
						(
							INT,
							CASE
								WHEN
									/*TODO: Deal with server principals*/ 
									tl.resource_subtype <> 'SERVER_PRINCIPAL' 
									AND tl.resource_description LIKE '%index_id or stats_id = %' THEN
									(
										SUBSTRING
										(
											tl.resource_description, 
											(CHARINDEX('index_id or stats_id = ', tl.resource_description) + 23), 
											COALESCE
											(
												NULLIF
												(
													CHARINDEX(',', tl.resource_description, CHARINDEX('index_id or stats_id = ', tl.resource_description) + 23), 
													0
												), 
												DATALENGTH(tl.resource_description)+1
											) - (CHARINDEX('index_id or stats_id = ', tl.resource_description) + 23)
										)
									)
								ELSE NULL
							END 
						) AS index_id,
						CONVERT
						(
							INT,
							CASE
								WHEN tl.resource_description LIKE '%schema_id = %' THEN
									(
										SUBSTRING
										(
											tl.resource_description, 
											(CHARINDEX('schema_id = ', tl.resource_description) + 12), 
											COALESCE
											(
												NULLIF
												(
													CHARINDEX(',', tl.resource_description, CHARINDEX('schema_id = ', tl.resource_description) + 12), 
													0
												), 
												DATALENGTH(tl.resource_description)+1
											) - (CHARINDEX('schema_id = ', tl.resource_description) + 12)
										)
									)
								ELSE NULL
							END 
						) AS schema_id,
						CONVERT
						(
							INT,
							CASE
								WHEN tl.resource_description LIKE '%principal_id = %' THEN
									(
										SUBSTRING
										(
											tl.resource_description, 
											(CHARINDEX('principal_id = ', tl.resource_description) + 15), 
											COALESCE
											(
												NULLIF
												(
													CHARINDEX(',', tl.resource_description, CHARINDEX('principal_id = ', tl.resource_description) + 15), 
													0
												), 
												DATALENGTH(tl.resource_description)+1
											) - (CHARINDEX('principal_id = ', tl.resource_description) + 15)
										)
									)
								ELSE NULL
							END
						) AS principal_id,
						tl.request_mode,
						tl.request_status,
						tl.request_session_id AS session_id,
						tl.request_request_id AS request_id,

						/*TODO: Applocks, other resource_descriptions*/
						RTRIM(tl.resource_description) AS resource_description,
						tl.resource_associated_entity_id
						/*********************************************/
					FROM 
					(
						SELECT 
							request_session_id,
							CONVERT(VARCHAR(120), resource_type) COLLATE Latin1_General_Bin2 AS resource_type,
							CONVERT(VARCHAR(120), resource_subtype) COLLATE Latin1_General_Bin2 AS resource_subtype,
							resource_database_id,
							CONVERT(VARCHAR(512), resource_description) COLLATE Latin1_General_Bin2 AS resource_description,
							resource_associated_entity_id,
							CONVERT(VARCHAR(120), request_mode) COLLATE Latin1_General_Bin2 AS request_mode,
							CONVERT(VARCHAR(120), request_status) COLLATE Latin1_General_Bin2 AS request_status,
							request_request_id
						FROM sys.dm_tran_locks
					) AS tl
				) AS x
				GROUP BY
					x.resource_type,
					x.database_name,
					x.object_id,
					x.file_id,
					CASE
						WHEN x.page_no = 1 OR x.page_no % 8088 = 0 THEN 'PFS'
						WHEN x.page_no = 2 OR x.page_no % 511232 = 0 THEN 'GAM'
						WHEN x.page_no = 3 OR (x.page_no - 1) % 511232 = 0 THEN 'SGAM'
						WHEN x.page_no = 6 OR (x.page_no - 6) % 511232 = 0 THEN 'DCM'
						WHEN x.page_no = 7 OR (x.page_no - 7) % 511232 = 0 THEN 'BCM'
						WHEN x.page_no IS NOT NULL THEN '*'
						ELSE NULL
					END,
					x.hobt_id,
					x.allocation_unit_id,
					x.index_id,
					x.schema_id,
					x.principal_id,
					x.request_mode,
					x.request_status,
					x.session_id,
					x.request_id,
					CASE
						WHEN COALESCE(x.object_id, x.file_id, x.hobt_id, x.allocation_unit_id, x.index_id, x.schema_id, x.principal_id) IS NULL THEN NULLIF(resource_description, '')
						ELSE NULL
					END
			) AS y ON
				y.session_id = s.session_id
				AND y.request_id = s.request_id
			OPTION (HASH GROUP);

			--Disable unnecessary autostats on the table
			CREATE STATISTICS s_database_name ON #locks (database_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_object_id ON #locks (object_id)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_hobt_id ON #locks (hobt_id)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_allocation_unit_id ON #locks (allocation_unit_id)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_index_id ON #locks (index_id)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_schema_id ON #locks (schema_id)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_principal_id ON #locks (principal_id)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_request_id ON #locks (request_id)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_start_time ON #locks (start_time)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_resource_type ON #locks (resource_type)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_object_name ON #locks (object_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_schema_name ON #locks (schema_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_page_type ON #locks (page_type)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_request_mode ON #locks (request_mode)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_request_status ON #locks (request_status)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_resource_description ON #locks (resource_description)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_index_name ON #locks (index_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_principal_name ON #locks (principal_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
		END;
		
		DECLARE 
			@sql VARCHAR(MAX), 
			@sql_n NVARCHAR(MAX);

		SET @sql = 
			CONVERT(VARCHAR(MAX), '') +
			'DECLARE @blocker BIT;
			SET @blocker = 0;
			DECLARE @i INT;
			SET @i = 2147483647;

			DECLARE @sessions TABLE
			(
				session_id SMALLINT NOT NULL,
				request_id INT NOT NULL,
				login_time DATETIME,
				last_request_end_time DATETIME,
				status VARCHAR(30),
				statement_start_offset INT,
				statement_end_offset INT,
				sql_handle BINARY(20),
				host_name NVARCHAR(128),
				login_name NVARCHAR(128),
				program_name NVARCHAR(128),
				database_id SMALLINT,
				memory_usage INT,
				open_tran_count SMALLINT, 
				' +
				CASE
					WHEN 
					(
						@get_task_info <> 0 
						OR @find_block_leaders = 1 
					) THEN
						'wait_type NVARCHAR(32),
						wait_resource NVARCHAR(256),
						wait_time BIGINT, 
						'
					ELSE 
						''
				END +
				'blocked SMALLINT,
				is_user_process BIT,
				cmd VARCHAR(32),
				PRIMARY KEY CLUSTERED (session_id, request_id) WITH (IGNORE_DUP_KEY = ON)
			);

			DECLARE @blockers TABLE
			(
				session_id INT NOT NULL PRIMARY KEY WITH (IGNORE_DUP_KEY = ON)
			);

			BLOCKERS:;

			INSERT @sessions
			(
				session_id,
				request_id,
				login_time,
				last_request_end_time,
				status,
				statement_start_offset,
				statement_end_offset,
				sql_handle,
				host_name,
				login_name,
				program_name,
				database_id,
				memory_usage,
				open_tran_count, 
				' +
				CASE
					WHEN 
					(
						@get_task_info <> 0
						OR @find_block_leaders = 1 
					) THEN
						'wait_type,
						wait_resource,
						wait_time, 
						'
					ELSE
						''
				END +
				'blocked,
				is_user_process,
				cmd 
			)
			SELECT TOP(@i)
				spy.session_id,
				spy.request_id,
				spy.login_time,
				spy.last_request_end_time,
				spy.status,
				spy.statement_start_offset,
				spy.statement_end_offset,
				spy.sql_handle,
				spy.host_name,
				spy.login_name,
				spy.program_name,
				spy.database_id,
				spy.memory_usage,
				spy.open_tran_count,
				' +
				CASE
					WHEN 
					(
						@get_task_info <> 0  
						OR @find_block_leaders = 1 
					) THEN
						'spy.wait_type,
						CASE
							WHEN
								spy.wait_type LIKE N''PAGE%LATCH_%''
								OR spy.wait_type = N''CXPACKET''
								OR spy.wait_type LIKE N''LATCH[_]%''
								OR spy.wait_type = N''OLEDB'' THEN
									spy.wait_resource
							ELSE
								NULL
						END AS wait_resource,
						spy.wait_time, 
						'
					ELSE
						''
				END +
				'spy.blocked,
				spy.is_user_process,
				spy.cmd
			FROM
			(
				SELECT TOP(@i)
					spx.*, 
					' +
					CASE
						WHEN 
						(
							@get_task_info <> 0 
							OR @find_block_leaders = 1 
						) THEN
							'ROW_NUMBER() OVER
							(
								PARTITION BY
									spx.session_id,
									spx.request_id
								ORDER BY
									CASE
										WHEN spx.wait_type LIKE N''LCK[_]%'' THEN 
											1
										ELSE
											99
									END,
									spx.wait_time DESC,
									spx.blocked DESC
							) AS r 
							'
						ELSE 
							'1 AS r 
							'
					END +
				'FROM
				(
					SELECT TOP(@i)
						sp0.session_id,
						sp0.request_id,
						sp0.login_time,
						sp0.last_request_end_time,
						LOWER(sp0.status) AS status,
						CASE
							WHEN sp0.cmd = ''CREATE INDEX'' THEN
								0
							ELSE
								sp0.stmt_start
						END AS statement_start_offset,
						CASE
							WHEN sp0.cmd = N''CREATE INDEX'' THEN
								-1
							ELSE
								COALESCE(NULLIF(sp0.stmt_end, 0), -1)
						END AS statement_end_offset,
						sp0.sql_handle,
						sp0.host_name,
						sp0.login_name,
						sp0.program_name,
						sp0.database_id,
						sp0.memory_usage,
						sp0.open_tran_count, 
						' +
						CASE
							WHEN 
							(
								@get_task_info <> 0 
								OR @find_block_leaders = 1 
							) THEN
								'CASE
									WHEN sp0.wait_time > 0 AND sp0.wait_type <> N''CXPACKET'' THEN
										sp0.wait_type
									ELSE
										NULL
								END AS wait_type,
								CASE
									WHEN sp0.wait_time > 0 AND sp0.wait_type <> N''CXPACKET'' THEN 
										sp0.wait_resource
									ELSE
										NULL
								END AS wait_resource,
								CASE
									WHEN sp0.wait_type <> N''CXPACKET'' THEN
										sp0.wait_time
									ELSE
										0
								END AS wait_time, 
								'
							ELSE
								''
						END +
						'sp0.blocked,
						sp0.is_user_process,
						sp0.cmd
					FROM
					(
						SELECT TOP(@i)
							sp1.session_id,
							sp1.request_id,
							sp1.login_time,
							sp1.last_request_end_time,
							sp1.status,
							sp1.cmd,
							sp1.stmt_start,
							sp1.stmt_end,
							MAX(NULLIF(sp1.sql_handle, 0x00)) OVER (PARTITION BY sp1.session_id, sp1.request_id) AS sql_handle,
							sp1.host_name,
							MAX(sp1.login_name) OVER (PARTITION BY sp1.session_id, sp1.request_id) AS login_name,
							sp1.program_name,
							sp1.database_id,
							MAX(sp1.memory_usage)  OVER (PARTITION BY sp1.session_id, sp1.request_id) AS memory_usage,
							MAX(sp1.open_tran_count)  OVER (PARTITION BY sp1.session_id, sp1.request_id) AS open_tran_count,
							sp1.wait_type,
							sp1.wait_resource,
							sp1.wait_time,
							sp1.blocked,
							sp1.hostprocess,
							sp1.is_user_process
						FROM
						(
							SELECT TOP(@i)
								sp2.spid AS session_id,
								CASE sp2.status
									WHEN ''sleeping'' THEN
										CONVERT(INT, 0)
									ELSE
										sp2.request_id
								END AS request_id,
								MAX(sp2.login_time) AS login_time,
								MAX(sp2.last_batch) AS last_request_end_time,
								MAX(CONVERT(VARCHAR(30), RTRIM(sp2.status)) COLLATE Latin1_General_Bin2) AS status,
								MAX(CONVERT(VARCHAR(32), RTRIM(sp2.cmd)) COLLATE Latin1_General_Bin2) AS cmd,
								MAX(sp2.stmt_start) AS stmt_start,
								MAX(sp2.stmt_end) AS stmt_end,
								MAX(sp2.sql_handle) AS sql_handle,
								MAX(CONVERT(sysname, RTRIM(sp2.hostname)) COLLATE SQL_Latin1_General_CP1_CI_AS) AS host_name,
								MAX(CONVERT(sysname, RTRIM(sp2.loginame)) COLLATE SQL_Latin1_General_CP1_CI_AS) AS login_name,
								MAX
								(
									CASE
										WHEN blk.queue_id IS NOT NULL THEN
											N''Service Broker
												database_id: '' + CONVERT(NVARCHAR, blk.database_id) +
												N'' queue_id: '' + CONVERT(NVARCHAR, blk.queue_id)
										ELSE
											CONVERT
											(
												sysname,
												RTRIM(sp2.program_name)
											)
									END COLLATE SQL_Latin1_General_CP1_CI_AS
								) AS program_name,
								MAX(sp2.dbid) AS database_id,
								MAX(sp2.memusage) AS memory_usage,
								MAX(sp2.open_tran) AS open_tran_count,
								RTRIM(sp2.lastwaittype) AS wait_type,
								RTRIM(sp2.waitresource) AS wait_resource,
								MAX(sp2.waittime) AS wait_time,
								COALESCE(NULLIF(sp2.blocked, sp2.spid), 0) AS blocked,
								MAX
								(
									CASE
										WHEN blk.session_id = sp2.spid THEN
											''blocker''
										ELSE
											RTRIM(sp2.hostprocess)
									END
								) AS hostprocess,
								CONVERT
								(
									BIT,
									MAX
									(
										CASE
											WHEN sp2.hostprocess > '''' THEN
												1
											ELSE
												0
										END
									)
								) AS is_user_process
							FROM
							(
								SELECT TOP(@i)
									session_id,
									CONVERT(INT, NULL) AS queue_id,
									CONVERT(INT, NULL) AS database_id
								FROM @blockers

								UNION ALL

								SELECT TOP(@i)
									CONVERT(SMALLINT, 0),
									CONVERT(INT, NULL) AS queue_id,
									CONVERT(INT, NULL) AS database_id
								WHERE
									@blocker = 0

								UNION ALL

								SELECT TOP(@i)
									CONVERT(SMALLINT, spid),
									queue_id,
									database_id
								FROM sys.dm_broker_activated_tasks
								WHERE
									@blocker = 0
							) AS blk
							INNER JOIN sys.sysprocesses AS sp2 ON
								sp2.spid = blk.session_id
								OR
								(
									blk.session_id = 0
									AND @blocker = 0
								)
							' +
							CASE 
								WHEN 
								(
									@get_task_info = 0 
									AND @find_block_leaders = 0
								) THEN
									'WHERE
										sp2.ecid = 0 
									' 
								ELSE
									''
							END +
							'GROUP BY
								sp2.spid,
								CASE sp2.status
									WHEN ''sleeping'' THEN
										CONVERT(INT, 0)
									ELSE
										sp2.request_id
								END,
								RTRIM(sp2.lastwaittype),
								RTRIM(sp2.waitresource),
								COALESCE(NULLIF(sp2.blocked, sp2.spid), 0)
						) AS sp1
					) AS sp0
					WHERE
						@blocker = 1
						OR
						(1=1 
						' +
							--inclusive filter
							CASE
								WHEN @filter <> '' THEN
									CASE @filter_type
										WHEN 'session' THEN
											CASE
												WHEN CONVERT(SMALLINT, @filter) <> 0 THEN
													'AND sp0.session_id = CONVERT(SMALLINT, @filter) 
													'
												ELSE
													''
											END
										WHEN 'program' THEN
											'AND sp0.program_name LIKE @filter 
											'
										WHEN 'login' THEN
											'AND sp0.login_name LIKE @filter 
											'
										WHEN 'host' THEN
											'AND sp0.host_name LIKE @filter 
											'
										WHEN 'database' THEN
											'AND DB_NAME(sp0.database_id) LIKE @filter 
											'
										ELSE
											''
									END
								ELSE
									''
							END +
							--exclusive filter
							CASE
								WHEN @not_filter <> '' THEN
									CASE @not_filter_type
										WHEN 'session' THEN
											CASE
												WHEN CONVERT(SMALLINT, @not_filter) <> 0 THEN
													'AND sp0.session_id <> CONVERT(SMALLINT, @not_filter) 
													'
												ELSE
													''
											END
										WHEN 'program' THEN
											'AND sp0.program_name NOT LIKE @not_filter 
											'
										WHEN 'login' THEN
											'AND sp0.login_name NOT LIKE @not_filter 
											'
										WHEN 'host' THEN
											'AND sp0.host_name NOT LIKE @not_filter 
											'
										WHEN 'database' THEN
											'AND DB_NAME(sp0.database_id) NOT LIKE @not_filter 
											'
										ELSE
											''
									END
								ELSE
									''
							END +
							CASE @show_own_spid
								WHEN 1 THEN
									''
								ELSE
									'AND sp0.session_id <> @@spid 
									'
							END +
							CASE 
								WHEN @show_system_spids = 0 THEN
									'AND sp0.hostprocess > '''' 
									' 
								ELSE
									''
							END +
							CASE @show_sleeping_spids
								WHEN 0 THEN
									'AND sp0.status <> ''sleeping'' 
									'
								WHEN 1 THEN
									'AND
									(
										sp0.status <> ''sleeping''
										OR sp0.open_tran_count > 0
									)
									'
								ELSE
									''
							END +
						')
				) AS spx
			) AS spy
			WHERE
				spy.r = 1; 
			' + 
			CASE @recursion
				WHEN 1 THEN 
					'IF @@ROWCOUNT > 0
					BEGIN;
						INSERT @blockers
						(
							session_id
						)
						SELECT TOP(@i)
							blocked
						FROM @sessions
						WHERE
							NULLIF(blocked, 0) IS NOT NULL

						EXCEPT

						SELECT TOP(@i)
							session_id
						FROM @sessions; 
						' +

						CASE
							WHEN
							(
								@get_task_info > 0
								OR @find_block_leaders = 1
							) THEN
								'IF @@ROWCOUNT > 0
								BEGIN;
									SET @blocker = 1;
									GOTO BLOCKERS;
								END; 
								'
							ELSE 
								''
						END +
					'END; 
					'
				ELSE 
					''
			END +
			'SELECT TOP(@i)
				@recursion AS recursion,
				x.session_id,
				x.request_id,
				DENSE_RANK() OVER
				(
					ORDER BY
						x.session_id
				) AS session_number,
				' +
				CASE
					WHEN @output_column_list LIKE '%|[dd hh:mm:ss.mss|]%' ESCAPE '|' THEN 
						'x.elapsed_time '
					ELSE 
						'0 '
				END + 
					'AS elapsed_time, 
					' +
				CASE
					WHEN
						(
							@output_column_list LIKE '%|[dd hh:mm:ss.mss (avg)|]%' ESCAPE '|' OR 
							@output_column_list LIKE '%|[avg_elapsed_time|]%' ESCAPE '|'
						)
						AND @recursion = 1
							THEN 
								'x.avg_elapsed_time / 1000 '
					ELSE 
						'NULL '
				END + 
					'AS avg_elapsed_time, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[physical_io|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[physical_io_delta|]%' ESCAPE '|'
							THEN 
								'x.physical_io '
					ELSE 
						'NULL '
				END + 
					'AS physical_io, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[reads|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[reads_delta|]%' ESCAPE '|'
							THEN 
								'x.reads '
					ELSE 
						'0 '
				END + 
					'AS reads, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[physical_reads|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[physical_reads_delta|]%' ESCAPE '|'
							THEN 
								'x.physical_reads '
					ELSE 
						'0 '
				END + 
					'AS physical_reads, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[writes|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[writes_delta|]%' ESCAPE '|'
							THEN 
								'x.writes '
					ELSE 
						'0 '
				END + 
					'AS writes, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[tempdb_allocations|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[tempdb_allocations_delta|]%' ESCAPE '|'
							THEN 
								'x.tempdb_allocations '
					ELSE 
						'0 '
				END + 
					'AS tempdb_allocations, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[tempdb_current|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[tempdb_current_delta|]%' ESCAPE '|'
							THEN 
								'x.tempdb_current '
					ELSE 
						'0 '
				END + 
					'AS tempdb_current, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[CPU|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[CPU_delta|]%' ESCAPE '|'
							THEN
								'x.CPU '
					ELSE
						'0 '
				END + 
					'AS CPU, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[CPU_delta|]%' ESCAPE '|'
						AND @get_task_info = 2
						AND @sys_info = 1
							THEN 
								'x.thread_CPU_snapshot '
					ELSE 
						'0 '
				END + 
					'AS thread_CPU_snapshot, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[context_switches|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[context_switches_delta|]%' ESCAPE '|'
							THEN 
								'x.context_switches '
					ELSE 
						'NULL '
				END + 
					'AS context_switches, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[used_memory|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[used_memory_delta|]%' ESCAPE '|'
							THEN 
								'x.used_memory '
					ELSE 
						'0 '
				END + 
					'AS used_memory, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[tasks|]%' ESCAPE '|'
						AND @recursion = 1
							THEN 
								'x.tasks '
					ELSE 
						'NULL '
				END + 
					'AS tasks, 
					' +
				CASE
					WHEN 
						(
							@output_column_list LIKE '%|[status|]%' ESCAPE '|' 
							OR @output_column_list LIKE '%|[sql_command|]%' ESCAPE '|'
						)
						AND @recursion = 1
							THEN 
								'x.status '
					ELSE 
						''''' '
				END + 
					'AS status, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[wait_info|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 
								CASE @get_task_info
									WHEN 2 THEN
										'COALESCE(x.task_wait_info, x.sys_wait_info) '
									ELSE
										'x.sys_wait_info '
								END
					ELSE 
						'NULL '
				END + 
					'AS wait_info, 
					' +
				CASE
					WHEN 
						(
							@output_column_list LIKE '%|[tran_start_time|]%' ESCAPE '|' 
							OR @output_column_list LIKE '%|[tran_log_writes|]%' ESCAPE '|' 
						)
						AND @recursion = 1
							THEN 
								'x.transaction_id '
					ELSE 
						'NULL '
				END + 
					'AS transaction_id, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[open_tran_count|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 
								'x.open_tran_count '
					ELSE 
						'NULL '
				END + 
					'AS open_tran_count, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[sql_text|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 
								'x.sql_handle '
					ELSE 
						'NULL '
				END + 
					'AS sql_handle, 
					' +
				CASE
					WHEN 
						(
							@output_column_list LIKE '%|[sql_text|]%' ESCAPE '|' 
							OR @output_column_list LIKE '%|[query_plan|]%' ESCAPE '|' 
						)
						AND @recursion = 1
							THEN 
								'x.statement_start_offset '
					ELSE 
						'NULL '
				END + 
					'AS statement_start_offset, 
					' +
				CASE
					WHEN 
						(
							@output_column_list LIKE '%|[sql_text|]%' ESCAPE '|' 
							OR @output_column_list LIKE '%|[query_plan|]%' ESCAPE '|' 
						)
						AND @recursion = 1
							THEN 
								'x.statement_end_offset '
					ELSE 
						'NULL '
				END + 
					'AS statement_end_offset, 
					' +
				'NULL AS sql_text, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[query_plan|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 
								'x.plan_handle '
					ELSE 
						'NULL '
				END + 
					'AS plan_handle, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[blocking_session_id|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 
								'NULLIF(x.blocking_session_id, 0) '
					ELSE 
						'NULL '
				END + 
					'AS blocking_session_id, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[percent_complete|]%' ESCAPE '|'
						AND @recursion = 1
							THEN 
								'x.percent_complete '
					ELSE 
						'NULL '
				END + 
					'AS percent_complete, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[host_name|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 
								'x.host_name '
					ELSE 
						''''' '
				END + 
					'AS host_name, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[login_name|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 
								'x.login_name '
					ELSE 
						''''' '
				END + 
					'AS login_name, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[database_name|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 
								'DB_NAME(x.database_id) '
					ELSE 
						'NULL '
				END + 
					'AS database_name, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[program_name|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 
								'x.program_name '
					ELSE 
						''''' '
				END + 
					'AS program_name, 
					' +
				CASE
					WHEN
						@output_column_list LIKE '%|[additional_info|]%' ESCAPE '|'
						AND @recursion = 1
							THEN
								'(
									SELECT TOP(@i)
										x.text_size,
										x.language,
										x.date_format,
										x.date_first,
										CASE x.quoted_identifier
											WHEN 0 THEN ''OFF''
											WHEN 1 THEN ''ON''
										END AS quoted_identifier,
										CASE x.arithabort
											WHEN 0 THEN ''OFF''
											WHEN 1 THEN ''ON''
										END AS arithabort,
										CASE x.ansi_null_dflt_on
											WHEN 0 THEN ''OFF''
											WHEN 1 THEN ''ON''
										END AS ansi_null_dflt_on,
										CASE x.ansi_defaults
											WHEN 0 THEN ''OFF''
											WHEN 1 THEN ''ON''
										END AS ansi_defaults,
										CASE x.ansi_warnings
											WHEN 0 THEN ''OFF''
											WHEN 1 THEN ''ON''
										END AS ansi_warnings,
										CASE x.ansi_padding
											WHEN 0 THEN ''OFF''
											WHEN 1 THEN ''ON''
										END AS ansi_padding,
										CASE ansi_nulls
											WHEN 0 THEN ''OFF''
											WHEN 1 THEN ''ON''
										END AS ansi_nulls,
										CASE x.concat_null_yields_null
											WHEN 0 THEN ''OFF''
											WHEN 1 THEN ''ON''
										END AS concat_null_yields_null,
										CASE x.transaction_isolation_level
											WHEN 0 THEN ''Unspecified''
											WHEN 1 THEN ''ReadUncomitted''
											WHEN 2 THEN ''ReadCommitted''
											WHEN 3 THEN ''Repeatable''
											WHEN 4 THEN ''Serializable''
											WHEN 5 THEN ''Snapshot''
										END AS transaction_isolation_level,
										x.lock_timeout,
										x.deadlock_priority,
										x.row_count,
										x.command_type, 
										' +
										CASE
											WHEN OBJECT_ID('master.dbo.fn_varbintohexstr') IS NOT NULL THEN
												'master.dbo.fn_varbintohexstr(x.sql_handle) AS sql_handle,
												master.dbo.fn_varbintohexstr(x.plan_handle) AS plan_handle,'
											ELSE
												'CONVERT(VARCHAR(256), x.sql_handle, 1) AS sql_handle,
												CONVERT(VARCHAR(256), x.plan_handle, 1) AS plan_handle,'
										END +
										'
										x.statement_start_offset,
										x.statement_end_offset,
										' +
										CASE
											WHEN @output_column_list LIKE '%|[program_name|]%' ESCAPE '|' THEN
												'(
													SELECT TOP(1)
														CONVERT(uniqueidentifier, CONVERT(XML, '''').value(''xs:hexBinary( substring(sql:column("agent_info.job_id_string"), 0) )'', ''binary(16)'')) AS job_id,
														agent_info.step_id,
														(
															SELECT TOP(1)
																NULL
															FOR XML
																PATH(''job_name''),
																TYPE
														),
														(
															SELECT TOP(1)
																NULL
															FOR XML
																PATH(''step_name''),
																TYPE
														)
													FROM
													(
														SELECT TOP(1)
															SUBSTRING(x.program_name, CHARINDEX(''0x'', x.program_name) + 2, 32) AS job_id_string,
															SUBSTRING(x.program_name, CHARINDEX('': Step '', x.program_name) + 7, CHARINDEX('')'', x.program_name, CHARINDEX('': Step '', x.program_name)) - (CHARINDEX('': Step '', x.program_name) + 7)) AS step_id
														WHERE
															x.program_name LIKE N''SQLAgent - TSQL JobStep (Job 0x%''
													) AS agent_info
													FOR XML
														PATH(''agent_job_info''),
														TYPE
												),
												'
											ELSE ''
										END +
										CASE
											WHEN @get_task_info = 2 THEN
												'CONVERT(XML, x.block_info) AS block_info, 
												'
											ELSE
												''
										END + '
										x.host_process_id,
										x.group_id
									FOR XML
										PATH(''additional_info''),
										TYPE
								) '
					ELSE
						'NULL '
				END + 
					'AS additional_info, 
				x.start_time, 
					' +
				CASE
					WHEN
						@output_column_list LIKE '%|[login_time|]%' ESCAPE '|'
						AND @recursion = 1
							THEN
								'x.login_time '
					ELSE 
						'NULL '
				END + 
					'AS login_time, 
				x.last_request_start_time
			FROM
			(
				SELECT TOP(@i)
					y.*,
					CASE
						WHEN DATEDIFF(hour, y.start_time, GETDATE()) > 576 THEN
							DATEDIFF(second, GETDATE(), y.start_time)
						ELSE DATEDIFF(ms, y.start_time, GETDATE())
					END AS elapsed_time,
					COALESCE(tempdb_info.tempdb_allocations, 0) AS tempdb_allocations,
					COALESCE
					(
						CASE
							WHEN tempdb_info.tempdb_current < 0 THEN 0
							ELSE tempdb_info.tempdb_current
						END,
						0
					) AS tempdb_current, 
					' +
					CASE
						WHEN 
							(
								@get_task_info <> 0
								OR @find_block_leaders = 1
							) THEN
								'N''('' + CONVERT(NVARCHAR, y.wait_duration_ms) + N''ms)'' +
									y.wait_type +
										CASE
											WHEN y.wait_type LIKE N''PAGE%LATCH_%'' THEN
												N'':'' +
												COALESCE(DB_NAME(CONVERT(INT, LEFT(y.resource_description, CHARINDEX(N'':'', y.resource_description) - 1))), N''(null)'') +
												N'':'' +
												SUBSTRING(y.resource_description, CHARINDEX(N'':'', y.resource_description) + 1, LEN(y.resource_description) - CHARINDEX(N'':'', REVERSE(y.resource_description)) - CHARINDEX(N'':'', y.resource_description)) +
												N''('' +
													CASE
														WHEN
															CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) = 1 OR
															CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) % 8088 = 0
																THEN 
																	N''PFS''
														WHEN
															CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) = 2 OR
															CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) % 511232 = 0
																THEN 
																	N''GAM''
														WHEN
															CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) = 3 OR
															(CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) - 1) % 511232 = 0
																THEN
																	N''SGAM''
														WHEN
															CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) = 6 OR
															(CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) - 6) % 511232 = 0 
																THEN 
																	N''DCM''
														WHEN
															CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) = 7 OR
															(CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) - 7) % 511232 = 0 
																THEN 
																	N''BCM''
														ELSE 
															N''*''
													END +
												N'')''
											WHEN y.wait_type = N''CXPACKET'' THEN
												N'':'' + SUBSTRING(y.resource_description, CHARINDEX(N''nodeId'', y.resource_description) + 7, 4)
											WHEN y.wait_type LIKE N''LATCH[_]%'' THEN
												N'' ['' + LEFT(y.resource_description, COALESCE(NULLIF(CHARINDEX(N'' '', y.resource_description), 0), LEN(y.resource_description) + 1) - 1) + N'']''
											WHEN
												y.wait_type = N''OLEDB''
												AND y.resource_description LIKE N''%(SPID=%)'' THEN
													N''['' + LEFT(y.resource_description, CHARINDEX(N''(SPID='', y.resource_description) - 2) +
														N'':'' + SUBSTRING(y.resource_description, CHARINDEX(N''(SPID='', y.resource_description) + 6, CHARINDEX(N'')'', y.resource_description, (CHARINDEX(N''(SPID='', y.resource_description) + 6)) - (CHARINDEX(N''(SPID='', y.resource_description) + 6)) + '']''
											ELSE
												N''''
										END COLLATE Latin1_General_Bin2 AS sys_wait_info, 
										'
							ELSE
								''
						END +
						CASE
							WHEN @get_task_info = 2 THEN
								'tasks.physical_io,
								tasks.context_switches,
								tasks.tasks,
								tasks.block_info,
								tasks.wait_info AS task_wait_info,
								tasks.thread_CPU_snapshot,
								'
							ELSE
								'' 
					END +
					CASE 
						WHEN NOT (@get_avg_time = 1 AND @recursion = 1) THEN
							'CONVERT(INT, NULL) '
						ELSE 
							'qs.total_elapsed_time / qs.execution_count '
					END + 
						'AS avg_elapsed_time 
				FROM
				(
					SELECT TOP(@i)
						sp.session_id,
						sp.request_id,
						COALESCE(r.logical_reads, s.logical_reads) AS reads,
						COALESCE(r.reads, s.reads) AS physical_reads,
						COALESCE(r.writes, s.writes) AS writes,
						COALESCE(r.CPU_time, s.CPU_time) AS CPU,
						sp.memory_usage + COALESCE(r.granted_query_memory, 0) AS used_memory,
						LOWER(sp.status) AS status,
						COALESCE(r.sql_handle, sp.sql_handle) AS sql_handle,
						COALESCE(r.statement_start_offset, sp.statement_start_offset) AS statement_start_offset,
						COALESCE(r.statement_end_offset, sp.statement_end_offset) AS statement_end_offset,
						' +
						CASE
							WHEN 
							(
								@get_task_info <> 0
								OR @find_block_leaders = 1 
							) THEN
								'sp.wait_type COLLATE Latin1_General_Bin2 AS wait_type,
								sp.wait_resource COLLATE Latin1_General_Bin2 AS resource_description,
								sp.wait_time AS wait_duration_ms, 
								'
							ELSE
								''
						END +
						'NULLIF(sp.blocked, 0) AS blocking_session_id,
						r.plan_handle,
						NULLIF(r.percent_complete, 0) AS percent_complete,
						sp.host_name,
						sp.login_name,
						sp.program_name,
						s.host_process_id,
						COALESCE(r.text_size, s.text_size) AS text_size,
						COALESCE(r.language, s.language) AS language,
						COALESCE(r.date_format, s.date_format) AS date_format,
						COALESCE(r.date_first, s.date_first) AS date_first,
						COALESCE(r.quoted_identifier, s.quoted_identifier) AS quoted_identifier,
						COALESCE(r.arithabort, s.arithabort) AS arithabort,
						COALESCE(r.ansi_null_dflt_on, s.ansi_null_dflt_on) AS ansi_null_dflt_on,
						COALESCE(r.ansi_defaults, s.ansi_defaults) AS ansi_defaults,
						COALESCE(r.ansi_warnings, s.ansi_warnings) AS ansi_warnings,
						COALESCE(r.ansi_padding, s.ansi_padding) AS ansi_padding,
						COALESCE(r.ansi_nulls, s.ansi_nulls) AS ansi_nulls,
						COALESCE(r.concat_null_yields_null, s.concat_null_yields_null) AS concat_null_yields_null,
						COALESCE(r.transaction_isolation_level, s.transaction_isolation_level) AS transaction_isolation_level,
						COALESCE(r.lock_timeout, s.lock_timeout) AS lock_timeout,
						COALESCE(r.deadlock_priority, s.deadlock_priority) AS deadlock_priority,
						COALESCE(r.row_count, s.row_count) AS row_count,
						COALESCE(r.command, sp.cmd) AS command_type,
						COALESCE
						(
							CASE
								WHEN
								(
									s.is_user_process = 0
									AND r.total_elapsed_time >= 0
								) THEN
									DATEADD
									(
										ms,
										1000 * (DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())) / 500) - DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())),
										DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())
									)
							END,
							NULLIF(COALESCE(r.start_time, sp.last_request_end_time), CONVERT(DATETIME, ''19000101'', 112)),
							sp.login_time
						) AS start_time,
						sp.login_time,
						CASE
							WHEN s.is_user_process = 1 THEN
								s.last_request_start_time
							ELSE
								COALESCE
								(
									DATEADD
									(
										ms,
										1000 * (DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())) / 500) - DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())),
										DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())
									),
									s.last_request_start_time
								)
						END AS last_request_start_time,
						r.transaction_id,
						sp.database_id,
						sp.open_tran_count,
						' +
							CASE
								WHEN EXISTS
								(
									SELECT
										*
									FROM sys.all_columns AS ac
									WHERE
										ac.object_id = OBJECT_ID('sys.dm_exec_sessions')
										AND ac.name = 'group_id'
								)
									THEN 's.group_id'
								ELSE 'CONVERT(INT, NULL) AS group_id'
							END + '
					FROM @sessions AS sp
					LEFT OUTER LOOP JOIN sys.dm_exec_sessions AS s ON
						s.session_id = sp.session_id
						AND s.login_time = sp.login_time
					LEFT OUTER LOOP JOIN sys.dm_exec_requests AS r ON
						sp.status <> ''sleeping''
						AND r.session_id = sp.session_id
						AND r.request_id = sp.request_id
						AND
						(
							(
								s.is_user_process = 0
								AND sp.is_user_process = 0
							)
							OR
							(
								r.start_time = s.last_request_start_time
								AND s.last_request_end_time <= sp.last_request_end_time
							)
						)
				) AS y
				' + 
				CASE 
					WHEN @get_task_info = 2 THEN
						CONVERT(VARCHAR(MAX), '') +
						'LEFT OUTER HASH JOIN
						(
							SELECT TOP(@i)
								task_nodes.task_node.value(''(session_id/text())[1]'', ''SMALLINT'') AS session_id,
								task_nodes.task_node.value(''(request_id/text())[1]'', ''INT'') AS request_id,
								task_nodes.task_node.value(''(physical_io/text())[1]'', ''BIGINT'') AS physical_io,
								task_nodes.task_node.value(''(context_switches/text())[1]'', ''BIGINT'') AS context_switches,
								task_nodes.task_node.value(''(tasks/text())[1]'', ''INT'') AS tasks,
								task_nodes.task_node.value(''(block_info/text())[1]'', ''NVARCHAR(4000)'') AS block_info,
								task_nodes.task_node.value(''(waits/text())[1]'', ''NVARCHAR(4000)'') AS wait_info,
								task_nodes.task_node.value(''(thread_CPU_snapshot/text())[1]'', ''BIGINT'') AS thread_CPU_snapshot
							FROM
							(
								SELECT TOP(@i)
									CONVERT
									(
										XML,
										REPLACE
										(
											CONVERT(NVARCHAR(MAX), tasks_raw.task_xml_raw) COLLATE Latin1_General_Bin2,
											N''</waits></tasks><tasks><waits>'',
											N'', ''
										)
									) AS task_xml
								FROM
								(
									SELECT TOP(@i)
										CASE waits.r
											WHEN 1 THEN
												waits.session_id
											ELSE
												NULL
										END AS [session_id],
										CASE waits.r
											WHEN 1 THEN
												waits.request_id
											ELSE
												NULL
										END AS [request_id],											
										CASE waits.r
											WHEN 1 THEN
												waits.physical_io
											ELSE
												NULL
										END AS [physical_io],
										CASE waits.r
											WHEN 1 THEN
												waits.context_switches
											ELSE
												NULL
										END AS [context_switches],
										CASE waits.r
											WHEN 1 THEN
												waits.thread_CPU_snapshot
											ELSE
												NULL
										END AS [thread_CPU_snapshot],
										CASE waits.r
											WHEN 1 THEN
												waits.tasks
											ELSE
												NULL
										END AS [tasks],
										CASE waits.r
											WHEN 1 THEN
												waits.block_info
											ELSE
												NULL
										END AS [block_info],
										REPLACE
										(
											REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
											REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
											REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
												CONVERT
												(
													NVARCHAR(MAX),
													N''('' +
														CONVERT(NVARCHAR, num_waits) + N''x: '' +
														CASE num_waits
															WHEN 1 THEN
																CONVERT(NVARCHAR, min_wait_time) + N''ms''
															WHEN 2 THEN
																CASE
																	WHEN min_wait_time <> max_wait_time THEN
																		CONVERT(NVARCHAR, min_wait_time) + N''/'' + CONVERT(NVARCHAR, max_wait_time) + N''ms''
																	ELSE
																		CONVERT(NVARCHAR, max_wait_time) + N''ms''
																END
															ELSE
																CASE
																	WHEN min_wait_time <> max_wait_time THEN
																		CONVERT(NVARCHAR, min_wait_time) + N''/'' + CONVERT(NVARCHAR, avg_wait_time) + N''/'' + CONVERT(NVARCHAR, max_wait_time) + N''ms''
																	ELSE 
																		CONVERT(NVARCHAR, max_wait_time) + N''ms''
																END
														END +
													N'')'' + wait_type COLLATE Latin1_General_Bin2
												),
												NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''),
												NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''),
												NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''),
											NCHAR(0),
											N''''
										) AS [waits]
									FROM
									(
										SELECT TOP(@i)
											w1.*,
											ROW_NUMBER() OVER
											(
												PARTITION BY
													w1.session_id,
													w1.request_id
												ORDER BY
													w1.block_info DESC,
													w1.num_waits DESC,
													w1.wait_type
											) AS r
										FROM
										(
											SELECT TOP(@i)
												task_info.session_id,
												task_info.request_id,
												task_info.physical_io,
												task_info.context_switches,
												task_info.thread_CPU_snapshot,
												task_info.num_tasks AS tasks,
												CASE
													WHEN task_info.runnable_time IS NOT NULL THEN
														''RUNNABLE''
													ELSE
														wt2.wait_type
												END AS wait_type,
												NULLIF(COUNT(COALESCE(task_info.runnable_time, wt2.waiting_task_address)), 0) AS num_waits,
												MIN(COALESCE(task_info.runnable_time, wt2.wait_duration_ms)) AS min_wait_time,
												AVG(COALESCE(task_info.runnable_time, wt2.wait_duration_ms)) AS avg_wait_time,
												MAX(COALESCE(task_info.runnable_time, wt2.wait_duration_ms)) AS max_wait_time,
												MAX(wt2.block_info) AS block_info
											FROM
											(
												SELECT TOP(@i)
													t.session_id,
													t.request_id,
													SUM(CONVERT(BIGINT, t.pending_io_count)) OVER (PARTITION BY t.session_id, t.request_id) AS physical_io,
													SUM(CONVERT(BIGINT, t.context_switches_count)) OVER (PARTITION BY t.session_id, t.request_id) AS context_switches, 
													' +
													CASE
														WHEN 
															@output_column_list LIKE '%|[CPU_delta|]%' ESCAPE '|'
															AND @sys_info = 1
															THEN
																'SUM(tr.usermode_time + tr.kernel_time) OVER (PARTITION BY t.session_id, t.request_id) '
														ELSE
															'CONVERT(BIGINT, NULL) '
													END + 
														' AS thread_CPU_snapshot, 
													COUNT(*) OVER (PARTITION BY t.session_id, t.request_id) AS num_tasks,
													t.task_address,
													t.task_state,
													CASE
														WHEN
															t.task_state = ''RUNNABLE''
															AND w.runnable_time > 0 THEN
																w.runnable_time
														ELSE
															NULL
													END AS runnable_time
												FROM sys.dm_os_tasks AS t
												CROSS APPLY
												(
													SELECT TOP(1)
														sp2.session_id
													FROM @sessions AS sp2
													WHERE
														sp2.session_id = t.session_id
														AND sp2.request_id = t.request_id
														AND sp2.status <> ''sleeping''
												) AS sp20
												LEFT OUTER HASH JOIN
												( 
												' +
													CASE
														WHEN @sys_info = 1 THEN
															'SELECT TOP(@i)
																(
																	SELECT TOP(@i)
																		ms_ticks
																	FROM sys.dm_os_sys_info
																) -
																	w0.wait_resumed_ms_ticks AS runnable_time,
																w0.worker_address,
																w0.thread_address,
																w0.task_bound_ms_ticks
															FROM sys.dm_os_workers AS w0
															WHERE
																w0.state = ''RUNNABLE''
																OR @first_collection_ms_ticks >= w0.task_bound_ms_ticks'
														ELSE
															'SELECT
																CONVERT(BIGINT, NULL) AS runnable_time,
																CONVERT(VARBINARY(8), NULL) AS worker_address,
																CONVERT(VARBINARY(8), NULL) AS thread_address,
																CONVERT(BIGINT, NULL) AS task_bound_ms_ticks
															WHERE
																1 = 0'
														END +
												'
												) AS w ON
													w.worker_address = t.worker_address 
												' +
												CASE
													WHEN
														@output_column_list LIKE '%|[CPU_delta|]%' ESCAPE '|'
														AND @sys_info = 1
														THEN
															'LEFT OUTER HASH JOIN sys.dm_os_threads AS tr ON
																tr.thread_address = w.thread_address
																AND @first_collection_ms_ticks >= w.task_bound_ms_ticks
															'
													ELSE
														''
												END +
											') AS task_info
											LEFT OUTER HASH JOIN
											(
												SELECT TOP(@i)
													wt1.wait_type,
													wt1.waiting_task_address,
													MAX(wt1.wait_duration_ms) AS wait_duration_ms,
													MAX(wt1.block_info) AS block_info
												FROM
												(
													SELECT DISTINCT TOP(@i)
														wt.wait_type +
															CASE
																WHEN wt.wait_type LIKE N''PAGE%LATCH_%'' THEN
																	'':'' +
																	COALESCE(DB_NAME(CONVERT(INT, LEFT(wt.resource_description, CHARINDEX(N'':'', wt.resource_description) - 1))), N''(null)'') +
																	N'':'' +
																	SUBSTRING(wt.resource_description, CHARINDEX(N'':'', wt.resource_description) + 1, LEN(wt.resource_description) - CHARINDEX(N'':'', REVERSE(wt.resource_description)) - CHARINDEX(N'':'', wt.resource_description)) +
																	N''('' +
																		CASE
																			WHEN
																				CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) = 1 OR
																				CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) % 8088 = 0
																					THEN 
																						N''PFS''
																			WHEN
																				CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) = 2 OR
																				CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) % 511232 = 0 
																					THEN 
																						N''GAM''
																			WHEN
																				CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) = 3 OR
																				(CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) - 1) % 511232 = 0 
																					THEN 
																						N''SGAM''
																			WHEN
																				CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) = 6 OR
																				(CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) - 6) % 511232 = 0 
																					THEN 
																						N''DCM''
																			WHEN
																				CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) = 7 OR
																				(CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) - 7) % 511232 = 0
																					THEN 
																						N''BCM''
																			ELSE
																				N''*''
																		END +
																	N'')''
																WHEN wt.wait_type = N''CXPACKET'' THEN
																	N'':'' + SUBSTRING(wt.resource_description, CHARINDEX(N''nodeId'', wt.resource_description) + 7, 4)
																WHEN wt.wait_type LIKE N''LATCH[_]%'' THEN
																	N'' ['' + LEFT(wt.resource_description, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description), 0), LEN(wt.resource_description) + 1) - 1) + N'']''
																ELSE 
																	N''''
															END COLLATE Latin1_General_Bin2 AS wait_type,
														CASE
															WHEN
															(
																wt.blocking_session_id IS NOT NULL
																AND wt.wait_type LIKE N''LCK[_]%''
															) THEN
																(
																	SELECT TOP(@i)
																		x.lock_type,
																		REPLACE
																		(
																			REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
																			REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
																			REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
																				DB_NAME
																				(
																					CONVERT
																					(
																						INT,
																						SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''dbid='', wt.resource_description), 0) + 5, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description, CHARINDEX(N''dbid='', wt.resource_description) + 5), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''dbid='', wt.resource_description) - 5)
																					)
																				),
																				NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''),
																				NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''),
																				NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''),
																			NCHAR(0),
																			N''''
																		) AS database_name,
																		CASE x.lock_type
																			WHEN N''objectlock'' THEN
																				SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''objid='', wt.resource_description), 0) + 6, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description, CHARINDEX(N''objid='', wt.resource_description) + 6), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''objid='', wt.resource_description) - 6)
																			ELSE
																				NULL
																		END AS object_id,
																		CASE x.lock_type
																			WHEN N''filelock'' THEN
																				SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''fileid='', wt.resource_description), 0) + 7, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description, CHARINDEX(N''fileid='', wt.resource_description) + 7), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''fileid='', wt.resource_description) - 7)
																			ELSE
																				NULL
																		END AS file_id,
																		CASE
																			WHEN x.lock_type in (N''pagelock'', N''extentlock'', N''ridlock'') THEN
																				SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''associatedObjectId='', wt.resource_description), 0) + 19, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description, CHARINDEX(N''associatedObjectId='', wt.resource_description) + 19), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''associatedObjectId='', wt.resource_description) - 19)
																			WHEN x.lock_type in (N''keylock'', N''hobtlock'', N''allocunitlock'') THEN
																				SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''hobtid='', wt.resource_description), 0) + 7, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description, CHARINDEX(N''hobtid='', wt.resource_description) + 7), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''hobtid='', wt.resource_description) - 7)
																			ELSE
																				NULL
																		END AS hobt_id,
																		CASE x.lock_type
																			WHEN N''applicationlock'' THEN
																				SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''hash='', wt.resource_description), 0) + 5, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description, CHARINDEX(N''hash='', wt.resource_description) + 5), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''hash='', wt.resource_description) - 5)
																			ELSE
																				NULL
																		END AS applock_hash,
																		CASE x.lock_type
																			WHEN N''metadatalock'' THEN
																				SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''subresource='', wt.resource_description), 0) + 12, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description, CHARINDEX(N''subresource='', wt.resource_description) + 12), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''subresource='', wt.resource_description) - 12)
																			ELSE
																				NULL
																		END AS metadata_resource,
																		CASE x.lock_type
																			WHEN N''metadatalock'' THEN
																				SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''classid='', wt.resource_description), 0) + 8, COALESCE(NULLIF(CHARINDEX(N'' dbid='', wt.resource_description) - CHARINDEX(N''classid='', wt.resource_description), 0), LEN(wt.resource_description) + 1) - 8)
																			ELSE
																				NULL
																		END AS metadata_class_id
																	FROM
																	(
																		SELECT TOP(1)
																			LEFT(wt.resource_description, CHARINDEX(N'' '', wt.resource_description) - 1) COLLATE Latin1_General_Bin2 AS lock_type
																	) AS x
																	FOR XML
																		PATH('''')
																)
															ELSE NULL
														END AS block_info,
														wt.wait_duration_ms,
														wt.waiting_task_address
													FROM
													(
														SELECT TOP(@i)
															wt0.wait_type COLLATE Latin1_General_Bin2 AS wait_type,
															wt0.resource_description COLLATE Latin1_General_Bin2 AS resource_description,
															wt0.wait_duration_ms,
															wt0.waiting_task_address,
															CASE
																WHEN wt0.blocking_session_id = p.blocked THEN
																	wt0.blocking_session_id
																ELSE
																	NULL
															END AS blocking_session_id
														FROM sys.dm_os_waiting_tasks AS wt0
														CROSS APPLY
														(
															SELECT TOP(1)
																s0.blocked
															FROM @sessions AS s0
															WHERE
																s0.session_id = wt0.session_id
																AND COALESCE(s0.wait_type, N'''') <> N''OLEDB''
																AND wt0.wait_type <> N''OLEDB''
														) AS p
													) AS wt
												) AS wt1
												GROUP BY
													wt1.wait_type,
													wt1.waiting_task_address
											) AS wt2 ON
												wt2.waiting_task_address = task_info.task_address
												AND wt2.wait_duration_ms > 0
												AND task_info.runnable_time IS NULL
											GROUP BY
												task_info.session_id,
												task_info.request_id,
												task_info.physical_io,
												task_info.context_switches,
												task_info.thread_CPU_snapshot,
												task_info.num_tasks,
												CASE
													WHEN task_info.runnable_time IS NOT NULL THEN
														''RUNNABLE''
													ELSE
														wt2.wait_type
												END
										) AS w1
									) AS waits
									ORDER BY
										waits.session_id,
										waits.request_id,
										waits.r
									FOR XML
										PATH(N''tasks''),
										TYPE
								) AS tasks_raw (task_xml_raw)
							) AS tasks_final
							CROSS APPLY tasks_final.task_xml.nodes(N''/tasks'') AS task_nodes (task_node)
							WHERE
								task_nodes.task_node.exist(N''session_id'') = 1
						) AS tasks ON
							tasks.session_id = y.session_id
							AND tasks.request_id = y.request_id 
						'
					ELSE
						''
				END +
				'LEFT OUTER HASH JOIN
				(
					SELECT TOP(@i)
						t_info.session_id,
						COALESCE(t_info.request_id, -1) AS request_id,
						SUM(t_info.tempdb_allocations) AS tempdb_allocations,
						SUM(t_info.tempdb_current) AS tempdb_current
					FROM
					(
						SELECT TOP(@i)
							tsu.session_id,
							tsu.request_id,
							tsu.user_objects_alloc_page_count +
								tsu.internal_objects_alloc_page_count AS tempdb_allocations,
							tsu.user_objects_alloc_page_count +
								tsu.internal_objects_alloc_page_count -
								tsu.user_objects_dealloc_page_count -
								tsu.internal_objects_dealloc_page_count AS tempdb_current
						FROM sys.dm_db_task_space_usage AS tsu
						CROSS APPLY
						(
							SELECT TOP(1)
								s0.session_id
							FROM @sessions AS s0
							WHERE
								s0.session_id = tsu.session_id
						) AS p

						UNION ALL

						SELECT TOP(@i)
							ssu.session_id,
							NULL AS request_id,
							ssu.user_objects_alloc_page_count +
								ssu.internal_objects_alloc_page_count AS tempdb_allocations,
							ssu.user_objects_alloc_page_count +
								ssu.internal_objects_alloc_page_count -
								ssu.user_objects_dealloc_page_count -
								ssu.internal_objects_dealloc_page_count AS tempdb_current
						FROM sys.dm_db_session_space_usage AS ssu
						CROSS APPLY
						(
							SELECT TOP(1)
								s0.session_id
							FROM @sessions AS s0
							WHERE
								s0.session_id = ssu.session_id
						) AS p
					) AS t_info
					GROUP BY
						t_info.session_id,
						COALESCE(t_info.request_id, -1)
				) AS tempdb_info ON
					tempdb_info.session_id = y.session_id
					AND tempdb_info.request_id =
						CASE
							WHEN y.status = N''sleeping'' THEN
								-1
							ELSE
								y.request_id
						END
				' +
				CASE 
					WHEN 
						NOT 
						(
							@get_avg_time = 1 
							AND @recursion = 1
						) THEN 
							''
					ELSE
						'LEFT OUTER HASH JOIN
						(
							SELECT TOP(@i)
								*
							FROM sys.dm_exec_query_stats
						) AS qs ON
							qs.sql_handle = y.sql_handle
							AND qs.plan_handle = y.plan_handle
							AND qs.statement_start_offset = y.statement_start_offset
							AND qs.statement_end_offset = y.statement_end_offset
						'
				END + 
			') AS x
			OPTION (KEEPFIXED PLAN, OPTIMIZE FOR (@i = 1)); ';

		SET @sql_n = CONVERT(NVARCHAR(MAX), @sql);

		SET @last_collection_start = GETDATE();

		IF 
			@recursion = -1
			AND @sys_info = 1
		BEGIN;
			SELECT
				@first_collection_ms_ticks = ms_ticks
			FROM sys.dm_os_sys_info;
		END;

		INSERT #sessions
		(
			recursion,
			session_id,
			request_id,
			session_number,
			elapsed_time,
			avg_elapsed_time,
			physical_io,
			reads,
			physical_reads,
			writes,
			tempdb_allocations,
			tempdb_current,
			CPU,
			thread_CPU_snapshot,
			context_switches,
			used_memory,
			tasks,
			status,
			wait_info,
			transaction_id,
			open_tran_count,
			sql_handle,
			statement_start_offset,
			statement_end_offset,		
			sql_text,
			plan_handle,
			blocking_session_id,
			percent_complete,
			host_name,
			login_name,
			database_name,
			program_name,
			additional_info,
			start_time,
			login_time,
			last_request_start_time
		)
		EXEC sp_executesql 
			@sql_n,
			N'@recursion SMALLINT, @filter sysname, @not_filter sysname, @first_collection_ms_ticks BIGINT',
			@recursion, @filter, @not_filter, @first_collection_ms_ticks;

		--Collect transaction information?
		IF
			@recursion = 1
			AND
			(
				@output_column_list LIKE '%|[tran_start_time|]%' ESCAPE '|'
				OR @output_column_list LIKE '%|[tran_log_writes|]%' ESCAPE '|' 
			)
		BEGIN;	
			DECLARE @i INT;
			SET @i = 2147483647;

			UPDATE s
			SET
				tran_start_time =
					CONVERT
					(
						DATETIME,
						LEFT
						(
							x.trans_info,
							NULLIF(CHARINDEX(NCHAR(254) COLLATE Latin1_General_Bin2, x.trans_info) - 1, -1)
						),
						121
					),
				tran_log_writes =
					RIGHT
					(
						x.trans_info,
						LEN(x.trans_info) - CHARINDEX(NCHAR(254) COLLATE Latin1_General_Bin2, x.trans_info)
					)
			FROM
			(
				SELECT TOP(@i)
					trans_nodes.trans_node.value('(session_id/text())[1]', 'SMALLINT') AS session_id,
					COALESCE(trans_nodes.trans_node.value('(request_id/text())[1]', 'INT'), 0) AS request_id,
					trans_nodes.trans_node.value('(trans_info/text())[1]', 'NVARCHAR(4000)') AS trans_info				
				FROM
				(
					SELECT TOP(@i)
						CONVERT
						(
							XML,
							REPLACE
							(
								CONVERT(NVARCHAR(MAX), trans_raw.trans_xml_raw) COLLATE Latin1_General_Bin2, 
								N'</trans_info></trans><trans><trans_info>', N''
							)
						)
					FROM
					(
						SELECT TOP(@i)
							CASE u_trans.r
								WHEN 1 THEN u_trans.session_id
								ELSE NULL
							END AS [session_id],
							CASE u_trans.r
								WHEN 1 THEN u_trans.request_id
								ELSE NULL
							END AS [request_id],
							CONVERT
							(
								NVARCHAR(MAX),
								CASE
									WHEN u_trans.database_id IS NOT NULL THEN
										CASE u_trans.r
											WHEN 1 THEN COALESCE(CONVERT(NVARCHAR, u_trans.transaction_start_time, 121) + NCHAR(254), N'')
											ELSE N''
										END + 
											REPLACE
											(
												REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
												REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
												REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
													CONVERT(VARCHAR(128), COALESCE(DB_NAME(u_trans.database_id), N'(null)')),
													NCHAR(31),N'?'),NCHAR(30),N'?'),NCHAR(29),N'?'),NCHAR(28),N'?'),NCHAR(27),N'?'),NCHAR(26),N'?'),NCHAR(25),N'?'),NCHAR(24),N'?'),NCHAR(23),N'?'),NCHAR(22),N'?'),
													NCHAR(21),N'?'),NCHAR(20),N'?'),NCHAR(19),N'?'),NCHAR(18),N'?'),NCHAR(17),N'?'),NCHAR(16),N'?'),NCHAR(15),N'?'),NCHAR(14),N'?'),NCHAR(12),N'?'),
													NCHAR(11),N'?'),NCHAR(8),N'?'),NCHAR(7),N'?'),NCHAR(6),N'?'),NCHAR(5),N'?'),NCHAR(4),N'?'),NCHAR(3),N'?'),NCHAR(2),N'?'),NCHAR(1),N'?'),
												NCHAR(0),
												N'?'
											) +
											N': ' +
										CONVERT(NVARCHAR, u_trans.log_record_count) + N' (' + CONVERT(NVARCHAR, u_trans.log_kb_used) + N' kB)' +
										N','
									ELSE
										N'N/A,'
								END COLLATE Latin1_General_Bin2
							) AS [trans_info]
						FROM
						(
							SELECT TOP(@i)
								trans.*,
								ROW_NUMBER() OVER
								(
									PARTITION BY
										trans.session_id,
										trans.request_id
									ORDER BY
										trans.transaction_start_time DESC
								) AS r
							FROM
							(
								SELECT TOP(@i)
									session_tran_map.session_id,
									session_tran_map.request_id,
									s_tran.database_id,
									COALESCE(SUM(s_tran.database_transaction_log_record_count), 0) AS log_record_count,
									COALESCE(SUM(s_tran.database_transaction_log_bytes_used), 0) / 1024 AS log_kb_used,
									MIN(s_tran.database_transaction_begin_time) AS transaction_start_time
								FROM
								(
									SELECT TOP(@i)
										*
									FROM sys.dm_tran_active_transactions
									WHERE
										transaction_begin_time <= @last_collection_start
								) AS a_tran
								INNER HASH JOIN
								(
									SELECT TOP(@i)
										*
									FROM sys.dm_tran_database_transactions
									WHERE
										database_id < 32767
								) AS s_tran ON
									s_tran.transaction_id = a_tran.transaction_id
								LEFT OUTER HASH JOIN
								(
									SELECT TOP(@i)
										*
									FROM sys.dm_tran_session_transactions
								) AS tst ON
									s_tran.transaction_id = tst.transaction_id
								CROSS APPLY
								(
									SELECT TOP(1)
										s3.session_id,
										s3.request_id
									FROM
									(
										SELECT TOP(1)
											s1.session_id,
											s1.request_id
										FROM #sessions AS s1
										WHERE
											s1.transaction_id = s_tran.transaction_id
											AND s1.recursion = 1
											
										UNION ALL
									
										SELECT TOP(1)
											s2.session_id,
											s2.request_id
										FROM #sessions AS s2
										WHERE
											s2.session_id = tst.session_id
											AND s2.recursion = 1
									) AS s3
									ORDER BY
										s3.request_id
								) AS session_tran_map
								GROUP BY
									session_tran_map.session_id,
									session_tran_map.request_id,
									s_tran.database_id
							) AS trans
						) AS u_trans
						FOR XML
							PATH('trans'),
							TYPE
					) AS trans_raw (trans_xml_raw)
				) AS trans_final (trans_xml)
				CROSS APPLY trans_final.trans_xml.nodes('/trans') AS trans_nodes (trans_node)
			) AS x
			INNER HASH JOIN #sessions AS s ON
				s.session_id = x.session_id
				AND s.request_id = x.request_id
			OPTION (OPTIMIZE FOR (@i = 1));
		END;

		--Variables for text and plan collection
		DECLARE	
			@session_id SMALLINT,
			@request_id INT,
			@sql_handle VARBINARY(64),
			@plan_handle VARBINARY(64),
			@statement_start_offset INT,
			@statement_end_offset INT,
			@start_time DATETIME,
			@database_name sysname;

		IF 
			@recursion = 1
			AND @output_column_list LIKE '%|[sql_text|]%' ESCAPE '|'
		BEGIN;
			DECLARE sql_cursor
			CURSOR LOCAL FAST_FORWARD
			FOR 
				SELECT 
					session_id,
					request_id,
					sql_handle,
					statement_start_offset,
					statement_end_offset
				FROM #sessions
				WHERE
					recursion = 1
					AND sql_handle IS NOT NULL
			OPTION (KEEPFIXED PLAN);

			OPEN sql_cursor;

			FETCH NEXT FROM sql_cursor
			INTO 
				@session_id,
				@request_id,
				@sql_handle,
				@statement_start_offset,
				@statement_end_offset;

			--Wait up to 5 ms for the SQL text, then give up
			SET LOCK_TIMEOUT 5;

			WHILE @@FETCH_STATUS = 0
			BEGIN;
				BEGIN TRY;
					UPDATE s
					SET
						s.sql_text =
						(
							SELECT
								REPLACE
								(
									REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
									REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
									REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
										N'--' + NCHAR(13) + NCHAR(10) +
										CASE 
											WHEN @get_full_inner_text = 1 THEN est.text
											WHEN LEN(est.text) < (@statement_end_offset / 2) + 1 THEN est.text
											WHEN SUBSTRING(est.text, (@statement_start_offset/2), 2) LIKE N'[a-zA-Z0-9][a-zA-Z0-9]' THEN est.text
											ELSE
												CASE
													WHEN @statement_start_offset > 0 THEN
														SUBSTRING
														(
															est.text,
															((@statement_start_offset/2) + 1),
															(
																CASE
																	WHEN @statement_end_offset = -1 THEN 2147483647
																	ELSE ((@statement_end_offset - @statement_start_offset)/2) + 1
																END
															)
														)
													ELSE RTRIM(LTRIM(est.text))
												END
										END +
										NCHAR(13) + NCHAR(10) + N'--' COLLATE Latin1_General_Bin2,
										NCHAR(31),N'?'),NCHAR(30),N'?'),NCHAR(29),N'?'),NCHAR(28),N'?'),NCHAR(27),N'?'),NCHAR(26),N'?'),NCHAR(25),N'?'),NCHAR(24),N'?'),NCHAR(23),N'?'),NCHAR(22),N'?'),
										NCHAR(21),N'?'),NCHAR(20),N'?'),NCHAR(19),N'?'),NCHAR(18),N'?'),NCHAR(17),N'?'),NCHAR(16),N'?'),NCHAR(15),N'?'),NCHAR(14),N'?'),NCHAR(12),N'?'),
										NCHAR(11),N'?'),NCHAR(8),N'?'),NCHAR(7),N'?'),NCHAR(6),N'?'),NCHAR(5),N'?'),NCHAR(4),N'?'),NCHAR(3),N'?'),NCHAR(2),N'?'),NCHAR(1),N'?'),
									NCHAR(0),
									N''
								) AS [processing-instruction(query)]
							FOR XML
								PATH(''),
								TYPE
						),
						s.statement_start_offset = 
							CASE 
								WHEN LEN(est.text) < (@statement_end_offset / 2) + 1 THEN 0
								WHEN SUBSTRING(CONVERT(VARCHAR(MAX), est.text), (@statement_start_offset/2), 2) LIKE '[a-zA-Z0-9][a-zA-Z0-9]' THEN 0
								ELSE @statement_start_offset
							END,
						s.statement_end_offset = 
							CASE 
								WHEN LEN(est.text) < (@statement_end_offset / 2) + 1 THEN -1
								WHEN SUBSTRING(CONVERT(VARCHAR(MAX), est.text), (@statement_start_offset/2), 2) LIKE '[a-zA-Z0-9][a-zA-Z0-9]' THEN -1
								ELSE @statement_end_offset
							END
					FROM 
						#sessions AS s,
						(
							SELECT TOP(1)
								text
							FROM
							(
								SELECT 
									text, 
									0 AS row_num
								FROM sys.dm_exec_sql_text(@sql_handle)
								
								UNION ALL
								
								SELECT 
									NULL,
									1 AS row_num
							) AS est0
							ORDER BY
								row_num
						) AS est
					WHERE 
						s.session_id = @session_id
						AND s.request_id = @request_id
						AND s.recursion = 1
					OPTION (KEEPFIXED PLAN);
				END TRY
				BEGIN CATCH;
					UPDATE s
					SET
						s.sql_text = 
							CASE ERROR_NUMBER() 
								WHEN 1222 THEN '<timeout_exceeded />'
								ELSE '<error message="' + ERROR_MESSAGE() + '" />'
							END
					FROM #sessions AS s
					WHERE 
						s.session_id = @session_id
						AND s.request_id = @request_id
						AND s.recursion = 1
					OPTION (KEEPFIXED PLAN);
				END CATCH;

				FETCH NEXT FROM sql_cursor
				INTO
					@session_id,
					@request_id,
					@sql_handle,
					@statement_start_offset,
					@statement_end_offset;
			END;

			--Return this to the default
			SET LOCK_TIMEOUT -1;

			CLOSE sql_cursor;
			DEALLOCATE sql_cursor;
		END;

		IF 
			@get_outer_command = 1 
			AND @recursion = 1
			AND @output_column_list LIKE '%|[sql_command|]%' ESCAPE '|'
		BEGIN;
			DECLARE @buffer_results TABLE
			(
				EventType VARCHAR(30),
				Parameters INT,
				EventInfo NVARCHAR(4000),
				start_time DATETIME,
				session_number INT IDENTITY(1,1) NOT NULL PRIMARY KEY
			);

			DECLARE buffer_cursor
			CURSOR LOCAL FAST_FORWARD
			FOR 
				SELECT 
					session_id,
					MAX(start_time) AS start_time
				FROM #sessions
				WHERE
					recursion = 1
				GROUP BY
					session_id
				ORDER BY
					session_id
				OPTION (KEEPFIXED PLAN);

			OPEN buffer_cursor;

			FETCH NEXT FROM buffer_cursor
			INTO 
				@session_id,
				@start_time;

			WHILE @@FETCH_STATUS = 0
			BEGIN;
				BEGIN TRY;
					--In SQL Server 2008, DBCC INPUTBUFFER will throw 
					--an exception if the session no longer exists
					INSERT @buffer_results
					(
						EventType,
						Parameters,
						EventInfo
					)
					EXEC sp_executesql
						N'DBCC INPUTBUFFER(@session_id) WITH NO_INFOMSGS;',
						N'@session_id SMALLINT',
						@session_id;

					UPDATE br
					SET
						br.start_time = @start_time
					FROM @buffer_results AS br
					WHERE
						br.session_number = 
						(
							SELECT MAX(br2.session_number)
							FROM @buffer_results br2
						);
				END TRY
				BEGIN CATCH
				END CATCH;

				FETCH NEXT FROM buffer_cursor
				INTO 
					@session_id,
					@start_time;
			END;

			UPDATE s
			SET
				sql_command = 
				(
					SELECT 
						REPLACE
						(
							REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
							REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
							REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								CONVERT
								(
									NVARCHAR(MAX),
									N'--' + NCHAR(13) + NCHAR(10) + br.EventInfo + NCHAR(13) + NCHAR(10) + N'--' COLLATE Latin1_General_Bin2
								),
								NCHAR(31),N'?'),NCHAR(30),N'?'),NCHAR(29),N'?'),NCHAR(28),N'?'),NCHAR(27),N'?'),NCHAR(26),N'?'),NCHAR(25),N'?'),NCHAR(24),N'?'),NCHAR(23),N'?'),NCHAR(22),N'?'),
								NCHAR(21),N'?'),NCHAR(20),N'?'),NCHAR(19),N'?'),NCHAR(18),N'?'),NCHAR(17),N'?'),NCHAR(16),N'?'),NCHAR(15),N'?'),NCHAR(14),N'?'),NCHAR(12),N'?'),
								NCHAR(11),N'?'),NCHAR(8),N'?'),NCHAR(7),N'?'),NCHAR(6),N'?'),NCHAR(5),N'?'),NCHAR(4),N'?'),NCHAR(3),N'?'),NCHAR(2),N'?'),NCHAR(1),N'?'),
							NCHAR(0),
							N''
						) AS [processing-instruction(query)]
					FROM @buffer_results AS br
					WHERE 
						br.session_number = s.session_number
						AND br.start_time = s.start_time
						AND 
						(
							(
								s.start_time = s.last_request_start_time
								AND EXISTS
								(
									SELECT *
									FROM sys.dm_exec_requests r2
									WHERE
										r2.session_id = s.session_id
										AND r2.request_id = s.request_id
										AND r2.start_time = s.start_time
								)
							)
							OR 
							(
								s.request_id = 0
								AND EXISTS
								(
									SELECT *
									FROM sys.dm_exec_sessions s2
									WHERE
										s2.session_id = s.session_id
										AND s2.last_request_start_time = s.last_request_start_time
								)
							)
						)
					FOR XML
						PATH(''),
						TYPE
				)
			FROM #sessions AS s
			WHERE
				recursion = 1
			OPTION (KEEPFIXED PLAN);

			CLOSE buffer_cursor;
			DEALLOCATE buffer_cursor;
		END;

		IF 
			@get_plans >= 1 
			AND @recursion = 1
			AND @output_column_list LIKE '%|[query_plan|]%' ESCAPE '|'
		BEGIN;
			DECLARE @live_plan BIT;
			SET @live_plan = ISNULL(CONVERT(BIT, SIGN(OBJECT_ID('sys.dm_exec_query_statistics_xml'))), 0)

			DECLARE plan_cursor
			CURSOR LOCAL FAST_FORWARD
			FOR 
				SELECT
					session_id,
					request_id,
					plan_handle,
					statement_start_offset,
					statement_end_offset
				FROM #sessions
				WHERE
					recursion = 1
					AND plan_handle IS NOT NULL
			OPTION (KEEPFIXED PLAN);

			OPEN plan_cursor;

			FETCH NEXT FROM plan_cursor
			INTO 
				@session_id,
				@request_id,
				@plan_handle,
				@statement_start_offset,
				@statement_end_offset;

			--Wait up to 5 ms for a query plan, then give up
			SET LOCK_TIMEOUT 5;

			WHILE @@FETCH_STATUS = 0
			BEGIN;
				DECLARE @query_plan XML;
				SET @query_plan = NULL;

				IF @live_plan = 1
				BEGIN;
					BEGIN TRY;
						SELECT
							@query_plan = x.query_plan
						FROM sys.dm_exec_query_statistics_xml(@session_id) AS x;

						IF 
							@query_plan IS NOT NULL
							AND EXISTS
							(
								SELECT
									*
								FROM sys.dm_exec_requests AS r
								WHERE
									r.session_id = @session_id
									AND r.request_id = @request_id
									AND r.plan_handle = @plan_handle
									AND r.statement_start_offset = @statement_start_offset
									AND r.statement_end_offset = @statement_end_offset
							)
						BEGIN;
							UPDATE s
							SET
								s.query_plan = @query_plan
							FROM #sessions AS s
							WHERE 
								s.session_id = @session_id
								AND s.request_id = @request_id
								AND s.recursion = 1
							OPTION (KEEPFIXED PLAN);
						END;
					END TRY
					BEGIN CATCH;
						SET @query_plan = NULL;
					END CATCH;
				END;

				IF @query_plan IS NULL
				BEGIN;
					BEGIN TRY;
						UPDATE s
						SET
							s.query_plan =
							(
								SELECT
									CONVERT(xml, query_plan)
								FROM sys.dm_exec_text_query_plan
								(
									@plan_handle, 
									CASE @get_plans
										WHEN 1 THEN
											@statement_start_offset
										ELSE
											0
									END, 
									CASE @get_plans
										WHEN 1 THEN
											@statement_end_offset
										ELSE
											-1
									END
								)
							)
						FROM #sessions AS s
						WHERE 
							s.session_id = @session_id
							AND s.request_id = @request_id
							AND s.recursion = 1
						OPTION (KEEPFIXED PLAN);
					END TRY
					BEGIN CATCH;
						IF ERROR_NUMBER() = 6335
						BEGIN;
							UPDATE s
							SET
								s.query_plan =
								(
									SELECT
										N'--' + NCHAR(13) + NCHAR(10) + 
										N'-- Could not render showplan due to XML data type limitations. ' + NCHAR(13) + NCHAR(10) + 
										N'-- To see the graphical plan save the XML below as a .SQLPLAN file and re-open in SSMS.' + NCHAR(13) + NCHAR(10) +
										N'--' + NCHAR(13) + NCHAR(10) +
											REPLACE(qp.query_plan, N'<RelOp', NCHAR(13)+NCHAR(10)+N'<RelOp') + 
											NCHAR(13) + NCHAR(10) + N'--' COLLATE Latin1_General_Bin2 AS [processing-instruction(query_plan)]
									FROM sys.dm_exec_text_query_plan
									(
										@plan_handle, 
										CASE @get_plans
											WHEN 1 THEN
												@statement_start_offset
											ELSE
												0
										END, 
										CASE @get_plans
											WHEN 1 THEN
												@statement_end_offset
											ELSE
												-1
										END
									) AS qp
									FOR XML
										PATH(''),
										TYPE
								)
							FROM #sessions AS s
							WHERE 
								s.session_id = @session_id
								AND s.request_id = @request_id
								AND s.recursion = 1
							OPTION (KEEPFIXED PLAN);
						END;
						ELSE
						BEGIN;
							UPDATE s
							SET
								s.query_plan = 
									CASE ERROR_NUMBER() 
										WHEN 1222 THEN '<timeout_exceeded />'
										ELSE '<error message="' + ERROR_MESSAGE() + '" />'
									END
							FROM #sessions AS s
							WHERE 
								s.session_id = @session_id
								AND s.request_id = @request_id
								AND s.recursion = 1
							OPTION (KEEPFIXED PLAN);
						END;
					END CATCH;
				END;

				FETCH NEXT FROM plan_cursor
				INTO
					@session_id,
					@request_id,
					@plan_handle,
					@statement_start_offset,
					@statement_end_offset;
			END;

			--Return this to the default
			SET LOCK_TIMEOUT -1;

			CLOSE plan_cursor;
			DEALLOCATE plan_cursor;
		END;

		IF 
			@get_locks = 1 
			AND @recursion = 1
			AND @output_column_list LIKE '%|[locks|]%' ESCAPE '|'
		BEGIN;
			DECLARE locks_cursor
			CURSOR LOCAL FAST_FORWARD
			FOR 
				SELECT DISTINCT
					database_name
				FROM #locks
				WHERE
					EXISTS
					(
						SELECT *
						FROM #sessions AS s
						WHERE
							s.session_id = #locks.session_id
							AND recursion = 1
					)
					AND database_name <> '(null)'
				OPTION (KEEPFIXED PLAN);

			OPEN locks_cursor;

			FETCH NEXT FROM locks_cursor
			INTO 
				@database_name;

			WHILE @@FETCH_STATUS = 0
			BEGIN;
				BEGIN TRY;
					SET @sql_n = CONVERT(NVARCHAR(MAX), '') +
						'UPDATE l ' +
						'SET ' +
							'object_name = ' +
								'REPLACE ' +
								'( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
										'o.name COLLATE Latin1_General_Bin2, ' +
										'NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''), ' +
										'NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''), ' +
										'NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''), ' +
									'NCHAR(0), ' +
									N''''' ' +
								'), ' +
							'index_name = ' +
								'REPLACE ' +
								'( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
										'i.name COLLATE Latin1_General_Bin2, ' +
										'NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''), ' +
										'NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''), ' +
										'NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''), ' +
									'NCHAR(0), ' +
									N''''' ' +
								'), ' +
							'schema_name = ' +
								'REPLACE ' +
								'( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
										's.name COLLATE Latin1_General_Bin2, ' +
										'NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''), ' +
										'NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''), ' +
										'NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''), ' +
									'NCHAR(0), ' +
									N''''' ' +
								'), ' +
							'principal_name = ' + 
								'REPLACE ' +
								'( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
										'dp.name COLLATE Latin1_General_Bin2, ' +
										'NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''), ' +
										'NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''), ' +
										'NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''), ' +
									'NCHAR(0), ' +
									N''''' ' +
								') ' +
						'FROM #locks AS l ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.allocation_units AS au ON ' +
							'au.allocation_unit_id = l.allocation_unit_id ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.partitions AS p ON ' +
							'p.hobt_id = ' +
								'COALESCE ' +
								'( ' +
									'l.hobt_id, ' +
									'CASE ' +
										'WHEN au.type IN (1, 3) THEN au.container_id ' +
										'ELSE NULL ' +
									'END ' +
								') ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.partitions AS p1 ON ' +
							'l.hobt_id IS NULL ' +
							'AND au.type = 2 ' +
							'AND p1.partition_id = au.container_id ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.objects AS o ON ' +
							'o.object_id = COALESCE(l.object_id, p.object_id, p1.object_id) ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.indexes AS i ON ' +
							'i.object_id = COALESCE(l.object_id, p.object_id, p1.object_id) ' +
							'AND i.index_id = COALESCE(l.index_id, p.index_id, p1.index_id) ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.schemas AS s ON ' +
							's.schema_id = COALESCE(l.schema_id, o.schema_id) ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.database_principals AS dp ON ' +
							'dp.principal_id = l.principal_id ' +
						'WHERE ' +
							'l.database_name = @database_name ' +
						'OPTION (KEEPFIXED PLAN); ';
					
					EXEC sp_executesql
						@sql_n,
						N'@database_name sysname',
						@database_name;
				END TRY
				BEGIN CATCH;
					UPDATE #locks
					SET
						query_error = 
							REPLACE
							(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
									CONVERT
									(
										NVARCHAR(MAX), 
										ERROR_MESSAGE() COLLATE Latin1_General_Bin2
									),
									NCHAR(31),N'?'),NCHAR(30),N'?'),NCHAR(29),N'?'),NCHAR(28),N'?'),NCHAR(27),N'?'),NCHAR(26),N'?'),NCHAR(25),N'?'),NCHAR(24),N'?'),NCHAR(23),N'?'),NCHAR(22),N'?'),
									NCHAR(21),N'?'),NCHAR(20),N'?'),NCHAR(19),N'?'),NCHAR(18),N'?'),NCHAR(17),N'?'),NCHAR(16),N'?'),NCHAR(15),N'?'),NCHAR(14),N'?'),NCHAR(12),N'?'),
									NCHAR(11),N'?'),NCHAR(8),N'?'),NCHAR(7),N'?'),NCHAR(6),N'?'),NCHAR(5),N'?'),NCHAR(4),N'?'),NCHAR(3),N'?'),NCHAR(2),N'?'),NCHAR(1),N'?'),
								NCHAR(0),
								N''
							)
					WHERE 
						database_name = @database_name
					OPTION (KEEPFIXED PLAN);
				END CATCH;

				FETCH NEXT FROM locks_cursor
				INTO
					@database_name;
			END;

			CLOSE locks_cursor;
			DEALLOCATE locks_cursor;

			CREATE CLUSTERED INDEX IX_SRD ON #locks (session_id, request_id, database_name);

			UPDATE s
			SET 
				s.locks =
				(
					SELECT 
						REPLACE
						(
							REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
							REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
							REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								CONVERT
								(
									NVARCHAR(MAX), 
									l1.database_name COLLATE Latin1_General_Bin2
								),
								NCHAR(31),N'?'),NCHAR(30),N'?'),NCHAR(29),N'?'),NCHAR(28),N'?'),NCHAR(27),N'?'),NCHAR(26),N'?'),NCHAR(25),N'?'),NCHAR(24),N'?'),NCHAR(23),N'?'),NCHAR(22),N'?'),
								NCHAR(21),N'?'),NCHAR(20),N'?'),NCHAR(19),N'?'),NCHAR(18),N'?'),NCHAR(17),N'?'),NCHAR(16),N'?'),NCHAR(15),N'?'),NCHAR(14),N'?'),NCHAR(12),N'?'),
								NCHAR(11),N'?'),NCHAR(8),N'?'),NCHAR(7),N'?'),NCHAR(6),N'?'),NCHAR(5),N'?'),NCHAR(4),N'?'),NCHAR(3),N'?'),NCHAR(2),N'?'),NCHAR(1),N'?'),
							NCHAR(0),
							N''
						) AS [Database/@name],
						MIN(l1.query_error) AS [Database/@query_error],
						(
							SELECT 
								l2.request_mode AS [Lock/@request_mode],
								l2.request_status AS [Lock/@request_status],
								COUNT(*) AS [Lock/@request_count]
							FROM #locks AS l2
							WHERE 
								l1.session_id = l2.session_id
								AND l1.request_id = l2.request_id
								AND l2.database_name = l1.database_name
								AND l2.resource_type = 'DATABASE'
							GROUP BY
								l2.request_mode,
								l2.request_status
							FOR XML
								PATH(''),
								TYPE
						) AS [Database/Locks],
						(
							SELECT
								COALESCE(l3.object_name, '(null)') AS [Object/@name],
								l3.schema_name AS [Object/@schema_name],
								(
									SELECT
										l4.resource_type AS [Lock/@resource_type],
										l4.page_type AS [Lock/@page_type],
										l4.index_name AS [Lock/@index_name],
										CASE 
											WHEN l4.object_name IS NULL THEN l4.schema_name
											ELSE NULL
										END AS [Lock/@schema_name],
										l4.principal_name AS [Lock/@principal_name],
										l4.resource_description AS [Lock/@resource_description],
										l4.request_mode AS [Lock/@request_mode],
										l4.request_status AS [Lock/@request_status],
										SUM(l4.request_count) AS [Lock/@request_count]
									FROM #locks AS l4
									WHERE 
										l4.session_id = l3.session_id
										AND l4.request_id = l3.request_id
										AND l3.database_name = l4.database_name
										AND COALESCE(l3.object_name, '(null)') = COALESCE(l4.object_name, '(null)')
										AND COALESCE(l3.schema_name, '') = COALESCE(l4.schema_name, '')
										AND l4.resource_type <> 'DATABASE'
									GROUP BY
										l4.resource_type,
										l4.page_type,
										l4.index_name,
										CASE 
											WHEN l4.object_name IS NULL THEN l4.schema_name
											ELSE NULL
										END,
										l4.principal_name,
										l4.resource_description,
										l4.request_mode,
										l4.request_status
									FOR XML
										PATH(''),
										TYPE
								) AS [Object/Locks]
							FROM #locks AS l3
							WHERE 
								l3.session_id = l1.session_id
								AND l3.request_id = l1.request_id
								AND l3.database_name = l1.database_name
								AND l3.resource_type <> 'DATABASE'
							GROUP BY 
								l3.session_id,
								l3.request_id,
								l3.database_name,
								COALESCE(l3.object_name, '(null)'),
								l3.schema_name
							FOR XML
								PATH(''),
								TYPE
						) AS [Database/Objects]
					FROM #locks AS l1
					WHERE
						l1.session_id = s.session_id
						AND l1.request_id = s.request_id
						AND l1.start_time IN (s.start_time, s.last_request_start_time)
						AND s.recursion = 1
					GROUP BY 
						l1.session_id,
						l1.request_id,
						l1.database_name
					FOR XML
						PATH(''),
						TYPE
				)
			FROM #sessions s
			OPTION (KEEPFIXED PLAN);
		END;

		IF 
			@find_block_leaders = 1
			AND @recursion = 1
			AND @output_column_list LIKE '%|[blocked_session_count|]%' ESCAPE '|'
		BEGIN;
			WITH
			blockers AS
			(
				SELECT
					session_id,
					session_id AS top_level_session_id,
					CONVERT(VARCHAR(8000), '.' + CONVERT(VARCHAR(8000), session_id) + '.') AS the_path
				FROM #sessions
				WHERE
					recursion = 1

				UNION ALL

				SELECT
					s.session_id,
					b.top_level_session_id,
					CONVERT(VARCHAR(8000), b.the_path + CONVERT(VARCHAR(8000), s.session_id) + '.') AS the_path
				FROM blockers AS b
				JOIN #sessions AS s ON
					s.blocking_session_id = b.session_id
					AND s.recursion = 1
					AND b.the_path NOT LIKE '%.' + CONVERT(VARCHAR(8000), s.session_id) + '.%' COLLATE Latin1_General_Bin2
			)
			UPDATE s
			SET
				s.blocked_session_count = x.blocked_session_count
			FROM #sessions AS s
			JOIN
			(
				SELECT
					b.top_level_session_id AS session_id,
					COUNT(*) - 1 AS blocked_session_count
				FROM blockers AS b
				GROUP BY
					b.top_level_session_id
			) x ON
				s.session_id = x.session_id
			WHERE
				s.recursion = 1;
		END;

		IF
			@get_task_info = 2
			AND @output_column_list LIKE '%|[additional_info|]%' ESCAPE '|'
			AND @recursion = 1
		BEGIN;
			CREATE TABLE #blocked_requests
			(
				session_id SMALLINT NOT NULL,
				request_id INT NOT NULL,
				database_name sysname NOT NULL,
				object_id INT,
				hobt_id BIGINT,
				schema_id INT,
				schema_name sysname NULL,
				object_name sysname NULL,
				query_error NVARCHAR(2048),
				PRIMARY KEY (database_name, session_id, request_id)
			);

			CREATE STATISTICS s_database_name ON #blocked_requests (database_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_schema_name ON #blocked_requests (schema_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_object_name ON #blocked_requests (object_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_query_error ON #blocked_requests (query_error)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
		
			INSERT #blocked_requests
			(
				session_id,
				request_id,
				database_name,
				object_id,
				hobt_id,
				schema_id
			)
			SELECT
				session_id,
				request_id,
				database_name,
				object_id,
				hobt_id,
				CONVERT(INT, SUBSTRING(schema_node, CHARINDEX(' = ', schema_node) + 3, LEN(schema_node))) AS schema_id
			FROM
			(
				SELECT
					session_id,
					request_id,
					agent_nodes.agent_node.value('(database_name/text())[1]', 'sysname') AS database_name,
					agent_nodes.agent_node.value('(object_id/text())[1]', 'int') AS object_id,
					agent_nodes.agent_node.value('(hobt_id/text())[1]', 'bigint') AS hobt_id,
					agent_nodes.agent_node.value('(metadata_resource/text()[.="SCHEMA"]/../../metadata_class_id/text())[1]', 'varchar(100)') AS schema_node
				FROM #sessions AS s
				CROSS APPLY s.additional_info.nodes('//block_info') AS agent_nodes (agent_node)
				WHERE
					s.recursion = 1
			) AS t
			WHERE
				t.database_name IS NOT NULL
				AND
				(
					t.object_id IS NOT NULL
					OR t.hobt_id IS NOT NULL
					OR t.schema_node IS NOT NULL
				);
			
			DECLARE blocks_cursor
			CURSOR LOCAL FAST_FORWARD
			FOR
				SELECT DISTINCT
					database_name
				FROM #blocked_requests;
				
			OPEN blocks_cursor;
			
			FETCH NEXT FROM blocks_cursor
			INTO 
				@database_name;
			
			WHILE @@FETCH_STATUS = 0
			BEGIN;
				BEGIN TRY;
					SET @sql_n = 
						CONVERT(NVARCHAR(MAX), '') +
						'UPDATE b ' +
						'SET ' +
							'b.schema_name = ' +
								'REPLACE ' +
								'( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
										's.name COLLATE Latin1_General_Bin2, ' +
										'NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''), ' +
										'NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''), ' +
										'NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''), ' +
									'NCHAR(0), ' +
									N''''' ' +
								'), ' +
							'b.object_name = ' +
								'REPLACE ' +
								'( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
										'o.name COLLATE Latin1_General_Bin2, ' +
										'NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''), ' +
										'NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''), ' +
										'NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''), ' +
									'NCHAR(0), ' +
									N''''' ' +
								') ' +
						'FROM #blocked_requests AS b ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.partitions AS p ON ' +
							'p.hobt_id = b.hobt_id ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.objects AS o ON ' +
							'o.object_id = COALESCE(p.object_id, b.object_id) ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.schemas AS s ON ' +
							's.schema_id = COALESCE(o.schema_id, b.schema_id) ' +
						'WHERE ' +
							'b.database_name = @database_name; ';
					
					EXEC sp_executesql
						@sql_n,
						N'@database_name sysname',
						@database_name;
				END TRY
				BEGIN CATCH;
					UPDATE #blocked_requests
					SET
						query_error = 
							REPLACE
							(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
									CONVERT
									(
										NVARCHAR(MAX), 
										ERROR_MESSAGE() COLLATE Latin1_General_Bin2
									),
									NCHAR(31),N'?'),NCHAR(30),N'?'),NCHAR(29),N'?'),NCHAR(28),N'?'),NCHAR(27),N'?'),NCHAR(26),N'?'),NCHAR(25),N'?'),NCHAR(24),N'?'),NCHAR(23),N'?'),NCHAR(22),N'?'),
									NCHAR(21),N'?'),NCHAR(20),N'?'),NCHAR(19),N'?'),NCHAR(18),N'?'),NCHAR(17),N'?'),NCHAR(16),N'?'),NCHAR(15),N'?'),NCHAR(14),N'?'),NCHAR(12),N'?'),
									NCHAR(11),N'?'),NCHAR(8),N'?'),NCHAR(7),N'?'),NCHAR(6),N'?'),NCHAR(5),N'?'),NCHAR(4),N'?'),NCHAR(3),N'?'),NCHAR(2),N'?'),NCHAR(1),N'?'),
								NCHAR(0),
								N''
							)
					WHERE
						database_name = @database_name;
				END CATCH;

				FETCH NEXT FROM blocks_cursor
				INTO
					@database_name;
			END;
			
			CLOSE blocks_cursor;
			DEALLOCATE blocks_cursor;
			
			UPDATE s
			SET
				additional_info.modify
				('
					insert <schema_name>{sql:column("b.schema_name")}</schema_name>
					as last
					into (/additional_info/block_info)[1]
				')
			FROM #sessions AS s
			INNER JOIN #blocked_requests AS b ON
				b.session_id = s.session_id
				AND b.request_id = s.request_id
				AND s.recursion = 1
			WHERE
				b.schema_name IS NOT NULL;

			UPDATE s
			SET
				additional_info.modify
				('
					insert <object_name>{sql:column("b.object_name")}</object_name>
					as last
					into (/additional_info/block_info)[1]
				')
			FROM #sessions AS s
			INNER JOIN #blocked_requests AS b ON
				b.session_id = s.session_id
				AND b.request_id = s.request_id
				AND s.recursion = 1
			WHERE
				b.object_name IS NOT NULL;

			UPDATE s
			SET
				additional_info.modify
				('
					insert <query_error>{sql:column("b.query_error")}</query_error>
					as last
					into (/additional_info/block_info)[1]
				')
			FROM #sessions AS s
			INNER JOIN #blocked_requests AS b ON
				b.session_id = s.session_id
				AND b.request_id = s.request_id
				AND s.recursion = 1
			WHERE
				b.query_error IS NOT NULL;
		END;

		IF
			@output_column_list LIKE '%|[program_name|]%' ESCAPE '|'
			AND @output_column_list LIKE '%|[additional_info|]%' ESCAPE '|'
			AND @recursion = 1
			AND DB_ID('msdb') IS NOT NULL
		BEGIN;
			SET @sql_n =
				N'BEGIN TRY;
					DECLARE @job_name sysname;
					SET @job_name = NULL;
					DECLARE @step_name sysname;
					SET @step_name = NULL;

					SELECT
						@job_name = 
							REPLACE
							(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
									j.name,
									NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''),
									NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''),
									NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''),
								NCHAR(0),
								N''?''
							),
						@step_name = 
							REPLACE
							(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
									s.step_name,
									NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''),
									NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''),
									NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''),
								NCHAR(0),
								N''?''
							)
					FROM msdb.dbo.sysjobs AS j
					INNER JOIN msdb.dbo.sysjobsteps AS s ON
						j.job_id = s.job_id
					WHERE
						j.job_id = @job_id
						AND s.step_id = @step_id;

					IF @job_name IS NOT NULL
					BEGIN;
						UPDATE s
						SET
							additional_info.modify
							(''
								insert text{sql:variable("@job_name")}
								into (/additional_info/agent_job_info/job_name)[1]
							'')
						FROM #sessions AS s
						WHERE 
							s.session_id = @session_id
							AND s.recursion = 1
						OPTION (KEEPFIXED PLAN);
						
						UPDATE s
						SET
							additional_info.modify
							(''
								insert text{sql:variable("@step_name")}
								into (/additional_info/agent_job_info/step_name)[1]
							'')
						FROM #sessions AS s
						WHERE 
							s.session_id = @session_id
							AND s.recursion = 1
						OPTION (KEEPFIXED PLAN);
					END;
				END TRY
				BEGIN CATCH;
					DECLARE @msdb_error_message NVARCHAR(256);
					SET @msdb_error_message = ERROR_MESSAGE();
				
					UPDATE s
					SET
						additional_info.modify
						(''
							insert <msdb_query_error>{sql:variable("@msdb_error_message")}</msdb_query_error>
							as last
							into (/additional_info/agent_job_info)[1]
						'')
					FROM #sessions AS s
					WHERE 
						s.session_id = @session_id
						AND s.recursion = 1
					OPTION (KEEPFIXED PLAN);
				END CATCH;'

			DECLARE @job_id UNIQUEIDENTIFIER;
			DECLARE @step_id INT;

			DECLARE agent_cursor
			CURSOR LOCAL FAST_FORWARD
			FOR 
				SELECT
					s.session_id,
					agent_nodes.agent_node.value('(job_id/text())[1]', 'uniqueidentifier') AS job_id,
					agent_nodes.agent_node.value('(step_id/text())[1]', 'int') AS step_id
				FROM #sessions AS s
				CROSS APPLY s.additional_info.nodes('//agent_job_info') AS agent_nodes (agent_node)
				WHERE
					s.recursion = 1
			OPTION (KEEPFIXED PLAN);
			
			OPEN agent_cursor;

			FETCH NEXT FROM agent_cursor
			INTO 
				@session_id,
				@job_id,
				@step_id;

			WHILE @@FETCH_STATUS = 0
			BEGIN;
				EXEC sp_executesql
					@sql_n,
					N'@job_id UNIQUEIDENTIFIER, @step_id INT, @session_id SMALLINT',
					@job_id, @step_id, @session_id

				FETCH NEXT FROM agent_cursor
				INTO 
					@session_id,
					@job_id,
					@step_id;
			END;

			CLOSE agent_cursor;
			DEALLOCATE agent_cursor;
		END; 
		
		IF 
			@delta_interval > 0 
			AND @recursion <> 1
		BEGIN;
			SET @recursion = 1;

			DECLARE @delay_time CHAR(12);
			SET @delay_time = CONVERT(VARCHAR, DATEADD(second, @delta_interval, 0), 114);
			WAITFOR DELAY @delay_time;

			GOTO REDO;
		END;
	END;

	SET @sql = 
		--Outer column list
		CONVERT
		(
			VARCHAR(MAX),
			CASE
				WHEN 
					@destination_table <> '' 
					AND @return_schema = 0 
						THEN 'INSERT ' + @destination_table + ' '
				ELSE ''
			END +
			'SELECT ' +
				@output_column_list + ' ' +
			CASE @return_schema
				WHEN 1 THEN 'INTO #session_schema '
				ELSE ''
			END
		--End outer column list
		) + 
		--Inner column list
		CONVERT
		(
			VARCHAR(MAX),
			'FROM ' +
			'( ' +
				'SELECT ' +
					'session_id, ' +
					--[dd hh:mm:ss.mss]
					CASE
						WHEN @format_output IN (1, 2) THEN
							'CASE ' +
								'WHEN elapsed_time < 0 THEN ' +
									'RIGHT ' +
									'( ' +
										'REPLICATE(''0'', max_elapsed_length) + CONVERT(VARCHAR, (-1 * elapsed_time) / 86400), ' +
										'max_elapsed_length ' +
									') + ' +
										'RIGHT ' +
										'( ' +
											'CONVERT(VARCHAR, DATEADD(second, (-1 * elapsed_time), 0), 120), ' +
											'9 ' +
										') + ' +
										'''.000'' ' +
								'ELSE ' +
									'RIGHT ' +
									'( ' +
										'REPLICATE(''0'', max_elapsed_length) + CONVERT(VARCHAR, elapsed_time / 86400000), ' +
										'max_elapsed_length ' +
									') + ' +
										'RIGHT ' +
										'( ' +
											'CONVERT(VARCHAR, DATEADD(second, elapsed_time / 1000, 0), 120), ' +
											'9 ' +
										') + ' +
										'''.'' + ' + 
										'RIGHT(''000'' + CONVERT(VARCHAR, elapsed_time % 1000), 3) ' +
							'END AS [dd hh:mm:ss.mss], '
						ELSE
							''
					END +
					--[dd hh:mm:ss.mss (avg)] / avg_elapsed_time
					CASE 
						WHEN  @format_output IN (1, 2) THEN 
							'RIGHT ' +
							'( ' +
								'''00'' + CONVERT(VARCHAR, avg_elapsed_time / 86400000), ' +
								'2 ' +
							') + ' +
								'RIGHT ' +
								'( ' +
									'CONVERT(VARCHAR, DATEADD(second, avg_elapsed_time / 1000, 0), 120), ' +
									'9 ' +
								') + ' +
								'''.'' + ' +
								'RIGHT(''000'' + CONVERT(VARCHAR, avg_elapsed_time % 1000), 3) AS [dd hh:mm:ss.mss (avg)], '
						ELSE
							'avg_elapsed_time, '
					END +
					--physical_io
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, physical_io))) OVER() - LEN(CONVERT(VARCHAR, physical_io))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_io), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_io), 1), 19)) AS '
						ELSE ''
					END + 'physical_io, ' +
					--reads
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, reads))) OVER() - LEN(CONVERT(VARCHAR, reads))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, reads), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, reads), 1), 19)) AS '
						ELSE ''
					END + 'reads, ' +
					--physical_reads
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, physical_reads))) OVER() - LEN(CONVERT(VARCHAR, physical_reads))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_reads), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_reads), 1), 19)) AS '
						ELSE ''
					END + 'physical_reads, ' +
					--writes
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, writes))) OVER() - LEN(CONVERT(VARCHAR, writes))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, writes), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, writes), 1), 19)) AS '
						ELSE ''
					END + 'writes, ' +
					--tempdb_allocations
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, tempdb_allocations))) OVER() - LEN(CONVERT(VARCHAR, tempdb_allocations))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_allocations), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_allocations), 1), 19)) AS '
						ELSE ''
					END + 'tempdb_allocations, ' +
					--tempdb_current
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, tempdb_current))) OVER() - LEN(CONVERT(VARCHAR, tempdb_current))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_current), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_current), 1), 19)) AS '
						ELSE ''
					END + 'tempdb_current, ' +
					--CPU
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, CPU))) OVER() - LEN(CONVERT(VARCHAR, CPU))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, CPU), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, CPU), 1), 19)) AS '
						ELSE ''
					END + 'CPU, ' +
					--context_switches
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, context_switches))) OVER() - LEN(CONVERT(VARCHAR, context_switches))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, context_switches), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, context_switches), 1), 19)) AS '
						ELSE ''
					END + 'context_switches, ' +
					--used_memory
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, used_memory))) OVER() - LEN(CONVERT(VARCHAR, used_memory))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, used_memory), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, used_memory), 1), 19)) AS '
						ELSE ''
					END + 'used_memory, ' +
					CASE
						WHEN @output_column_list LIKE '%|_delta|]%' ESCAPE '|' THEN
							--physical_io_delta			
							'CASE ' +
								'WHEN ' +
									'first_request_start_time = last_request_start_time ' + 
									'AND num_events = 2 ' +
									'AND physical_io_delta >= 0 ' +
										'THEN ' +
										CASE @format_output
											WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, physical_io_delta))) OVER() - LEN(CONVERT(VARCHAR, physical_io_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_io_delta), 1), 19)) ' 
											WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_io_delta), 1), 19)) '
											ELSE 'physical_io_delta '
										END +
								'ELSE NULL ' +
							'END AS physical_io_delta, ' +
							--reads_delta
							'CASE ' +
								'WHEN ' +
									'first_request_start_time = last_request_start_time ' + 
									'AND num_events = 2 ' +
									'AND reads_delta >= 0 ' +
										'THEN ' +
										CASE @format_output
											WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, reads_delta))) OVER() - LEN(CONVERT(VARCHAR, reads_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, reads_delta), 1), 19)) '
											WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, reads_delta), 1), 19)) '
											ELSE 'reads_delta '
										END +
								'ELSE NULL ' +
							'END AS reads_delta, ' +
							--physical_reads_delta
							'CASE ' +
								'WHEN ' +
									'first_request_start_time = last_request_start_time ' + 
									'AND num_events = 2 ' +
									'AND physical_reads_delta >= 0 ' +
										'THEN ' +
										CASE @format_output
											WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, physical_reads_delta))) OVER() - LEN(CONVERT(VARCHAR, physical_reads_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_reads_delta), 1), 19)) '
											WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_reads_delta), 1), 19)) '
											ELSE 'physical_reads_delta '
										END + 
								'ELSE NULL ' +
							'END AS physical_reads_delta, ' +
							--writes_delta
							'CASE ' +
								'WHEN ' +
									'first_request_start_time = last_request_start_time ' + 
									'AND num_events = 2 ' +
									'AND writes_delta >= 0 ' +
										'THEN ' +
										CASE @format_output
											WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, writes_delta))) OVER() - LEN(CONVERT(VARCHAR, writes_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, writes_delta), 1), 19)) '
											WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, writes_delta), 1), 19)) '
											ELSE 'writes_delta '
										END + 
								'ELSE NULL ' +
							'END AS writes_delta, ' +
							--tempdb_allocations_delta
							'CASE ' +
								'WHEN ' +
									'first_request_start_time = last_request_start_time ' + 
									'AND num_events = 2 ' +
									'AND tempdb_allocations_delta >= 0 ' +
										'THEN ' +
										CASE @format_output
											WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, tempdb_allocations_delta))) OVER() - LEN(CONVERT(VARCHAR, tempdb_allocations_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_allocations_delta), 1), 19)) '
											WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_allocations_delta), 1), 19)) '
											ELSE 'tempdb_allocations_delta '
										END + 
								'ELSE NULL ' +
							'END AS tempdb_allocations_delta, ' +
							--tempdb_current_delta
							--this is the only one that can (legitimately) go negative 
							'CASE ' +
								'WHEN ' +
									'first_request_start_time = last_request_start_time ' + 
									'AND num_events = 2 ' +
										'THEN ' +
										CASE @format_output
											WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, tempdb_current_delta))) OVER() - LEN(CONVERT(VARCHAR, tempdb_current_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_current_delta), 1), 19)) '
											WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_current_delta), 1), 19)) '
											ELSE 'tempdb_current_delta '
										END + 
								'ELSE NULL ' +
							'END AS tempdb_current_delta, ' +
							--CPU_delta
							'CASE ' +
								'WHEN ' +
									'first_request_start_time = last_request_start_time ' + 
									'AND num_events = 2 ' +
										'THEN ' +
											'CASE ' +
												'WHEN ' +
													'thread_CPU_delta > CPU_delta ' +
													'AND thread_CPU_delta > 0 ' +
														'THEN ' +
															CASE @format_output
																WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, thread_CPU_delta + CPU_delta))) OVER() - LEN(CONVERT(VARCHAR, thread_CPU_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, thread_CPU_delta), 1), 19)) '
																WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, thread_CPU_delta), 1), 19)) '
																ELSE 'thread_CPU_delta '
															END + 
												'WHEN CPU_delta >= 0 THEN ' +
													CASE @format_output
														WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, thread_CPU_delta + CPU_delta))) OVER() - LEN(CONVERT(VARCHAR, CPU_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, CPU_delta), 1), 19)) '
														WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, CPU_delta), 1), 19)) '
														ELSE 'CPU_delta '
													END + 
												'ELSE NULL ' +
											'END ' +
								'ELSE ' +
									'NULL ' +
							'END AS CPU_delta, ' +
							--context_switches_delta
							'CASE ' +
								'WHEN ' +
									'first_request_start_time = last_request_start_time ' + 
									'AND num_events = 2 ' +
									'AND context_switches_delta >= 0 ' +
										'THEN ' +
										CASE @format_output
											WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, context_switches_delta))) OVER() - LEN(CONVERT(VARCHAR, context_switches_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, context_switches_delta), 1), 19)) '
											WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, context_switches_delta), 1), 19)) '
											ELSE 'context_switches_delta '
										END + 
								'ELSE NULL ' +
							'END AS context_switches_delta, ' +
							--used_memory_delta
							'CASE ' +
								'WHEN ' +
									'first_request_start_time = last_request_start_time ' + 
									'AND num_events = 2 ' +
									'AND used_memory_delta >= 0 ' +
										'THEN ' +
										CASE @format_output
											WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, used_memory_delta))) OVER() - LEN(CONVERT(VARCHAR, used_memory_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, used_memory_delta), 1), 19)) '
											WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, used_memory_delta), 1), 19)) '
											ELSE 'used_memory_delta '
										END + 
								'ELSE NULL ' +
							'END AS used_memory_delta, '
						ELSE ''
					END +
					--tasks
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, tasks))) OVER() - LEN(CONVERT(VARCHAR, tasks))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tasks), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tasks), 1), 19)) '
						ELSE ''
					END + 'tasks, ' +
					'status, ' +
					'wait_info, ' +
					'locks, ' +
					'tran_start_time, ' +
					'LEFT(tran_log_writes, LEN(tran_log_writes) - 1) AS tran_log_writes, ' +
					--open_tran_count
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, open_tran_count))) OVER() - LEN(CONVERT(VARCHAR, open_tran_count))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, open_tran_count), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, open_tran_count), 1), 19)) AS '
						ELSE ''
					END + 'open_tran_count, ' +
					--sql_command
					CASE @format_output 
						WHEN 0 THEN 'REPLACE(REPLACE(CONVERT(NVARCHAR(MAX), sql_command), ''<?query --''+CHAR(13)+CHAR(10), ''''), CHAR(13)+CHAR(10)+''--?>'', '''') AS '
						ELSE ''
					END + 'sql_command, ' +
					--sql_text
					CASE @format_output 
						WHEN 0 THEN 'REPLACE(REPLACE(CONVERT(NVARCHAR(MAX), sql_text), ''<?query --''+CHAR(13)+CHAR(10), ''''), CHAR(13)+CHAR(10)+''--?>'', '''') AS '
						ELSE ''
					END + 'sql_text, ' +
					'query_plan, ' +
					'blocking_session_id, ' +
					--blocked_session_count
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, blocked_session_count))) OVER() - LEN(CONVERT(VARCHAR, blocked_session_count))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, blocked_session_count), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, blocked_session_count), 1), 19)) AS '
						ELSE ''
					END + 'blocked_session_count, ' +
					--percent_complete
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, CONVERT(MONEY, percent_complete), 2))) OVER() - LEN(CONVERT(VARCHAR, CONVERT(MONEY, percent_complete), 2))) + CONVERT(CHAR(22), CONVERT(MONEY, percent_complete), 2)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, CONVERT(CHAR(22), CONVERT(MONEY, blocked_session_count), 1)) AS '
						ELSE ''
					END + 'percent_complete, ' +
					'host_name, ' +
					'login_name, ' +
					'database_name, ' +
					'program_name, ' +
					'additional_info, ' +
					'start_time, ' +
					'login_time, ' +
					'CASE ' +
						'WHEN status = N''sleeping'' THEN NULL ' +
						'ELSE request_id ' +
					'END AS request_id, ' +
					'GETDATE() AS collection_time '
		--End inner column list
		) +
		--Derived table and INSERT specification
		CONVERT
		(
			VARCHAR(MAX),
				'FROM ' +
				'( ' +
					'SELECT TOP(2147483647) ' +
						'*, ' +
						'CASE ' +
							'MAX ' +
							'( ' +
								'LEN ' +
								'( ' +
									'CONVERT ' +
									'( ' +
										'VARCHAR, ' +
										'CASE ' +
											'WHEN elapsed_time < 0 THEN ' +
												'(-1 * elapsed_time) / 86400 ' +
											'ELSE ' +
												'elapsed_time / 86400000 ' +
										'END ' +
									') ' +
								') ' +
							') OVER () ' +
								'WHEN 1 THEN 2 ' +
								'ELSE ' +
									'MAX ' +
									'( ' +
										'LEN ' +
										'( ' +
											'CONVERT ' +
											'( ' +
												'VARCHAR, ' +
												'CASE ' +
													'WHEN elapsed_time < 0 THEN ' +
														'(-1 * elapsed_time) / 86400 ' +
													'ELSE ' +
														'elapsed_time / 86400000 ' +
												'END ' +
											') ' +
										') ' +
									') OVER () ' +
						'END AS max_elapsed_length, ' +
						CASE
							WHEN @output_column_list LIKE '%|_delta|]%' ESCAPE '|' THEN
								'MAX(physical_io * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(physical_io * recursion) OVER (PARTITION BY session_id, request_id) AS physical_io_delta, ' +
								'MAX(reads * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(reads * recursion) OVER (PARTITION BY session_id, request_id) AS reads_delta, ' +
								'MAX(physical_reads * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(physical_reads * recursion) OVER (PARTITION BY session_id, request_id) AS physical_reads_delta, ' +
								'MAX(writes * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(writes * recursion) OVER (PARTITION BY session_id, request_id) AS writes_delta, ' +
								'MAX(tempdb_allocations * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(tempdb_allocations * recursion) OVER (PARTITION BY session_id, request_id) AS tempdb_allocations_delta, ' +
								'MAX(tempdb_current * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(tempdb_current * recursion) OVER (PARTITION BY session_id, request_id) AS tempdb_current_delta, ' +
								'MAX(CPU * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(CPU * recursion) OVER (PARTITION BY session_id, request_id) AS CPU_delta, ' +
								'MAX(thread_CPU_snapshot * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(thread_CPU_snapshot * recursion) OVER (PARTITION BY session_id, request_id) AS thread_CPU_delta, ' +
								'MAX(context_switches * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(context_switches * recursion) OVER (PARTITION BY session_id, request_id) AS context_switches_delta, ' +
								'MAX(used_memory * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(used_memory * recursion) OVER (PARTITION BY session_id, request_id) AS used_memory_delta, ' +
								'MIN(last_request_start_time) OVER (PARTITION BY session_id, request_id) AS first_request_start_time, '
							ELSE ''
						END +
						'COUNT(*) OVER (PARTITION BY session_id, request_id) AS num_events ' +
					'FROM #sessions AS s1 ' +
					CASE 
						WHEN @sort_order = '' THEN ''
						ELSE
							'ORDER BY ' +
								@sort_order
					END +
				') AS s ' +
				'WHERE ' +
					's.recursion = 1 ' +
			') x ' +
			'OPTION (KEEPFIXED PLAN); ' +
			'' +
			CASE @return_schema
				WHEN 1 THEN
					'SET @schema = ' +
						'''CREATE TABLE <table_name> ( '' + ' +
							'STUFF ' +
							'( ' +
								'( ' +
									'SELECT ' +
										''','' + ' +
										'QUOTENAME(COLUMN_NAME) + '' '' + ' +
										'DATA_TYPE + ' + 
										'CASE ' +
											'WHEN DATA_TYPE LIKE ''%char'' THEN ''('' + COALESCE(NULLIF(CONVERT(VARCHAR, CHARACTER_MAXIMUM_LENGTH), ''-1''), ''max'') + '') '' ' +
											'ELSE '' '' ' +
										'END + ' +
										'CASE IS_NULLABLE ' +
											'WHEN ''NO'' THEN ''NOT '' ' +
											'ELSE '''' ' +
										'END + ''NULL'' AS [text()] ' +
									'FROM tempdb.INFORMATION_SCHEMA.COLUMNS ' +
									'WHERE ' +
										'TABLE_NAME = (SELECT name FROM tempdb.sys.objects WHERE object_id = OBJECT_ID(''tempdb..#session_schema'')) ' +
										'ORDER BY ' +
											'ORDINAL_POSITION ' +
									'FOR XML ' +
										'PATH('''') ' +
								'), + ' +
								'1, ' +
								'1, ' +
								''''' ' +
							') + ' +
						''')''; ' 
				ELSE ''
			END
		--End derived table and INSERT specification
		);

	SET @sql_n = CONVERT(NVARCHAR(MAX), @sql);

	EXEC sp_executesql
		@sql_n,
		N'@schema VARCHAR(MAX) OUTPUT',
		@schema OUTPUT;
END;
GO
PRINT N'Creating Procedure [dbo].[usp_WriteToFile]...';


GO

	CREATE PROC dbo.[usp_WriteToFile]
		@msg VARCHAR(7999),
		@file VARCHAR(300),
		@overwrite BIT = 0
	AS
	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 20.02.2019 (1.0)
	-- Description: Эта процедура производит построчную запись в файл.
					С помощью неё можно организовать файл скрипта powershell.
					Для записи в файл используется процедура xp_cmdshell.
	*/
	BEGIN
		SET NOCOUNT ON;
		DECLARE @cmd VARCHAR(7999),@ErrMsg nvarchar(3000),@rc int;
		set @cmd = N'cmd /k chcp 1251 && echo | echo '+COALESCE(LTRIM(@msg),'-')+CASE WHEN (@overwrite = 1) THEN ' > ' ELSE ' >> ' END +RTRIM(@file);
	--	SET @cmd = RTRIM('echo ' + COALESCE(LTRIM(@msg),'-') + CASE WHEN (@overwrite = 1) THEN ' > ' ELSE ' >> ' END + RTRIM(@file))
		EXEC @rc=[master].dbo.xp_cmdshell @cmd , no_output
		if @rc=1
		BEGIN
			set @ErrMsg=N'Ошибка при записи в файл '+@file;
			RAISERROR(@ErrMsg,11,1) WITH LOG;
		END;
		SET NOCOUNT OFF;
	END
GO
PRINT N'Creating Procedure [awr].[usp_pfc_collect]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 24.08.2015 (1.0)
	-- Description: Процедура для сбора и сохранения в базе sputnik данным мониторинга по наиболее важным
					счетчикам производительности SQL SERVER.
				
	-- Update:		01.09.2015 (1.1)
					Добавлена поддержка именованных экземпляров (переменная @instance_name).
					Если экземпляр именованных то в [object_name] будет имя экзепляра, а не SQLServer.  
					01.09.2015 (1.15)								
					Счетчик CPU Usage % теперь собираем из системного Extended Event (причем два счетчика: общая загрузка CPU и загрузка CPU текущим экземпляром SQL Server).
					14.09.2015 (1.2)
					Добавлен сбор нестантартных счетчиков по памяти, а также по времени выполнения активных запросов sp_whoisactive.
					23.09.2015 (1.3)
					Добавлен сбор нестандартных ДИНАМИЧЕСКИХ счетчиков, таких как Logical Disk (в разрезе по каждому диску).
					28.09.2015 (1.31)
					Включение и настройка xEvents [xe_DiskInfo] перенесена сюда (в начало) из процедуры usp_get_DiskMetr.
					19.11.2015 (1.32)
					Добавлен сбор информации о Uptime для SQL Server в часах.
					10.03.2016 (1.33)
					Оптимизация - при обращении к awr.pfc_data используем фильтр по полю tt (чтобы задействовать индекс).
					Результаты: длительность ДО:  ~25 сек, ПОСЛЕ: ~2 сек. Кол-во чтений стало на порядок меньше!
					27.05.2016 (1.34)
					Добавлен собственный счетчик Response time(ms)
					12.12.2016 (1.350)
					Добавлен собственный счетчик Tran_RunTime_min (время выполнения активных транзакций в мин.)
					24.04.2017 (1.371)
					Добавлены новые счетчики (по регламентным заданиям SQL).
					Также частично выполнена оптимизация при сборе - удалено обращение к awr.pfc_data - зачем сюда обращаться, если нужно просто вставить новые значения?
					19.03.2018 (1.380)
					Добавлены новые счётчики (по использованию TempDB).
					23.03.2018 (1.382)
					Добавлен новый счётчик Sleeping_tran- это кол-во зависших сесссий с открытыми транзакциями.
					02.04.2018 (1.383)
					Исправление сбора данных по использованию TempDB.
	-- ============================================= */
	CREATE PROCEDURE awr.usp_pfc_collect

	AS
	begin
		set nocount on;
		set LOCK_TIMEOUT 10000;
		declare @tt datetime, @instance_name nvarchar(128);
		declare @T1 table(id smallint, counter_type int, value numeric(19,2));
		IF NOT EXISTS (SELECT * FROM sys.server_event_sessions WHERE name = 'xe_DiskInfo')
		BEGIN
		--Настраиваем и включаем сборщик данных через Extended Events!
		--xEvents сессия для сбора информации о счетчиках группы Logical Disk (инфо обновляется каждые 15 сек.)
		--Данные сохраняются в кольцевой буфер и хранятся тут совсем недолго.
		--Эти данные нужно успеть захватить и обработать и положить в схему awr в базу sputnik.
			CREATE EVENT SESSION [xe_DiskInfo] ON SERVER 
				ADD EVENT sqlserver.perfobject_logicaldisk 
				ADD TARGET package0.ring_buffer(SET max_events_limit=(128),max_memory=(32768))
			WITH (MAX_MEMORY=4096 KB,EVENT_RETENTION_MODE=ALLOW_SINGLE_EVENT_LOSS,MAX_DISPATCH_LATENCY=10 SECONDS,MAX_EVENT_SIZE=0 KB,MEMORY_PARTITION_MODE=NONE,TRACK_CAUSALITY=OFF,STARTUP_STATE=ON);
			ALTER EVENT SESSION [xe_DiskInfo] ON SERVER STATE = START;
			--геренируем задержку в 30 сек, чтобы данные успелись собраться!
			--если не успеет собраться, тогда соберем в след. раз!
			waitfor delay '00:00:30.000';
		END
		declare @xml_data xml;
		SELECT @xml_data=CAST(xet.target_data AS xml)
				FROM sys.dm_xe_session_targets AS xet
				JOIN sys.dm_xe_sessions AS xe
				   ON (xe.address = xet.event_session_address)
				WHERE xe.name = 'xe_DiskInfo'
					and xet.target_name = 'ring_buffer';
		--select @xml_data;
		IF @xml_data is null
			--Если возвращен NULL, значит скорее всего Сессия не включена!
			ALTER EVENT SESSION [xe_DiskInfo] ON SERVER STATE = START;


		set @tt=getdate();
		select @instance_name=IIF(serverproperty('instancename') IS NULL, 'SQLServer', 'MSSQL$'+CAST(serverproperty('instancename') as varchar(128)));
		insert into @T1 (id, counter_type, value)
		select ph.id, ph.counter_type, CAST(pd.cntr_value as numeric(19,2)) as value
		from
		(
			select id, [object_name], counter_name, instance_name, counter_type
			from awr.pfc_handle
			where counter_type is not null
			union
			select id, [object_name], counter_name+' base', instance_name, null as counter_type
			from awr.pfc_handle
			where counter_type=537003264 --для этого типа счетчика нужно также получить базовое значение!
		) ph
		inner join sys.dm_os_performance_counters pd 
			on REPLACE(ph.[object_name],'#instance#',@instance_name)=rtrim(pd.[object_name]) and ph.[counter_name]=rtrim(pd.[counter_name])
				and (/*ph.counter_name like 'CPU usage %' or */ph.instance_name=pd.instance_name);
	
		--Сбор нестандартных счетчиков:
		--1. Кол-во запросов в sp_whoisactive;
		declare @T2 table(tt datetime null,id int null,cnt numeric(19,2));
		declare @T_tmp table(tt datetime null, counter_name nvarchar(300) null, instance_name nvarchar(300), value numeric(19,2));
		declare @id_spwhoisactive_count smallint=null, @id_sleeptran_count smallint=null;
		select @id_spwhoisactive_count=id from awr.pfc_handle where [object_name]='sputnik.awr' and counter_name='Active sessions (sp_whoisactive)' and instance_name='_Total';
		select @id_sleeptran_count=id from awr.pfc_handle where [object_name]='sputnik.awr' and counter_name='Active sessions (sp_whoisactive)' and instance_name='Sleep_transactions';
		if @id_spwhoisactive_count is not null
		begin tran
			insert into @T2(cnt)
			exec info.sp_who3 @busy_minutes=0,@get_count=1;
			update @T2
			set id=@id_spwhoisactive_count,tt=@tt
			where id is null
		commit
		if @id_sleeptran_count is not null
		begin tran
			insert into @T2(cnt)
			exec info.sp_who3 @busy_minutes=0,@get_count=1, @only_sleep_tran=1;;
			update @T2
			set id=@id_sleeptran_count,tt=@tt
			where id is null
		commit

		--2. Всего установлено памяти на сервере в Мб и всего использовано памяти в Мб из системного dmv:
		if exists(select id from awr.pfc_handle where [object_name]='sputnik.awr' and counter_name IN ('Physical Memory (Gb)','Physical Memory (Mb)'))
		begin
			;with cte_1 AS(
				SELECT 
					@tt as tt,
					cast(total_physical_memory_kb/(1024.00*1024.00) as numeric(19,2)) as _Total, 
					cast((total_physical_memory_kb-available_physical_memory_kb)/(1024.00*1024.00) as numeric(19,2)) as _Used,
					cast(available_physical_memory_kb/1024.00 as numeric(19,2)) as _Free 
				FROM sys.dm_os_sys_memory
			),
			cte_2 AS(
				SELECT 
					tt,
					instance_name,	
					value
				FROM cte_1
				unpivot(value for instance_name in ([_Total],[_Used],[_Free])
				)unpvt
			),
			cte_3 AS (
				select id,h.instance_name
				from awr.pfc_handle h
				where [object_name]='sputnik.awr' and counter_name IN ('Physical Memory (Gb)','Physical Memory (Mb)')
			)
			insert into @T2(tt,id,cnt)
			select 
				cte_2.tt,
				cte_3.id,	
				cte_2.value
			from cte_2
			inner join cte_3
				on cte_2.instance_name=cte_3.instance_name
			;
		end

		--3. Загрузка информации о текущем времени выполнения запросов (sp_whoisactive) 
		if exists(select id from awr.pfc_handle where [object_name]='sputnik.awr' and counter_name='Run_time_query_min')
		begin
			delete @T_tmp;
			insert into @T_tmp (tt,counter_name,instance_name, value)
			exec info.usp_SQLMon @Filter_Reads=0, @Filter_DurSec=0, @interval_sec=0, @get_runtime_metr=1;

			;with cte_src as (
				select tt, instance_name, value
				from @T_tmp
			),cte_pfc as
			(
				select distinct h.id,h.instance_name,max(d.tt) over (partition by h.id) as tt
				from awr.pfc_handle h
				left join awr.pfc_data d 
					on h.id=d.pfc_id  and d.tt>dateadd(minute,-10,@tt) --оптимизация - фильтруем, используем индекс чтобы быстро искать!
				where [object_name]='sputnik.awr' and counter_name='Run_time_query_min'
			)
			insert into @T2(tt,id,cnt)
			select 
				cte_src.tt,
				cte_pfc.id,	
				cte_src.value
			from cte_src
			inner join cte_pfc
				on cte_src.instance_name=cte_pfc.instance_name
				and (cte_src.tt>cte_pfc.tt or cte_pfc.tt is null)
			;		
		end
		
		--4. Загрузка CPU общая и текущим экземпляров SQL Server из системного Extended Events
		if exists(select id from awr.pfc_handle where [object_name]='sputnik.awr' and counter_name='CPU usage %')
		begin
			DECLARE @ts_now bigint = (SELECT cpu_ticks/(cpu_ticks/ms_ticks)FROM sys.dm_os_sys_info); 
			;WITH cte_1 AS(
				SELECT [timestamp], convert(xml, record) AS [record] 
				FROM sys.dm_os_ring_buffers 
				WHERE ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR' 
				AND record LIKE '%<SystemHealth>%'
			),
			cte_2 AS(   
				SELECT 
					100-record.value('(./Record/SchedulerMonitorEvent/SystemHealth/SystemIdle)[1]', 'int') AS [_Total], 
		 			record.value('(./Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]','int') AS [SQL], 
					CAST(DATEADD(ms, -1 * (@ts_now - [timestamp]), GETDATE()) as datetime2(0)) AS [tt] 
				FROM cte_1
				WHERE [timestamp]=(SELECT MAX([timestamp]) FROM cte_1)
			),
			cte_3 AS(
				select 
					tt,
					instance_name,	
					value
				from cte_2
				unpivot(value for instance_name in ([SQL],[_Total])
				)unpvt
			),
			cte_4 AS(
				select distinct h.id,h.instance_name,max(d.tt) as tt
				from awr.pfc_handle h
				left join awr.pfc_data d 
					on h.id=d.pfc_id  and d.tt>dateadd(minute,-10,@tt) --оптимизация - фильтруем, используем индекс чтобы быстро искать!
				where [object_name]='sputnik.awr' and counter_name='CPU usage %'
				group by h.id, h.instance_name
			)
			insert into @T2(tt,id,cnt)
			select 
				cte_3.tt,
				cte_4.id,	
				cte_3.value
			from cte_3
			inner join cte_4
				on cte_3.instance_name=cte_4.instance_name
				and (cte_3.tt>cte_4.tt or cte_4.tt is null)
			;
		end

		--5. Подготовка и загрузка динамических данных (например, данных по каждому дисковому разделу)
		declare @T_dyn table(tt datetime null, id smallint null, cnt numeric(19,2));
		if exists(select top 1 id from awr.pfc_handle where [object_name]='sputnik.awr' and instance_name='#dynamic#')
		begin
			delete @T_tmp;
			insert into @T_tmp (tt,counter_name,instance_name, value)
			exec info.usp_get_DiskMetr;
			--сначала загрузим информацию о заголовках (в таблицу pfc_handle_dyn), по тем данным, которых ещё нет!
			;with cte_dyn_h as (
				select h.id, T.instance_name
				from @T_tmp T
				inner join awr.pfc_handle h
					on T.counter_name=h.counter_name and h.[object_name]='sputnik.awr' and h.instance_name='#dynamic#'
			)
			MERGE
			INTO awr.pfc_handle_dyn as Target
			USING cte_dyn_h as Source
			ON (Source.id=Target.pfc_id and Source.instance_name=Target.instance_name)
			WHEN NOT MATCHED THEN
				INSERT (pfc_id,instance_name)
				VALUES (Source.id,Source.instance_name)
			;

			--теперь загрузим информацию о данных (сначала в @T_dyn, а в конце процедуры в таблицу pfc_data_dyn)!
			;with cte_1 as (
				select T.tt, dyn_h.id, T.value
				from @T_tmp T
				inner join awr.pfc_handle h
					on T.counter_name=h.counter_name and h.[object_name]='sputnik.awr' and h.instance_name='#dynamic#'
				inner join awr.pfc_handle_dyn dyn_h
					on h.id=dyn_h.pfc_id and T.instance_name=dyn_h.instance_name
			),
			cte_2 as (
				select distinct h.id, max(d.tt) as tt
				from cte_1 h
				left join awr.pfc_data_dyn d 
					on h.id=d.pfc_dyn_id  and d.tt>dateadd(minute,-10,@tt) --оптимизация - фильтруем, используем индекс чтобы быстро искать!
				group by h.id
			)
			insert into @T_dyn(tt,id,cnt)
			select 
				cte_1.tt, cte_1.id,	cte_1.value
			from cte_1
			inner join cte_2
				on cte_2.id=cte_1.id
				and (cte_1.tt>cte_2.tt or cte_2.tt is null)
			;
		end

		--6. Загрузка информации о текущем Uptime для SQL Server в часах
		if exists(select id from awr.pfc_handle where [object_name]='sputnik.awr' and counter_name='SQL Server Uptime (hours)')
		begin

			;with cte_1 AS(
				select top 1
					datediff(hour,create_date,getdate()) as value
				from sys.databases
				where name='tempdb'
			),
			cte_2 AS (
				select id
				from awr.pfc_handle h
				where [object_name]='sputnik.awr' and counter_name IN ('SQL Server Uptime (hours)')
			)
			insert into @T2(tt,id,cnt)
			select 
				@tt,
				(select id from cte_2) as id,	
				(select value from cte_1) as value
			from cte_1
			;
		end

		--7. Загрузка информации о Времени отклика (в милисек.)
		if exists(select id from awr.pfc_handle where [object_name]='sputnik.awr' and counter_name='Response time (ms)')
		begin
			declare @tt_start datetime2, @tt_end datetime2, @t float, @i smallint=0;
			set @tt_start=SYSDATETIME();
			if object_id('tempdb.dbo.#t') is not null
				drop table #t;
			create table #t(t float);
			while (@i<100)
			begin
				insert into #t(t)
				select square((rand()/PI()) * log(rand()) * cos(rand())) as t option(maxdop 0);
				insert into #t(t)
				select square((rand()/2) * log10(rand()) * sin(rand())) as t option(maxdop 0);
				insert into #t(t)
				select square((rand()/3) * log(rand()) * tan(rand())) as t option(maxdop 0);
				insert into #t(t)
				select square((rand()/4) * log10(rand()) * abs(rand())) as t option(maxdop 0);
				insert into #t(t)
				select square((rand()/5) * log(rand()) * cos(rand())) as t option(maxdop 0);
				set @i+=1;
			end
			select @t=avg(t) from #t option(maxdop 0, recompile);
			select @t=max(t) from #t option(maxdop 0, recompile);
			select @t=min(t) from #t option(maxdop 0, recompile);
			select @t=sum(t) from #t option(maxdop 0, recompile);
			set @tt_end=SYSDATETIME();

			;with cte_1 AS(
				select datediff(MILLISECOND,@tt_start, @tt_end) as value
				--option(maxdop 0)
			),
			cte_2 AS (
				select id
				from awr.pfc_handle h
				where [object_name]='sputnik.awr' and counter_name IN ('Response time (ms)')
			)
			insert into @T2(tt,id,cnt)
			select 
				@tt,
				(select id from cte_2) as id,	
				(select value from cte_1) as value
			from cte_1
			;
		end

		--8. Загрузка информации о текущем времени выполнения Транзакций (sys.dm_tran_active_transactions) 
		if exists(select id from awr.pfc_handle where [object_name]='sputnik.awr' and counter_name='Tran_RunTime_min')
		begin
			delete @T_tmp;
			;with cte_src1 as(
				select transaction_id as tran_id, [name],transaction_type as tran_type,transaction_state as tran_state, datediff(minute,transaction_begin_time,@tt) as dur_sec,
					row_number() over (order by transaction_begin_time asc, transaction_id asc) as rnk
				from sys.dm_tran_active_transactions
				where transaction_id>1000 and transaction_type<>2
			)
			, cte_src2 as (
				select distinct sum(dur_sec) over () as top5
				from cte_src1
				where rnk<=5
			)
			insert into @T_tmp (tt,counter_name,instance_name, value)
			select distinct @tt as tt, 'Tran_RunTime_min' as counter_name, '_All' as instance_name, sum(dur_sec) over () as [value]
			from cte_src1
			UNION ALL
			select distinct @tt as tt, 'Tran_RunTime_min' as counter_name, '_Max' as instance_name, max(dur_sec) over () as [value]
			from cte_src1
			UNION ALL
			select distinct @tt as tt, 'Tran_RunTime_min' as counter_name, '_Avg' as instance_name, avg(dur_sec) over () as [value]
			from cte_src1
			UNION ALL
			select distinct @tt as tt, 'Tran_RunTime_min' as counter_name, '_Top5' as instance_name, top5 as [value]
			from cte_src2;

			;with cte_src as (
				select tt, instance_name, value
				from @T_tmp
			),cte_pfc as
			(
				select distinct h.id,h.instance_name
				from awr.pfc_handle h
				where [object_name]='sputnik.awr' and counter_name='Tran_RunTime_min'
			)
			insert into @T2(tt,id,cnt)
			select 
				cte_src.tt,
				cte_pfc.id,	
				cte_src.value
			from cte_src
			inner join cte_pfc
				on cte_src.instance_name=cte_pfc.instance_name
			;		
		end

		--9. Загрузка информации о sp_whoisactive: сколько строк возвращает, и за сколько мсек. отрабатывает 
		if exists(select id from awr.pfc_handle where [object_name]='sputnik.awr' and counter_name='sp_whoisactive')
		begin
			delete @T_tmp;
			declare @cnt bigint;
			--сформируем схему таблицу и создадим таблицу [tempdb].[dbo].[sp_whoisactive_collect]
			--drop table [tempdb].[dbo].[sp_whoisactive_collect];
			if OBJECT_ID('[tempdb].[dbo].[sp_whoisactive_collect]') IS NULL
			BEGIN
				declare @schema nvarchar(MAX);
				exec sp_whoisactive @schema=@schema output, @return_schema=1,@output_column_list = '[start_time][dd hh:mm:ss.mss][session_id][sql_text][host_name][login_name][program_name][database_name][wait_info][CPU][tempdb%][block%][reads][writes][physical_reads][used_memory][status][open_tran_count][percent_complete][collection_time]'
				set @schema=replace(@schema,'<table_name>', '[tempdb].[dbo].[sp_whoisactive_collect]');
				set @schema=replace(@schema,'[dd hh:mm:ss.mss] varchar(8000)', '[dd hh:mm:ss.mss] varchar(50)');
				set @schema=replace(@schema,'varchar(4000)', 'varchar(500)');
				--select @schema;
				exec(@schema);
			END;
			TRUNCATE TABLE [tempdb].[dbo].[sp_whoisactive_collect];
			set @tt_start=SYSDATETIME();
			EXEC sp_WhoIsActive 
				@output_column_list = '[start_time][dd hh:mm:ss.mss][session_id][sql_text][host_name][login_name][program_name][database_name][wait_info][CPU][tempdb%][block%][reads][writes][physical_reads][used_memory][status][open_tran_count][percent_complete][collection_time]'
				,@destination_table = '[tempdb].[dbo].[sp_whoisactive_collect]';
			select @cnt=COUNT_BIG(*) from [tempdb].[dbo].[sp_whoisactive_collect]; 
			set @tt_end=SYSDATETIME();
	
			insert into @T_tmp (tt,counter_name,instance_name, value)
			select distinct @tt as tt, 'sp_whoisactive' as counter_name, 'cnt' as instance_name, @cnt as [value]
			UNION ALL
			select distinct @tt as tt, 'sp_whoisactive' as counter_name, 'elapsed_time_ms' as instance_name, datediff(MILLISECOND,@tt_start, @tt_end) as [value];

			;with cte_src as (
				select tt, instance_name, value
				from @T_tmp
			),cte_pfc as
			(
				select distinct h.id,h.instance_name
				from awr.pfc_handle h
				where [object_name]='sputnik.awr' and counter_name='sp_whoisactive'
			)
			insert into @T2(tt,id,cnt)
			select 
				cte_src.tt,
				cte_pfc.id,	
				cte_src.value
			from cte_src
			inner join cte_pfc
				on cte_src.instance_name=cte_pfc.instance_name
			;		
		end

		--10. Загрузка информации о регламентых заданиях (Jobs) sputnik 
		if exists(select id from awr.pfc_handle where [object_name]='sputnik.awr' and counter_name LIKE 'Job$_%' ESCAPE '$')
		begin
			delete @T_tmp;
			declare @TJ TABLE (Job nvarchar(2000), Step nvarchar(2000),RUN_STATUS varchar(50), Duration_min numeric(19,2));
			insert into @TJ (Job,Step,RUN_STATUS,Duration_min)
			exec sputnik.info.usp_JobMonitor @Lite=1, @OnlyEnabled=0;

			insert into @T_tmp (tt,counter_name,instance_name, [value])
			select distinct @tt as tt, 'Job_Backup_min' as counter_name, 'Full_or_Diff' as instance_name, CASE WHEN RUN_STATUS='Running' THEN [Duration_min] ELSE 0 END as [value]
			from @TJ
			where Job LIKE '%BackupFull Всех БД%'
			UNION ALL
			select distinct @tt as tt, 'Job_Backup_min' as counter_name, 'Log' as instance_name, CASE WHEN RUN_STATUS='Running' THEN [Duration_min] ELSE 0 END as [value]
			from @TJ
			where Job LIKE '%BackupLog Всех БД%'
			UNION ALL
			select distinct @tt as tt, 'Job_Index_Stats_min' as counter_name, 'GetInfo' as instance_name, CASE WHEN RUN_STATUS='Running' THEN [Duration_min] ELSE 0 END as [value]
			from @TJ
			where Job LIKE '%Обслуживание индексов. Сбор статистик%'
			UNION ALL
			select distinct @tt as tt, 'Job_Index_Stats_min' as counter_name, 'ReIndex' as instance_name, CASE WHEN RUN_STATUS='Running' AND Step='1.rebuild indexes' THEN [Duration_min] ELSE 0 END as [value]
			from @TJ
			where Job LIKE '%Обслуживание индексов. Реиндексация%'
			UNION ALL
			select distinct @tt as tt, 'Job_Index_Stats_min' as counter_name, 'UpdStats' as instance_name, CASE WHEN RUN_STATUS='Running' AND Step='2.recompute stats' THEN [Duration_min] ELSE 0 END as [value]
			from @TJ
			where Job LIKE '%Обслуживание индексов. Реиндексация%'
			UNION ALL
			select distinct @tt as tt, 'Job_Index_Stats_min' as counter_name, 'UpdStatsOpt' as instance_name, CASE WHEN RUN_STATUS='Running' THEN [Duration_min] ELSE 0 END as [value]
			from @TJ
			where Job LIKE '%Обслуживание индексов. Optimizing updatestats%'
			UNION ALL
			select distinct @tt as tt, 'Job_RM_min' as counter_name, '' as instance_name, CASE WHEN RUN_STATUS='Running' THEN sum([Duration_min]) over() ELSE 0 END as [value]
			from @TJ
			where Job LIKE 'RM%'
			UNION ALL
			select distinct @tt as tt, 'Job_ShrinkTempDB_min' as counter_name, '' as instance_name, CASE WHEN RUN_STATUS='Running' THEN [Duration_min] ELSE 0 END as [value]
			from @TJ
			where Job LIKE '%Зачистка TempDb%'
			UNION ALL
			select distinct @tt as tt, 'Job_Cntr' as counter_name, 'All' as instance_name, COUNT_BIG(DISTINCT Job) as [value]
			from @TJ
			UNION ALL
			select distinct @tt as tt, 'Job_Cntr' as counter_name, 'Active' as instance_name, COUNT_BIG(DISTINCT Job) as [value]
			from @TJ
			where RUN_STATUS='Running' and Job not like '% Сбор данных awr. pfc%'
			UNION ALL
			select distinct @tt as tt, 'Job_Cntr' as counter_name, 'Failed_or_Cancel' as instance_name, COUNT_BIG(DISTINCT Job) as [value]
			from @TJ
			where RUN_STATUS IN ('Failed','Canceled by user')
			;

			;with cte_pfc as
			(
				select distinct h.id, h.instance_name, h.counter_name
				from awr.pfc_handle h
				where [object_name]='sputnik.awr' and counter_name LIKE 'Job$_%' ESCAPE '$'
			)
			insert into @T2(tt,id,cnt)
			select 
				src.tt,
				cte_pfc.id,	
				src.[value]
			from @T_tmp as src
			inner join cte_pfc
				on src.counter_name=cte_pfc.counter_name AND src.instance_name=cte_pfc.instance_name
			;		
		end

		--11. Загрузка информации об использовании TempDB в Мб
		if exists(select id from awr.pfc_handle where [object_name]='sputnik.awr' and counter_name = 'tempdb_using_Mb')
		begin
			delete @T_tmp;
			;with cte_src1 as(
				select distinct
					CASE pr 
						WHEN 'rowver_mb' THEN 'Row-versions'
						WHEN 'user_mb' THEN 'User-objects'
						WHEN 'internal_mb' THEN 'Internal'
						WHEN 'mixed_mb' THEN 'Mixed-extents'
						WHEN 'total_mb' THEN '_Total'
						ELSE NULL
					END as instance_name,	 
					vl as [value]
				from sputnik.info.vtempusing
			)
			insert into @T_tmp (tt,counter_name,instance_name, value)
			select @tt as tt, 'tempdb_using_Mb' as counter_name, instance_name, [value]
			from cte_src1;

			;with cte_src as (
				select tt, instance_name, [value]
				from @T_tmp
			),cte_pfc as
			(
				select distinct h.id,h.instance_name
				from awr.pfc_handle h
				where [object_name]='sputnik.awr' and counter_name='tempdb_using_Mb'
			)
			insert into @T2(tt,id,cnt)
			select 
				cte_src.tt,
				cte_pfc.id,	
				cte_src.value
			from cte_src
			inner join cte_pfc
				on cte_src.instance_name=cte_pfc.instance_name
			;		
		end


		--Загружаем в таблицу в БД sputnik все собранные данные Счетчиков производительности из dm_os_performance_counters и другие
		insert into awr.pfc_data(tt,pfc_id,value)
		select distinct @tt as tt, T.id as pfc_id,
			case 
				when T_base.value_base=0.00 then 0.00
				when T.counter_type=537003264 and T_base.value_base is not null then cast(t.value / T_base.value_base * 100.00  as numeric(19,2))
				else value
			end as value
		from 
		(
			select distinct id, counter_type,
				case 
					when counter_type=537003264 then SUM(value) over (partition by id)
					else value
				end as value
			from @T1
			where counter_type is not null
		) as T
		left join
		(
			select id, MAX(value) over (partition by id,counter_type) as value_base
			from @T1
			where counter_type is null
		) T_base
			on T.id=T_base.id
		UNION
		select tt, id as pfc_id, cnt as value
		from @T2
		;
	
		--Загружаем в таблицу в БД sputnik все собранные ДИНАМИЧЕСКИЕ данные 
		insert into awr.pfc_data_dyn(tt,pfc_dyn_id,value)
		select distinct tt, id as pfc_dyn_id, cnt as value
		from @T_dyn; 

	end
GO
PRINT N'Creating Procedure [backups].[usp_CopyBack]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 09.11.2014 (1.0)
	-- Description: Эта процедура производит копирование файлов резервных копий (бэкапов) в каталог для копий бэкапов (если такой каталог определён!).
					Все пути к резервным копиям и к копиям бэкапов должны быть определены в базе sputnik!
					После того, как файл бэкапа будет скопирован, расширения файлов переименовывается из .ONLY в .BAK
					Производится формирование сценария PowerShell для поиска, копирования и переименования файлов бэкапов, и в конце производится запуск этого сценария.

	-- Update:		16.11.2014 (1.01)
					Если в параметре @type задан Full, тогда сразу учитывается и Full и Diff бэкапы!
					21.11.2014 (1.05)
					Новый алгоритм - теперь файлы скриптов PowerShell формируется динамически, чтобы исключить вероятное пересечение!
					А очистка от старых файлов скриптов будет производиться в модуле [usp_CleaningBack].
					Также изменен алгоритм формирование исключений - теперь текст ошибки формируется через переменную @ErrMsg.
					31.12.2014 (1.06)
					Добавлена проверка наличие обрабатываемых данных перед выполнением!
					23.06.2015 (1.07)
					Добавлен учет имени экземпляра в алгоритм формирования файлов скриптов.
					21.10.2015 (1.10)
					Добавлена дополнительная проверка при переименовании расширения в локальном каталоге - 
					переименовываем только если в каталоге Копий есть такой файл! 
					А также добавлен новый параметр @FilterBackupID - позволяет найти файл бэкапа по ИД и копировать только его
					(добавляется ещё одно условие в отбор файлов).
					01.07.2016 (1.11)
					Добавлен новый параметр @XLastHours - Определяет фильтр по дате (за последние X указанных часов). 
					Не учитывается, если заданы @DateStart и @DateEnd. По умолчанию - за всё время (то есть фильтр не используется).
					22.12.2017 (1.120)
					Добавлен алгоритм экранирования спец.символов при поиске каталогов.
					19.04.2018 (1.121)
					Добавлена проверка при отборе бэкапов - только для существующих online баз!
					21.02.2019 (1.400)
					Изменён алгоритм: добавлено логгирование, запись файла скрипта через новую процедуру [usp_WriteToFile].
	-- ============================================= */
	create PROCEDURE backups.[usp_CopyBack]  
		@type varchar(4) = null				--тип бэкапа Log, Diff или Full.
		,@DBFilter nvarchar(100) = null		--фильтр по конкретной БД.
		,@Force	bit = 0						--флаг принудительного копирования (копирует даже если расширение = .BAK).
		,@DateStart datetime = null			
		,@DateEnd   datetime = null			--фильтр по дате. Будут копироваться только бэкапы в указанный период (если он задан!)
		,@FilterBackupID int = null			--Копировать будем конкретный файл бэкапа. Определяем этот файл бэкапа по ID
		,@XLastHours smallint = null		--Новый параметр. Определяет фильтр по дате (за последние X указанных часов). Не учитывается, если заданы @DateStart и @DateEnd 	
	AS
	BEGIN
		SET NOCOUNT ON;
		declare @Find_command nvarchar(3600), @Filter_FileName nvarchar(500), @PS_command nvarchar(2400), @CMD nvarchar(2800),@rc bit, @LocalDir nvarchar(1600), @NetDir nvarchar(1600), @rez_filter nvarchar(75), @date_filter nvarchar(200)='';
		declare @PSFile nvarchar(300), @Kind varchar(4), @DBName nvarchar(400), @ErrMsg nvarchar(900), @InstanceName nvarchar(128), @LogFile nvarchar(300);
		declare @Log_command nvarchar(3600);
		--Перед выполнением проверяем наличие обрабатываемых данных!
		if exists(
				select bc.DBName
				from sputnik.info.vGetAllBackConf bc
				inner join sys.databases sdb on bc.DBName=sdb.[name] and sdb.state_desc='ONLINE'
				where
					(@DBFilter is null or bc.DBName=@DBFilter)
					and (@type is null or (@type='Full' and bc.Kind IN ('Full','Diff')) or bc.Kind=@type)	--Если задан Full, тогда нужно учесть и Full и Diff.
					and (bc.NetDir is not null and bc.NetDir<>'' and bc.LocalDir<>bc.NetDir) --обязательное условия для копирования файлов!
			)
		BEGIN
			--получаем все настройки бэкапов из БД sputnik и сохраняем в курсор!
			declare C cursor for
			select distinct bc.LocalDir, bc.NetDir, bc.DBName, bc.Kind
			from sputnik.info.vGetAllBackConf bc
			inner join sys.databases sdb on bc.DBName=sdb.[name] and sdb.state_desc='ONLINE'
			where
				(@DBFilter is null or bc.DBName=@DBFilter)
				and (@type is null or (@type='Full' and bc.Kind IN ('Full','Diff')) or bc.Kind=@type)	--Если задан Full, тогда нужно учесть и Full и Diff.
				and (bc.NetDir is not null and bc.NetDir<>'' and bc.LocalDir<>bc.NetDir) --обязательное условия для копирования файлов!
			--Если задан конкретный ИД бэкапа тогда получим имя файла из таблицы и добавим это имя в условия поиска
			if @FilterBackupID is not null
			begin
				declare @BackupFile nvarchar(500);
				DECLARE @ChainBack TABLE (BackupFile NVARCHAR(800), BackupType VARCHAR(4), ID INT, BackupDate DATETIME2(2));
				INSERT INTO @ChainBack (BackupFile, BackupType, ID, BackupDate)
				EXEC sputnik.info.usp_GetChainLogs @DBName=@DBFilter,@FilterBackupID=@FilterBackupID, @top=1, @FromCopy=0, @GetBackupFile=1;
			
				select top 1 @BackupFile=BackupFile from @ChainBack;
				if @BackupFile IS NOT NULL AND @BackupFile<>'' 
				begin
					set @Filter_FileName=' -and ($_.Name) -like "'+@BackupFile+'*"';
				end
				else
					set @Filter_FileName='';
			end
			else
				set @Filter_FileName='';
			--определяем поиск по расширению
			if @Force=0
				set @rez_filter='$_.extension -eq ".ONLY"';
			else
				set @rez_filter='($_.extension -eq ".ONLY" -or $_.extension -eq ".BAK")';
			--определяем поиск по датам
			if @DateStart is not null or @DateEnd is not null
			begin
				if @DateStart is not null
					set @date_filter='-and $_.lastwritetime -ge "'+convert(nvarchar(50),@DateStart,120)+'" ';
				if @DateEnd is not null
					set @date_filter=@date_filter+'-and $_.lastwritetime -le "'+convert(nvarchar(50),@DateEnd,120)+'" ';
			end
			else if @XLastHours is not null
			begin
				set @date_filter='-and $_.lastwritetime -ge "'+convert(nvarchar(50),DATEADD(HOUR,-@XLastHours,GETDATE()),120)+'" '+
								 '-and $_.lastwritetime -le "'+convert(nvarchar(50),GETDATE(),120)+'" ';
			end 
			--формируем Имя файла скрипта, в зависимости от параметра ТипБэкапа.
			--Также добавляем текущее время к имени файла.
			--Все это нужно, чтобы исключить вероятность пересечение разных бэкапов.
			--+ теперь ещё учитывается имя экземпляра SQL Server и добавляется в имя файла.
			SELECT @InstanceName=COALESCE('_'+CAST(SERVERPROPERTY('InstanceName') as nvarchar(128)),'');
			set @PSFile='usp_CopyBack'+@InstanceName;
			if @type is not null
				set @PSFile=@PSFile+'_'+@type;
			else
				set @PSFile=@PSFile+'_ALL';
			set @PSFile=@PSFile+'_'+REPLACE(REPLACE(SUBSTRING(CONVERT(NVARCHAR(23),GETDATE(),126),1,23),'T','_'),':','.');
			set @LogFile=@PSFile+'.log';
			set @PSFile='%temp%\'+@PSFile+'.ps1';
			--1. Формируем файл скрипта PowerShell
			set @CMD = N'#PowerShell-Script for COPY backups. Created by Job on local SQL Server. Date: '+convert(varchar(20),getdate(),120);
			exec dbo.[usp_WriteToFile] @CMD, @PSFile, 1;
			set @CMD = N'$ErrorActionPreference = ^^^"stop^^^"';
			exec dbo.[usp_WriteToFile] @CMD, @PSFile;
			set @CMD = N'#Logs for COPY backups. Created by Job on local SQL Server. Date: '+convert(varchar(20),getdate(),120);
			exec dbo.[usp_WriteToFile] @CMD, @LogFile, 1;
			open C
			fetch next from C
			into @LocalDir, @NetDir, @DBName, @Kind
			while @@FETCH_STATUS=0
			begin
				--Экранируем символы [ и ], чтобы PowerShell смог обнаружить каталоги (если такие символы использованы):
				IF CHARINDEX('[', @LocalDir)>0
					SET @LocalDir=REPLACE(@LocalDir,'[','``[');
				IF CHARINDEX(']', @LocalDir)>0
					SET @LocalDir=REPLACE(@LocalDir,']','``]');
				IF CHARINDEX(']', @NetDir)>0
					SET @NetDir=REPLACE(@NetDir,']','``]');
				IF CHARINDEX(']', @NetDir)>0
					SET @NetDir=REPLACE(@NetDir,']','``]');
				--Блок TRY:
				set @PS_command=N'Try {';
				exec dbo.[usp_WriteToFile] @PS_command, @PSFile;
				--Ищем файлы бэкапов локально
				set @Find_command=N'get-childitem -path "'+@LocalDir+N'" ^^^| where {'+@rez_filter+' -and $_.Name -like "*'+@DBName+'*'+@Kind+N'*" '+@date_filter+@Filter_FileName+'} ^^^|';
				--Логируем найденные файлы бэкапов:
				set @Log_command=N'echo "$(Get-Date -Format "dd-MM-yyyy HH:mm:ss.ms") INFO Начало копирования (база: '+@DBName+N', тип бэкапа: '+@Kind+') " ^^^>^^^> %temp%\'+@LogFile;
				exec dbo.[usp_WriteToFile] @Log_command, @PSFile;
				set @Log_command=N'echo "INFO Всего файлов: $(('+REPLACE(@Find_command,'^^^','')+N' measure).count) ; Размер_Гб: $([math]::round((('+REPLACE(@Find_command,'^^^','')+N' measure length -sum).sum / 1gb),2)) ; Список файлов далее:" ^^^>^^^>  %temp%\'+@LogFile; 
				exec dbo.[usp_WriteToFile] @Log_command, @PSFile;
				set @Log_command=@Find_command+N' select Name -expand Name ^^^>^^^>  %temp%\'+@LogFile; 
				exec dbo.[usp_WriteToFile] @Log_command, @PSFile;
				--Копирование
				set @PS_command=@Find_command+' Copy-Item -Destination "'+@NetDir+'" -Force';
				exec dbo.[usp_WriteToFile] @PS_command, @PSFile;
				--Переименование расширений файлов в локальном каталоге!
				--Дополнительная проверка - переименовываем только если в каталоге Копий есть такой файл!
				set @Log_command=N'echo "$(Get-Date -Format "dd-MM-yyyy HH:mm:ss.ms") INFO Конец копирования " ^^^>^^^> %temp%\'+@LogFile;
				exec dbo.[usp_WriteToFile] @Log_command, @PSFile;
				set @Log_command=N'echo "$(Get-Date -Format "dd-MM-yyyy HH:mm:ss.ms") INFO Начало переименования (LocalDir, база: '+@DBName+N', тип бэкапа: '+@Kind+') .ONLY в .BAK " ^^^>^^^>  %temp%\'+@LogFile;
				exec dbo.[usp_WriteToFile] @Log_command, @PSFile;
				set @Log_command=@Find_command+N' select Name -expand Name ^^^>^^^>  %temp%\'+@LogFile; 
				exec dbo.[usp_WriteToFile] @Log_command, @PSFile;
				declare @Check_command nvarchar(500);
				set @Check_command=' WHERE {(Test-Path ("'+@NetDir+'"+$_.Name)) -eq $true} ^^^|';
				set @PS_command=@Find_command+@Check_command+' Rename-Item -newname { $_.name -replace "\.ONLY",".BAK" }';
				exec dbo.[usp_WriteToFile] @PS_command, @PSFile;
				--Переименование расширений файлов в каталоге копий бэкапов!
				set @Log_command=N'echo "$(Get-Date -Format "dd-MM-yyyy HH:mm:ss.ms") INFO Начало переименования (NetDir, база: '+@DBName+N', тип бэкапа: '+@Kind+') .ONLY в .BAK " ^^^>^^^>  %temp%\'+@LogFile;
				exec dbo.[usp_WriteToFile] @Log_command, @PSFile;
				set @Find_command=REPLACE(@Find_command, '-path "'+@LocalDir+N'"' , '-path "'+@NetDir+N'"'); 
				set @Log_command=@Find_command+N' select Name -expand Name ^^^>^^^>  %temp%\'+@LogFile; 
				exec dbo.[usp_WriteToFile] @Log_command, @PSFile;
				set @PS_command=@Find_command+' Rename-Item -newname { $_.name -replace "\.ONLY",".BAK" }';
				exec dbo.[usp_WriteToFile] @PS_command, @PSFile;
				--Логирование конца + закрываем скобку для Try
				set @Log_command=N'echo "$(Get-Date -Format "dd-MM-yyyy HH:mm:ss.ms") INFO Конец переименования " ^^^>^^^> %temp%\'+@LogFile;
				exec dbo.[usp_WriteToFile] @Log_command, @PSFile;
				set @Log_command=N'}'; 
				exec dbo.[usp_WriteToFile] @Log_command, @PSFile;
				set @PS_command=N'Catch {';
				exec dbo.[usp_WriteToFile] @PS_command, @PSFile;
				--Логирование + BREAK + закрываем скобку для Catch
				set @Log_command=N'echo "$(Get-Date -Format "dd-MM-yyyy HH:mm:ss.ms") ERROR $($error[0].exception) " ^^^>^^^> %temp%\'+@LogFile;
				exec dbo.[usp_WriteToFile] @Log_command, @PSFile;
				set @Log_command=N'BREAK';
				exec dbo.[usp_WriteToFile] @Log_command, @PSFile;
				set @Log_command=N'}';
				exec dbo.[usp_WriteToFile] @Log_command, @PSFile;
				fetch next from C
				into @LocalDir, @NetDir, @DBName, @Kind
			end
			close C;
			deallocate C;
			--2. Запуск скрипта PowerShell из файла
			set @CMD = 'powershell '+@PSFile;
			EXEC @rc=xp_cmdshell @CMD , no_output
			if @rc=1
			BEGIN
				set @ErrMsg=N'Ошибка при запуске PowerShell-скрипта из файла %temp%\'+@PSFile;
				RAISERROR(@ErrMsg,11,1) WITH LOG
			END;
			else
				PRINT N'Команда копирования файлов бэкапов успешно выполнена!';
		END;
	end
GO
PRINT N'Creating Procedure [backups].[usp_RunBack]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 23.12.2013 (1.0)
	-- Description: Эта процедура выполняет конкретный бэкап для конкретной базы данных.
					Тип бэкапа и все настройки хранятся в таблицу sputnik.backups.BackConf.
					После выполнения команды BACKUP происходит копирование бэкапа на удалённый ресурс (если он задан и отличается от локального).
					Эта процедура создана на основе процедур usp_PegLogBack и usp_PegFullBack и полностью заменяет обе эти процедуры, 
					добавляя расширенный функционал!
	-- Update:		25.12.2013 (1.1)
					Добавлен алгоритм определения Расширения файла в зависимости от наличия NetDir. Если NetDir не задан, или он равен LocalDir,
					то расширения файла сразу будет BAK , без переименования файла в конце.
					25.12.2013 (1.2)
					Добавлен алгоритм для отдельного резервного копирования Недельных бэкапов. Определяется текущий день недели и осуществляется
					поиск настройки из таблицы BackConfWeekly, если ничего не найдено, то поиск будет осуществляться в таблице BackConf. Также
					добавлена проверка - если из таблиц BackConf и BackConfWeekly не получена никакая информация - ничего не делать!
					26.12.2013 (1.3)
					Добавлен алгоритм для Дифференциального бэкапа!
					30.12.2013 (1.35)
					Исправлен алгоритм определения дня недели!
					09.01.2014 (1.36)
					Для переменной, которая хранит путь к файлу бэкапа увеличен размер строки с 200 до 900.
					16.01.2014 (1.4)
					Добавлен новые параметры:
							@NoCopy - если установлен в 1, тогда после создания бэкапа, копирование файлов бэкапа НЕ происходит.
						По умолчанию 0, т.е. копирование происходит после создания бэкапа.
							@ForceCopy - если установлен в 1, тогда Создание бэкапа НЕ происходит, а происходит принудительное копирование файлов бэкапа
						на сетевой ресурс. По умолчанию 0, т.е. сначала происходит создание Бэкапа, а потом уже (параметр @NoCopy устанавливается в 0) копирование
						файлов бэкапа на сетевой ресурс.
					Также увеличены размеры всех текстовых переменных (nvarchar).
					06.02.2014 (1.5)
						Добавлен новый алгоритм. Теперь если тип бэкапа задан Full, то осуществляется бэкап Full/Diff в зависимости от настроек в таблицах BackConfWeekly и
							BackConf
					17.02.2014 (1.6)
						Оптимизирован алгоритм получения информации дня недели. Теперь для этого создана новая функция uf_GetWeekDay.

					17.03.2014 (1.65)
						Добавлен алгоритм создания Бэкапов 1 раз в месяц. Для этого в таблицу BackConfWeekly добавлен новый столбец ДеньМесяца!

					31.07.2014 (1.7)
						Новый параметр @OnlyFull. Если этот параметр задан, то будет принудительно выполнена Полная копия (без учёта дифф!).
						Соответственно изменен алгоритм получения настроек (добавлено получение настроек без учета дня месяца и дня недели).

					07.08.2014 (1.72) Новый параметр @NoStats, если задан тогда в процессе резервного копирования не будет выводится кол-во выполненных процентов
					( это оператор STATS в команде BACKUP).

					06.10.2014 (1.73) Доработан алгоритм переименования расширения файлов бэкапов в самом конце. Теперь если задан параметр
						принудительного копирования файлов (без выполнения бэкапа) - @ForceCopy, то переименование расширения тоже выполняется принудительно.

					11.11.2014 (1.80) Теперь эта процедура выполняет только бэкапы. 
					Весь алгоритм копирования и переименования бэкапов вынесен в новый отдельный модуль - usp_CopyBack.Поэтому отсюда удален весь старый код, касающийся этого процесса. 
					Также алгоритм сжатие файлов журналов транзакций теперь закомментирован (т.к. в программе Хьюстон теперь работает механизм автоматического сжатия файлов БД).

					13.11.2014 (1.81) Восстановлен параметр @ForceCopy! При этом логика изменена: если задан этот параметр, тогда после выполнения бэкапа в конце сразу происходит 
					копирование этого бэкапа. Такое поведение нужно только при запуске модуля [usp_RunBack] из [usp_GC2]! В остальных случаях копирование бэкапов
					производится из [usp_StartBack] сразу для всех сделанных бэкапов!

					03.12.2014 (1.82) В команды полного и дифф. бэкапов добавлены опции BUFFERCOUNT и MAXTRANSFERSIZE с более оптимальными значениями для больших БД.
				
					29.12.2014 (1.83) Исправлена небольшая ошибка - в команду создания каталогов (если их нет) добавлены кавычки (защита от пробелов в имени).

					22.06.2015 (1.85) Добавлен учёт редакции экземпляра. Если Express Edition, тогда сжатие бэкапа не выполняется (слово COMPRESSION отсутствует)!

					15.08.2015 (2.00) Реализована возможность резервного копирования по Файловым Группам!

					31.05.2016 (2.01) Оператор IIF заменён на CASE для нормальной работы на SQL Server версий  < 2012!
	-- ============================================= */
	create PROCEDURE [backups].[usp_RunBack] 
		@DBNAME_in nvarchar(300)
		,@TypeBack varchar(4)
		,@OnlyFull bit = 0 
		,@NoStats bit = 0
		,@ForceCopy bit = 0
	AS
	BEGIN
		set nocount on;
		DECLARE @DBName NVARCHAR(300), @LocalDir NVARCHAR(500), @NetDir NVARCHAR(500), @LocalDays int, @NetDays INT, @tint int, @getdate datetime, @Extension nvarchar (20), @Edition nvarchar(100), @Compression nvarchar(50), @FG nvarchar(1000)=NULL, @str_FG nvarchar(2000)='', @str_FG_fname nvarchar(1000)='';
		DECLARE @tstr NVARCHAR(1100), @tcmd NVARCHAR(400),@rc int,@backup_file nvarchar(500), @WeekDay tinyint, @DynTypeBack varchar(4), @MonthDay tinyint, @StrStats NVARCHAR(20)='';
		SET @Edition=CAST(SERVERPROPERTY('Edition') as nvarchar(100));
		SELECT @Compression=CASE WHEN CHARINDEX('Express',@Edition)>0 THEN '' ELSE ', COMPRESSION' END;	
		--SELECT @Edition, @Compression;
		SET DATEFORMAT YMD;
		set @getdate=GETDATE();
		IF @NoStats=0
			SET @StrStats=N',STATS=25';
		--Определяем текущий день недели! Сначала ищем настройку в таблице BackConfWeekly для недельных бэкапов по текущему дню недели.
		--Если ничего нет, тогда ищем настройку в обычной таблице BackConf.
		select @WeekDay=sputnik.info.uf_GetWeekDay(@getdate);
		select @MonthDay=DATEPART ( DAY , @getdate );
		--update: теперь, если задан Тип Full. То проверяем и Full и Diff.
		--	Алгоритм такой: 1. ищем Full в Weekly. 2. Ищем Diff в Weekly. 3.Ищем Full в Daily 4. Ищем Diff в Daily	

		SELECT TOP 1 @DBName=DBName, @LocalDir=LocalDir, @NetDir=NetDir, @LocalDays=LocalDays, @NetDays=NetDays, @DynTypeBack=Kind, @FG=FG 
		FROM sputnik.backups.BackConfWeekly
		WHERE Kind=@TypeBack and DBName=@DBNAME_in and MonthDay=@MonthDay;
		if @DBName is null and @TypeBack='Full' and @OnlyFull=0
			SELECT TOP 1 @DBName=DBName, @LocalDir=LocalDir, @NetDir=NetDir, @LocalDays=LocalDays, @NetDays=NetDays, @DynTypeBack=Kind, @FG=FG  
			FROM sputnik.backups.BackConfWeekly
			WHERE Kind='Diff' and DBName=@DBNAME_in and MonthDay=@MonthDay;

		if @DBName is null
		begin
			SELECT TOP 1 @DBName=DBName, @LocalDir=LocalDir, @NetDir=NetDir, @LocalDays=LocalDays, @NetDays=NetDays, @DynTypeBack=Kind, @FG=FG 
			FROM sputnik.backups.BackConfWeekly
			WHERE Kind=@TypeBack and DBName=@DBNAME_in and WeekDay=@WeekDay;
			if @DBName is null and @TypeBack='Full' and @OnlyFull=0
				SELECT TOP 1 @DBName=DBName, @LocalDir=LocalDir, @NetDir=NetDir, @LocalDays=LocalDays, @NetDays=NetDays, @DynTypeBack=Kind, @FG=FG  
				FROM sputnik.backups.BackConfWeekly
				WHERE Kind='Diff' and DBName=@DBNAME_in and WeekDay=@WeekDay;
		end
		if @DBName is null
		begin
			SELECT TOP 1 @DBName=DBName, @LocalDir=LocalDir, @NetDir=NetDir, @LocalDays=LocalDays, @NetDays=NetDays, @DynTypeBack=Kind, @FG=FG 
			FROM sputnik.backups.BackConf 
			WHERE Kind=@TypeBack and DBName=@DBNAME_in
			if @DBName is null and @TypeBack='Full' and @OnlyFull=0
				SELECT TOP 1 @DBName=DBName, @LocalDir=LocalDir, @NetDir=NetDir, @LocalDays=LocalDays, @NetDays=NetDays, @DynTypeBack=Kind, @FG=FG  
				FROM sputnik.backups.BackConf
				WHERE Kind='Diff' and DBName=@DBNAME_in;
		end
		--Новый алгоритм (только для полных бэкапов!): если использован параметр @OnlyFull и настройки бэкапов не были найдены
		--тогда нужно найти подходящие настройки для Full из таблицы BackConfWeekly без учета дня месяца и дня недели!
		if @DBName is null and @OnlyFull=1 and @TypeBack='Full'
		begin
			DECLARE @T TABLE (DBName NVARCHAR(300), LocalDir NVARCHAR(500), NetDir NVARCHAR(500), LocalDays INT, NetDays INT, Kind VARCHAR(4), Ord tinyint);
			INSERT INTO @T
			SELECT TOP 1 DBName, LocalDir, NetDir, LocalDays, NetDays, Kind, 1 AS Ord
			FROM sputnik.backups.BackConfWeekly
			WHERE Kind='Full' and DBName=@DBNAME_in and MonthDay BETWEEN 1 AND 31
			UNION ALL
			SELECT TOP 1 DBName, LocalDir, NetDir, LocalDays, NetDays, Kind, 2 AS Ord
			FROM sputnik.backups.BackConfWeekly
			WHERE Kind='Full' and DBName=@DBNAME_in and WeekDay BETWEEN 1 AND 7;
			SELECT @DBName=DBName, @LocalDir=LocalDir, @NetDir=NetDir, @LocalDays=LocalDays, @NetDays=NetDays, @DynTypeBack=Kind
			FROM @T
			WHERE Ord=(SELECT MIN(Ord) FROM @T);
		end		

		if @DBName is not null
		begin
			-- если каталогов нет, создать их 
			SET @tcmd='md "' + @LocalDir+'"';
			EXEC xp_cmdshell @tcmd, no_output
			IF @LocalDir<>@NetDir and @NetDir is not null and @NetDir<>''
			begin
				SET @tcmd='md "' + @NetDir+'"';
				EXEC xp_cmdshell @tcmd, no_output
				--Установка Расширения файла @Extension в only - будем копировать в NetDir и потом менять на BAK
				set @Extension = '.ONLY';
			end
			else
				--Установка Расширения файла @Extension в BAK - копировать файл бэкапа НЕ НУЖНО!
				set @Extension = '.BAK';
		
			IF @FG IS NOT NULL AND @FG<>'' AND @DynTypeBack IN ('Full', 'Diff')
			BEGIN
				--Реализуем бэкапы по файловым группам!!
				--Сначала определяем имена ФГ которые попадают в текущий бэкап
				--Затем формируем строку для команды BACKUP где будут перечислены ФГ
				--Также формируем строку для вставки в имя файла, где будут указаны ФГ.
				declare @tsql_fg nvarchar(2000), @c_fg_cur nvarchar(300);
				if OBJECT_ID('tempdb.dbo.#t_fg') is not null
					drop table #t_fg;
				create table #t_fg (fg nvarchar(300));
				set @tsql_fg='USE ['+@DBName+'];
					insert into #t_fg (fg)			 
					select name as fg
					from sys.filegroups
					where charindex(QUOTENAME(name),'''+@FG+''')>0;'
				EXEC (@tsql_fg);
			
				declare C_fg cursor for
				select distinct fg
				from #t_fg;
				open C_fg;
				fetch next from C_fg into @c_fg_cur;
				while @@FETCH_STATUS=0
				begin
					if LEN(@str_FG)>0
						SET @str_FG=@str_FG+',';
					if LEN(@str_FG_fname)=0
						SET @str_FG_fname='FG_';
					SET @str_FG=@str_FG+' FILEGROUP = '''+@c_fg_cur+''' ';
					SET @str_FG_fname=@str_FG_fname+@c_fg_cur+'_';
					fetch next from C_fg into @c_fg_cur;
				end
				close C_fg;
				deallocate C_fg; 	  
			END
		
			set @backup_file=@DBName+'_'+@DynTypeBack+'_'+@str_FG_fname+REPLACE(REPLACE(SUBSTRING(CONVERT(NVARCHAR(max),@getdate,126),1,19),'T','_'),':','.');
			SET @tstr=@LocalDir+@backup_file+@Extension;

			if @DynTypeBack='Full'
				EXEC(N'BACKUP DATABASE ['+@DBName+'] '+@str_FG+' TO  DISK = N'''+@tstr+''' WITH FORMAT, INIT, SKIP, NOREWIND, NOUNLOAD'+@Compression+@StrStats+', CHECKSUM, BUFFERCOUNT=64, MAXTRANSFERSIZE=2097152');
			else if @DynTypeBack='Diff'
				EXEC(N'BACKUP DATABASE ['+@DBName+'] '+@str_FG+' TO  DISK = N'''+@tstr+''' WITH DIFFERENTIAL,FORMAT, INIT, SKIP, NOREWIND, NOUNLOAD'+@Compression+@StrStats+', CHECKSUM, BUFFERCOUNT=64, MAXTRANSFERSIZE=2097152');
			else if @DynTypeBack='Log'
			begin
				EXEC(N'BACKUP LOG ['+@DBName+'] TO  DISK = N'''+@tstr+''' WITH NOFORMAT, INIT, SKIP, NOREWIND, NOUNLOAD'+@Compression+@StrStats+', CHECKSUM');
				/*	Теперь не нужно здесь сжимать файлы ЖТ! Работает механизм авто-сжатия файлов БД из программы Хьюстон!
					Закомментировано. Оставлено на всякий случай.
					--if datepart(hh,@getdate)=23		--выполнить сжатие файлов LOG с 23 до 00.
					--	begin try
					--		exec db_maintenance.usp_ShrinkLogFile @DBName
					--	end try
					--	begin catch
					--		RAISERROR('Ошибка при попытке сжать (shrinkfile) файлы журналов транзакций через процедуру usp_ShrinkLogs !',11,1) WITH LOG
					--	end catch
				*/
			end
			begin try
				exec backups.usp_WriteBackuphistory @DBName, @FG, @DynTypeBack,@backup_file,@tstr
			end try
			begin catch
				RAISERROR('Ошибка при записи в таблицу История резервных копий через процедуру usp_WriteBackuphistory !',11,1) WITH LOG
			end catch

			--Если задан параметр @ForceCopy то нужно сразу же произвести КОПИРОВАНИЕ сделанного бэкапа через новый модуль!
			IF @ForceCopy=1
				exec backups.usp_CopyBack @DBFilter=@DBName,@type=@DynTypeBack,@DateStart=@getdate;			
		end
	END
GO
PRINT N'Creating Procedure [adt].[usp_eventnots_processor]...';


GO
/* =============================================
-- Author:		Андрей Иванов (sqland1c)
-- Create date: 17.04.2018 (1.000)
-- Description: Эта процедура используется как процедура-обработчик для очереди event_notification_q!
				Обрабатываются нужные события event_notifications для реализации различного аудита!

-- Update:		25.05.2018 (1.020)
				Добавлена проверка перед отправкой уведомлений по почте - если запись о такой же БД
				уже есть в таблице аудита, значит не будем отправлять уведомление.

				14.11.2018 (1.030)
				Теперь уведомление по почте происходят при событии drop database.
				
-- ============================================= */
create procedure [adt].[usp_eventnots_processor]
as
	set nocount on;
	declare @DlgHandle UNIQUEIDENTIFIER, @Msg VARBINARY(MAX), @MsgType sysname, @StrErr NVARCHAR(3000), @Msgxml XML;
	declare @tt datetime2(2), @event_type nvarchar(128), @db nvarchar(2000), @login varchar(128), @spid smallint, @sqltext nvarchar(max), @textdata nvarchar(2000), @host nvarchar(128)=null, @program nvarchar(128)=null;
	while (1=1)
	begin
		WAITFOR (
			RECEIVE TOP(1)
				@DlgHandle = [conversation_handle],
				@MsgType = message_type_name
			,	@Msg = message_body                    
			FROM	event_notification_q                 
		), TIMEOUT 1000
		IF (@@ROWCOUNT = 0)
		BEGIN
			--IF EXISTS(SELECT conversation_id FROM sys.conversation_endpoints WHERE conversation_handle=@DlgHandle AND state<>'CD')
			--	END CONVERSATION @DlgHandle;
			BREAK;
		END
		if (@MsgType='http://schemas.microsoft.com/SQL/Notifications/EventNotification')
		begin
			begin try
				set @Msgxml=cast(@Msg as XML);
				select 
					@tt=@Msgxml.value('(/EVENT_INSTANCE/PostTime)[1]', 'datetime2(2)'),
					@event_type=@Msgxml.value('(/EVENT_INSTANCE/EventType)[1]', 'nvarchar(128)'),
					@db=@Msgxml.value('(/EVENT_INSTANCE/DatabaseName)[1]', 'nvarchar(2000)'),
					@login=@Msgxml.value('(/EVENT_INSTANCE/LoginName)[1]', 'nvarchar(128)'),
					@spid=@Msgxml.value('(/EVENT_INSTANCE/SPID)[1]', 'smallint');
				select
					@sqltext=CASE WHEN @event_type in ('CREATE_DATABASE', 'ALTER_DATABASE', 'DROP_DATABASE') then @Msgxml.value('(/EVENT_INSTANCE/TSQLCommand/CommandText)[1]','nvarchar(max)') else @Msgxml.value('(/EVENT_INSTANCE/TextData)[1]','nvarchar(max)') END,
					@textdata=CASE WHEN @event_type in ('CREATE_DATABASE', 'ALTER_DATABASE', 'DROP_DATABASE') then @Msgxml.value('(/EVENT_INSTANCE/TextData)[1]', 'nvarchar(2000)') WHEN @event_type='AUDIT_BACKUP_RESTORE_EVENT' THEN CASE WHEN @Msgxml.value('(/EVENT_INSTANCE/Success)[1]','smallint') <> 1 THEN 'not completed' ELSE NULL END END ;
				if @event_type in ('CREATE_DATABASE', 'ALTER_DATABASE', 'DROP_DATABASE')
				begin
					if datediff(minute,@tt,sysdatetime())<=15
					begin
						select @host=[host_name], @program=[program_name] from sys.dm_exec_sessions where session_id=@spid and login_name=@login and login_time<=@tt;
					end
					else
						print('Невозможно определить host и program: прошло уже более 15 минут!');
				end
				else if @event_type='AUDIT_BACKUP_RESTORE_EVENT'
				begin
					select @host=@Msgxml.value('(/EVENT_INSTANCE/HostName)[1]', 'nvarchar(128)'),
						@program=@Msgxml.value('(/EVENT_INSTANCE/ApplicationName)[1]', 'nvarchar(128)')						
				end
				
				if (@event_type<>'AUDIT_BACKUP_RESTORE_EVENT' or @sqltext like 'restore%database%')
				begin
					declare @pr_event nvarchar(128);
					select @pr_event = CASE WHEN @event_type='AUDIT_BACKUP_RESTORE_EVENT' then 'restore_database' else @event_type end;
					print('event: '+@pr_event+'. database ['+@db+']. login: '+coalesce(@login,'')+' ; host: '+coalesce(@host,'')+' ; program: '+coalesce(@program,'')+' ; spid: '+coalesce(cast(@spid as varchar(10)),''));
				end

				--Проверка существования такой же БД: если есть записи в аудите, значит эта БД уже была и НЕ будем отправлять уведомление!
				declare @last_tt datetime2(2); 
				SELECT @last_tt=max(tt)
				FROM [sputnik].[adt].[instance_hs]
				WHERE tt between dateadd(hour,-24,@tt) and @tt 
					and db=@db;

				insert into sputnik.adt.instance_hs (tt,event_type,db,spid,[login],[host],program,sqltext,textdata)
				values(@tt,@event_type,@db,@spid,@login,@host,@program,@sqltext,@textdata);

				if (@event_type='CREATE_DATABASE' or (@event_type='AUDIT_BACKUP_RESTORE_EVENT' and @sqltext like 'restore%database%')) and @last_tt is null
					exec [sputnik].[adt].[usp_mail_eventdb] @dbname=@db, @tt=@tt, @login=@login, @hostname=@host, @program=@program, @sqlcommand=@sqltext;

				if (@event_type='DROP_DATABASE')
					exec [sputnik].[adt].[usp_mail_eventdb] @dbname=@db, @tt=@tt, @login=@login, @hostname=@host, @program=@program, @sqlcommand=@sqltext, @dropdb=1;

				set @host=null;set @program=null;
			end try
			begin catch
				SET @StrErr=N'Ошибка при обработке очереди event_notification_q в потоке [adt].[usp_eventnots_processor]. Имя БД: ['+@db+']; Тип события: ['+@event_type+'], время события(tt): ['+convert(varchar(30),@tt,120)+']. Текст ошибки: '+ERROR_MESSAGE();
				--В этом случае не будем заканчивать Диалог принудительно, чтобы другие бэкапы были выполнены до конца!
				--Просто пишем ошибку с подробностями в журнал SQL Server (через print) и заканчиваем выполнения (break):
				PRINT(@StrErr);
				BREAK;
				--END CONVERSATION @DlgHandle WITH ERROR = 10 DESCRIPTION=@StrErr;
			end catch
		end
		----Если в сообщении КонецДиалога или Ошибка, тогда закрыть диалог!
		--ELSE IF @MsgType=N'http://schemas.microsoft.com/SQL/ServiceBroker/EndDialog'
		--	END CONVERSATION @DlgHandle;
		--ELSE IF @MsgType=N'http://schemas.microsoft.com/SQL/ServiceBroker/Error'
		--	END CONVERSATION @DlgHandle;
	end
GO
PRINT N'Creating Procedure [backups].[usp_StartBackup]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 10.12.2013 (1.0)
	-- Description: Запуск резервного копирования для баз, указанных в таблицах BackConf и BackConfWeekly
					В качестве параметров можно указать имя конкретной базы данных!
					А также Тип бэкапа!
	-- Update:		26.12.2013 (1.1)
					Теперь Выборка баз для резервного копирования осуществляется сразу из двух таблиц BackConf и BackConfWeekly.
					Также переделан запрос для получения имён баз для резервного копирования!
					Теперь базы проверяются на существование (они могли быть удалены) и что состояние этих баз ONLINE
					16.01.2014 (1.2)
					Теперь для всех бэкапов новый алгоритм: сначала создаются все бэкапы локально, а затем уже происходит копирование всех файлов на сетевой ресурс.
					Также тип курсора изменён на scroll, чтобы можно было переходить по курсору во все стороны (и получить первую запись).
					18.01.2014 (1.22)
					Добавлены новын параметры
						@OnlyCopy - если будет 1, то для всех баз будет запушен скрипт копирования всех файлов бэкапов на сетевой ресурс.
						При этом создание самого бэкапа не будет. По умолчанию 0.
					17.03.2014 (1.25)
					При выборке Имя базы для создания бэкапов добавлен параметр DISTINCT.
					16.04.2014 (1.3)
					Добавлена поддержка Резервного копирования в Always ON! В зависимости от настроек AlwaysOn проверяется нужно ли выполнять
					Бэкап с текущей реплики. Сработает только для SQL Server 2012 и старше.
					13.10.2014 (1.33)
					Добавлен новый параметр @NoStats - если задан 1, то при выполнении бэкапа не будет выводиться дополнительная информация о 
					выполненном %. Также изменен алгоритм запуска процедуры usp_RunBack - при указании параметров теперь используется имена параметров
					(ранее параметры передавались без имени - по позиции). 
					Также для параметра @type задано значение по умолчанию - Full(полный бэкап!)
					11.11.2014 (1.40)
					Полностью изменен алгоритм копирования файлов бэкапов - теперь это выполняется через PowerShell в новом отдельном модуле usp_CopyBack.
					Причем копироваться будут только бэкапы сделанные только что! Чтобы копировать все бэкапы нужно задать параметр @OnlyCopy!
					21.11.2014 (1.41)
					Для бэкапов ЛОГОВ при копировании бэкапов изменен отбор по дате - не с текущего момента, а за последние сутки! 
					18.01.2015 (1.50)
					Добавлена возможность обработки бэкапов в многопоточном режиме (через Service Broker).
					Работа в многопоточном режиме определяется в столбце pp в таблице backups.config
					18.01.2015 (1.51)
					Многопоточный режим бэкапов теперь работает через новую очередь - [ProcessorQueueHard].
					Это очередь создана специально для тяжелых операций. Кол-во потоков - максимум 2.
					13.07.2015 (1.52)
					Резерное копирование в AlwaysOn с вторичных реплик - пока добавлена поддержка только Log бэкапов.
					31.12.2015 (1.55) 
					Добавлена проверка для режима pp! Добавляем в очередь сообщение о бэкапе, только если его ещё нет в Очереди!
					01.04.2016 (1.56) 
					Оператор IIF заменён на CASE для нормальной работы на SQL Server версий  < 2012!
					25.08.2016 (1.57) 
					Добавлена возможность бэкапить системную базу model.
					25.10.2016 (1.580)
					Добавлен новый параметр @ForceFULL - принудительно выполнить полный бэкап (даже если по расписанию должен быть DIFF).
					Действует, когда в параметре @type задан 'Full'.
					02.11.2016 (1.585)
					Добавлена проверка для Log-бэкапов: пропускать базу, если для неё установлен recovery_model=SIMPLE.

					05.06.2017 (1.590)
					Добавлены новые параметры @DBList и @DBList_delimeter: первый параметр определяет список баз
					в виде строки, разделённых Разделителем @DBList_delimeter (по умолчанию это Запятая).
					Теперь можно сделать бэкапы по списку баз. Старый параметр @DBFilter - отбор по конкретной базе.

					29.10.2018 (1.591)
					Когда определён только DIFF (без FULL): при выборке из vGetAllBackConf добавлено условие, чтобы учитывать
					такой бэкап.

					29.10.2020 (1.592)
					Резерное копирование в AlwaysOn с вторичных реплик - добавлена поддержка для Full и Diff бэкапов.

					23.02.2021 (1.593)
					Fixed check: is it possible to make a backup on this server (AlwaysOn)
	-- ============================================= */
	CREATE proc [backups].[usp_StartBackup] 
		@type varchar(4) = 'Full' --тип бэкапа Log или Full или Diff.
		,@DBFilter nvarchar(400) = null
		,@OnlyCopy bit = 0
		,@NoStats bit = 1
		,@pp bit = 0 --определяет, что этот модуль уже запущен в многопоточном режиме (через вызов из Service Broker).
		,@ForceFULL bit = 0 --принудительно сделать ПолныйБэкап, даже если сейчас по расписанию должен быть DIFF.
		,@DBList NVARCHAR(MAX) = NULL
		,@DBList_delimeter NVARCHAR(10)=','
	as
	begin
		set nocount on;
		declare @dbname nvarchar(400), @DateStart datetime=null, @pp_config bit=0;
		DECLARE @BackupHere BIT, @DlgHandle UNIQUEIDENTIFIER, @MsgRequest XML, @count_q_pp int;
		declare @sql NVARCHAR(MAX), @dblist_fmt NVARCHAR(MAX);
		IF @DBList > N'' AND @DBList IS NOT NULL
		BEGIN
			--11.04.17 Новый алгоритм обработки @DBList (список БД в виде строки);
			set @dblist_fmt = 'N'''+REPLACE(@DBList, @DBList_delimeter,''' , N''')+'''';
			set @dblist_fmt = REPLACE(@dblist_fmt,'N'''' , ','');
			set @dblist_fmt = REPLACE(@dblist_fmt,' , N''''','');
		END
		CREATE TABLE #x(DB NVARCHAR(600));
		SET @sql = N'SELECT name FROM sys.databases WHERE 1=1'
		+ CASE WHEN @dblist_fmt IS NOT NULL THEN ' AND name IN (' + @dblist_fmt + ')'
			   ELSE '' 
		  END;
		INSERT #x EXEC sp_executesql @sql;


		--Здесь Определяем отбор для копирования бэкапов по дате - только бэкапы сделанные только что!
		--А для бэкапов Логов - в течении последних суток!
		--или вообще все бэкапы (если задан параметр @OnlyCopy)
		IF @OnlyCopy=0
		BEGIN
			IF @type='Log'
				set @DateStart=DATEADD(day,-1,GETDATE());
			ELSE
				set @DateStart=GETDATE();				
		END;

		IF @type<>'Full'
			set @ForceFULL=0;

		--Определяем Базы для резервного копирования!
		--Проверяем что эти базы существуют, и их состояние ONLINE!
		--Если делаем Log бэкапы, то проверяем что модель восстановления<>simple
		declare BACKUPS scroll cursor
		for 
			select Conf.dbname
			from
			(
				select distinct DBName
				from sputnik.info.vGetAllBackConf
				where
					(@DBFilter is null or DBName=@DBFilter)
					and (@type is null or (Kind=@type) or (Kind in ('Full','Diff') and @type='Full'))
			) Conf
			inner join
			(
				select name as dbname
				from sys.databases
				where 
				state_desc='ONLINE' and is_in_standby=0 and is_read_only=0
				and name <> 'tempdb'
				and (@type<>'Log' OR recovery_model_desc<>'SIMPLE')
			) DBFact
			inner join #x X
				ON DBFact.dbname=X.DB
			on Conf.dbname=DBFact.dbname
	
		--Определяем настройки многопоточности!
		if @pp=0
		begin
			select @pp_config=[pp] 
			from backups.Config 
			where [pp] is not null and DateConfig=(select max(DateConfig) from backups.Config where [pp] is not null);
			if @pp_config=1
				--Открываем новый диалог для Backups!
				BEGIN DIALOG CONVERSATION @DlgHandle
					FROM SERVICE [pp_Commander]
					TO SERVICE N'pp_ProcessorHard'
					ON CONTRACT [pp_back_Contract]
					WITH ENCRYPTION = OFF;
		end;

		--Часть 1. Сначала выполним всех бэкапы локально (для всех баз!), без копирования файлов бэкапов
		open BACKUPS
		if @OnlyCopy=0
		begin
			fetch next from BACKUPS
				into @dbname
			while @@FETCH_STATUS=0
			begin
				--check: is it possible to make a backup on this server
				IF CAST (LEFT (CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(2)),2) AS SMALLINT) >= 11
					SET @BackupHere=sys.fn_hadr_backup_is_preferred_replica(@dbname);
				ELSE
					SET @BackupHere=1;
				IF @BackupHere=1
				BEGIN
					--Если многопоточность настроена, тогда добавляем все БД и типы бэкапов в очередь 
					--а всё остальное сделает Service Broker.
					if @pp=0 and @pp_config=1
					begin
						--формируем сообщение в очередь в виде XML.
						set @MsgRequest=cast('<backups>
												<db>'+@dbname+'</db>
												<type>'+@type+'</type>
											  </backups>' as xml);
					
						--31.12.2015 Добавлена проверка: существует ли УЖЕ в очереди наше сообщение!
						--Добавляем в очередь такое сообщение, если его ещё нет в Очереди!
						;WITH XMLNAMESPACES
						('http://pecom.ru/pegasExchange/types/' as ns),
						Q AS 
						(
							select CAST(message_body as XML) as msg_xml
							from pp.ProcessorQueueHard
							where message_type_name='pp_back_Request'
						)
						select @count_q_pp=count(*)
						from Q
						where msg_xml.exist(N'(/backups/db/text()[.=sql:variable("@dbname")])')=1
							AND msg_xml.exist(N'(/backups/type/text()[.=sql:variable("@type")])')=1;
						IF @count_q_pp=0 OR @count_q_pp IS NULL
						BEGIN
							--отправляем сообщение в очередь!
							SEND ON CONVERSATION @DlgHandle
								MESSAGE TYPE [pp_back_Request]
								(@MsgRequest);
						END
					end
					else
						--Запуск команды Бэкап теперь всё через одну новую процедуру backups.usp_RunBack!
						exec backups.usp_RunBack @DBName_IN=@dbname, @TypeBack=@type, @NoStats=@NoStats, @OnlyFull=@ForceFULL;
				END

				fetch next from BACKUPS
					into @dbname
			end
		end
		CLOSE BACKUPS;
		DEALLOCATE BACKUPS;

		if @pp=1 or @pp_config=0
		begin
			--Часть 2. Теперь выполним копирование всех файлов бэкапов, если это нужно
			--через новый отдельный модуль usp_CopyBack

			--check: is it possible to make a backup on this server
			IF CAST (LEFT (CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(2)),2) AS SMALLINT) >= 11
				SET @BackupHere=sys.fn_hadr_backup_is_preferred_replica(@dbname);
			ELSE
				SET @BackupHere=1;
			IF @BackupHere=1
			BEGIN
				--Запускаем новый модуль копирования файлов бэкапов!
				exec backups.usp_CopyBack @DBFilter=@DBFilter,@type=@type, @DateStart=@DateStart;
			END;
		end;
	end
GO
PRINT N'Creating Procedure [lse].[usp_RollForwardRecovery]...';


GO

	/* =============================================
	-- Author:		Андрей Иванов (sqland1c)
	-- Create date: 04.08.2014 (1.0)
	-- Description: Эта процедура используется как часть модуля lse - Log Shipping Easy.
					Сначала открываются все настройки для LSE и производится вызов ХП usp_RunRolling для наката бэкапов Логов по каждой БД.
					Если же целевая БД ещё не проинициализирована (или был задан режим переинициализации), тогда для неё будет вызов ХП для инициализации копии - usp_GC2.
					Возможен отбор по конкретной целевой БД, для этого должен быть задан параметр @DBNameTarget.

	-- Update:		07.08.2014 (1.1) реализован алгоритм, которые позволяет запускать LSE в многопоточном режиме через модуль pp.
					За это отвечает новый параметр @pp.
					18.08.2014 (1.2) реализована дополнительная проверка при работе в многопоточном режиме для минимизации
					нагрузки на сервер: В очередь сообщения будут добавлены только в том случае, eсли процессорами usp_ExecProcessor
					сейчас ничего не выполняется + инициализация производится только по одной БД! 
					18.03.2015 (1.23) Добавлена новая переменная @StandBy_File - для поддержки режима STANDBY (read-only) для восстанавливаемой БД.
					Это полный путь к файлу отката standby. Соответственно в таблице sputnik.lse.TargetConfig должен быть новый столбец StandBy_File.
					30.03.2016 (1.30) Доработка процедуры: Добавлены 2 проверки перед помещением в очередь Service Broker.
					А также добавлен новый параметр @execute - для того чтобы чётко разделить запуск из Joba (помещения в очередь)
					и запуски из обработчика очереди Service Broker (здесь как раз @execute=1).
					25.07.2016 (1.31) Доработка процедуры: добавлен учёт новой возможности - расположение лог-файлов 
					на отдельным диске(CatalogLogFiles).
					09.09.2016 (1.32) Доработка процедуры: Исправлена небольшая ошибка при определении курсора не хватало 1го нового столбца.
					13.11.2017 (1.330) Доработка процедуры: добавлен алгоритм обработки нового параметра из настроек - UseFreshDiffBack. Действует для тех баз, которые нужно инициализировать!
	-- ============================================= */
	CREATE PROCEDURE [lse].[usp_RollForwardRecovery]  
		@DBName nvarchar(300)=NULL,
		@pp bit=0,
		@execute bit=0
	AS
		SET NOCOUNT ON;
		if @pp=1 and @execute=0--and @DBName is null
		begin

			declare @DlgHandle UNIQUEIDENTIFIER, @MsgRequest XML;
			declare @tt table (db nvarchar(300));
			declare @count_q_pp int, @dbname_cur nvarchar(300);
			--Накат журналов транзакций для всех БД
			insert into @tt
			select distinct DBNameTarget as db
			from sputnik.lse.TargetConfig
			where [suspend]=0 AND [InitDate] is not null
				AND (DBNameTarget=@DBName OR @DBName IS NULL);

			--Производим дополнительную проверку, чтобы минимально нагружать сервер:
			--Инициализацию производим, только если процессорами usp_ExecProcessor сейчас ничего не исполняется
			IF NOT EXISTS(select queue_id from sys.dm_broker_activated_tasks where procedure_name='[pp].[usp_ExecProcessor]')
			BEGIN			
				--А Инициализация производится только по одной БД (опять же для минимальной нагрузки на сервер)!
				insert into @tt
				select TOP 1 DBNameTarget as db
				from sputnik.lse.TargetConfig
				where [suspend]=0 AND [InitDate] is null
					AND (DBNameTarget=@DBName OR @DBName IS NULL);
			END

			if exists(select top 1 db from @tt)
			begin
				declare LSE cursor for
				select cast('<DB>'+db+'</DB>' as xml) as DB,
					db as DBname
				from @tt;
				--Начинаем диалог для LSE!
				BEGIN DIALOG CONVERSATION @DlgHandle
					FROM SERVICE [pp_Commander]
					TO SERVICE N'pp_Processor'
					ON CONTRACT [pp_lse_Contract]
					WITH ENCRYPTION = OFF;
				open LSE;
				fetch next from LSE into @MsgRequest, @dbname_cur;
				while @@FETCH_STATUS=0
				begin
					--29.03.2016 Добавлена проверка: существует ли УЖЕ в очереди наше сообщение!
					--Добавляем в очередь такое же сообщение, если его ещё нет в Очереди!
					;WITH XMLNAMESPACES
					('http://pecom.ru/pegasExchange/types/' as ns),
					Q AS 
					(
						select CAST(message_body as XML) as msg_xml
						from pp.ProcessorQueue
						where message_type_name='pp_lse_Request'
					)
					select @count_q_pp=count(*)
					from Q
					where msg_xml.exist(N'(/db/text()[.=sql:variable("@dbname_cur")])')=1;

					--30.03.2016 Ещё одна проверка- выполняется ли в данный момент
					--обработчиком Service Broker восстановление в текущей БД
					if OBJECT_ID('tempdb..#broker_tasks') is not null
						DROP TABLE #broker_tasks;
					select 
						br_t.spid, s.login_time, s.status as Session_Status, s.open_transaction_count as Open_tran_cnt, DB_NAME(s.database_id) as DB,
						r.status as command_status, r.command as command_type, r.percent_complete as [%],
						--r.sql_handle, r.statement_start_offset, r.statement_end_offset,
						--sql_text.text as sql_text,
						(SELECT TOP 1 SUBSTRING(sql_text.text,r.statement_start_offset / 2+1 , 
						  ((CASE WHEN r.statement_end_offset = -1 THEN (LEN(CONVERT(nvarchar(max),sql_text.text)) * 2) 
							 ELSE r.statement_end_offset 
							END)  - r.statement_start_offset) / 2+1))  AS sql_statement
					INTO #broker_tasks
					from sys.dm_broker_activated_tasks br_t
					left join sys.dm_exec_sessions s
						on s.session_id = br_t.spid
					left join sys.dm_exec_requests r
						on r.session_id =s.session_id
					CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) AS sql_text
					where 
						br_t.procedure_name='[pp].[usp_ExecProcessor]'
						and r.command LIKE 'RESTORE %'
					--select * from #broker_tasks
					--if not exists(select spid from #broker_tasks where sql_statement like '%^['+'Booh2014'+'^]%' ESCAPE '^')
					--	select 1;
					IF (@count_q_pp=0 OR @count_q_pp IS NULL) 
						AND not exists(select spid from #broker_tasks where sql_statement like '%^['+@dbname_cur+'^]%' ESCAPE '^')
					BEGIN
						--отправляем сообщение в очередь!
						SEND ON CONVERSATION @DlgHandle
							MESSAGE TYPE [pp_lse_Request]
							(@MsgRequest);
					END				
					fetch next from LSE into @MsgRequest, @dbname_cur;
				end	
				close LSE;
				deallocate LSE;
			end
			return 1;
		end
		--Сначала получаем только те БД для наката, которые не приостановлены и для которых выполнена Инициализация.
		declare @ServerSource nvarchar(300), @DBNameSource nvarchar(300), @DBNameTarget nvarchar(300), @FromCopy bit, @BackupID int, @ConfigID smallint, @CatalogFilesDB nvarchar(800), @CatalogLogFiles nvarchar(800), @StandBy_File nvarchar(500), @UseFreshDiffBack bit;
		declare LSE cursor for
		select distinct c.id as ConfigID, c.CatalogFilesDB, c.CatalogLogFiles,
			case when c.InitBackupHS_id<h.MaxBackupHS_id then h.MaxBackupHS_id
				else c.InitBackupHS_id
			end BackupID
		from sputnik.lse.TargetConfig c
		left join (select distinct config_id, max(BackupHS_id) over (partition by config_id) as MaxBackupHS_id from sputnik.lse.HS) h
			on c.id=h.config_id		
		where [Suspend]=0 AND [InitDate] IS NOT NULL AND (DBNameTarget=@DBName OR @DBName IS NULL);
		open LSE;
		fetch next from LSE into @ConfigID, @CatalogFilesDB, @CatalogLogFiles, @BackupID;
		while @@FETCH_STATUS=0
		begin
			exec sputnik.lse.usp_RunRolling @ConfigID=@ConfigID, @BackupID=@BackupID, @MoveFilesTo=@CatalogFilesDB, @MoveLogFilesTo=@CatalogLogFiles, @pp=@pp;
			fetch next from LSE into @ConfigID, @CatalogFilesDB, @CatalogLogFiles, @BackupID;
		end
		close LSE;
		deallocate LSE;
		--Теперь получаем настройки, которые нужно проинициализировать!
		declare LSE cursor for
		select ServerSource, DBNameSource, DBNameTarget, FromCopy, CatalogFilesDB, CatalogLogFiles, StandBy_File, COALESCE(UseFreshDiffBack,0) as UseFreshDiffBack 
		from sputnik.lse.TargetConfig
		where [InitDate] is null AND (DBNameTarget=@DBName OR @DBName IS NULL);
		open LSE;
		fetch next from LSE into @ServerSource, @DBNameSource, @DBNameTarget, @FromCopy, @CatalogFilesDB, @CatalogLogFiles, @StandBy_File, @UseFreshDiffBack;
		while @@FETCH_STATUS=0
		begin
			--сформируем заново путь к файлам БД (если не задан в настройках!)
			if @CatalogFilesDB is NULL and @DBNameSource is not null
			begin
				DECLARE @MaxDrive CHAR(1);
				exec sputnik.info.usp_GetDrives @GetMaxFree=1, @MaxFreeDrive=@MaxDrive OUTPUT;
				SET @CatalogFilesDB=@MaxDrive+':\DATA\lse\'+@DBNameTarget+'\';
				UPDATE sputnik.lse.TargetConfig
				SET CatalogFilesDB=@CatalogFilesDB, CatalogLogFiles=NULL 
				WHERE DBNameTarget=@DBNameTarget;
			end
			exec sputnik.backups.usp_GC2 
				@ServerSource=@ServerSource, @DBNameSource=@DBNameSource, 
				@DBNameTarget=@DBNameTarget, @FromCopy=@FromCopy, @MoveFilesTo=@CatalogFilesDB, @MoveLogFilesTo=@CatalogLogFiles,
				@NoRecovery=1,@RunNewBackIfNeed=1, @FreshBack=@UseFreshDiffBack,@lse=1, @pp=@pp, @StandBy_File=@StandBy_File, @RunNewDiffBackIfNeed=@UseFreshDiffBack;
			fetch next from LSE into @ServerSource, @DBNameSource, @DBNameTarget, @FromCopy, @CatalogFilesDB, @CatalogLogFiles, @StandBy_File, @UseFreshDiffBack;
		end
		close LSE;
		deallocate LSE;
GO
PRINT N'Creating Procedure [pp].[usp_ExecProcessorHard]...';


GO

/* =============================================
-- Author:		Андрей Иванов (sqland1c)
-- Create date: 18.01.2015 (1.0)
-- Description: Эта процедура используется как процедура активации для целевой очереди  ProcessorQueueHard!
				Предназначена для организации многопоточной обработки тяжелых процессов (такие как бэкапы).
				Отличие от процедуры активации usp_ExecProcessor состоит в кол-ве потоков: в usp_ExecProcessorHard максимум 2, а в usp_ExecProcessor 8.
				Для того чтобы как можно меньше нагружать сервер тяжелыми процессами!
-- Update:		
-- ============================================= */
CREATE PROCEDURE [pp].[usp_ExecProcessorHard]
AS
	SET NOCOUNT ON;
	DECLARE @DlgHandle UNIQUEIDENTIFIER, @Msg VARBINARY(MAX), @MsgType sysname, @StrErr NVARCHAR(3000),@RunningBackupCount smallint;
	WHILE (1=1)
	BEGIN
		 DECLARE @DB NVARCHAR(300);

		 WAITFOR
			(	RECEIVE TOP(1)
					@DlgHandle = conversation_handle,
					@MsgType   = message_type_name,
					@Msg	   = message_body
				FROM [pp].ProcessorQueueHard
		), TIMEOUT 1000;		--делаем небольшое ожидание 1 сек. нового сообщения.
		IF (@@ROWCOUNT = 0)
		BEGIN
			IF EXISTS(SELECT conversation_id FROM sys.conversation_endpoints WHERE conversation_handle=@DlgHandle AND state<>'CD')
				END CONVERSATION @DlgHandle;
			BREAK;
		END
		--Запуск модуля lse в многопоточном режиме!
		IF @MsgType='pp_lse_Request'
		BEGIN
			begin try
				--В самом сообщении должна быть База данных для обработки (в формате XML).
				SET	@DB = CAST(@Msg as XML).value('(/DB)[1]', 'NVARCHAR(300)');
				--Теперь запускаем процедуру [lse].[usp_RollForwardRecovery]
				--Для этой процедуры должен быть новый параметр @pp=1 (который определяет запуск в многопоточном режиме)
				EXEC [sputnik].[lse].[usp_RollForwardRecovery] @DBName=@DB, @pp=1;
			end try
			begin catch
				SET @StrErr=N'Ошибка при запуске [lse].[usp_RollForwardRecovery] в потоке [pp].usp_ExecProcessor. Текст ошибки: '+ERROR_MESSAGE();
				END CONVERSATION @DlgHandle WITH ERROR = 10 DESCRIPTION=@StrErr;
			end catch
		END
		--Запуск модуля backups в многопоточном режиме!
		IF @MsgType='pp_back_Request'
		BEGIN
			begin try
				DECLARE @TypeBack VARCHAR(4); --тип бэкапа!
				--В самом сообщении должна быть имя БД и Тип Бэкапа для обработки (в формате XML).
				SET	@DB = CAST(@Msg as XML).value('(/backups/db)[1]', 'NVARCHAR(300)');
				SET	@TypeBack = CAST(@Msg as XML).value('(/backups/type)[1]', 'VARCHAR(4)');
				--Теперь запускаем процедуру выполнения бэкапов [usp_StartBackup] для конкретной БД
				--с параметром @pp=1 - указывает что работа идёт в многопоточном режиме! 
				EXEC [sputnik].[backups].[usp_StartBackup] @DBFilter=@DB, @type=@TypeBack, @pp=1;
			end try
			begin catch
				SET @StrErr=N'Ошибка при запуске [backups].[usp_StartBackup] в потоке [pp].usp_ExecProcessor. Имя БД: ['+@DB+']; Тип бэкапа: ['+@TypeBack+']. Текст ошибки: '+ERROR_MESSAGE();
				--В этом случае не будем заканчивать Диалог принудительно, чтобы другие бэкапы были выполнены до конца!
				--Просто пишем ошибку с подробностями в журнал SQL Server (через print) и заканчиваем выполнения (break):
				PRINT(@StrErr);
				BREAK;
				--END CONVERSATION @DlgHandle WITH ERROR = 10 DESCRIPTION=@StrErr;
			end catch
		END
		--Если в сообщении КонецДиалога или Ошибка, тогда закрыть диалог!
		ELSE IF @MsgType=N'http://schemas.microsoft.com/SQL/ServiceBroker/EndDialog'
			END CONVERSATION @DlgHandle;
		ELSE IF @MsgType=N'http://schemas.microsoft.com/SQL/ServiceBroker/Error'
			END CONVERSATION @DlgHandle;
	END
GO
PRINT N'Creating Procedure [pp].[usp_ExecProcessor]...';


GO

/* =============================================
-- Author:		Андрей Иванов (sqland1c)
-- Create date: 06.08.2014 (1.0)
-- Description: Эта процедура используется как процедура активации для целевой очереди!
				Предназначена для организации многопоточной обработки различных модулей (в зависимости от типа сообщения).
-- Update:		18.01.2015 (1.1)
				Добавлена возможность резервного копирования в многопоточном режиме (схема backups).
				18.01.2015 (1.11)
				Небольшое но важное исправление в алгоритме обработки исключений при работе над сообщениями backups-
				удалена команда завершения диалога (end conversation), чтобы другие бэкапы могли быть выполнены!!
				18.01.2015 (1.12)
				В алгоритме обработки исключений пр работе над сообщениями backups - 
				добавлена команда выхода из цикла (break), чтобы в случае ошибки остальные бэкапы могли 
				быть обработать в других потоках.
				31.03.2016 (1.14)
				Добавлен параметр @execute=1 для вызова [usp_RollForwardRecovery] - этот параметр говорит
				что выполняется обработчик очереди и будет выполнятся накат бэкапов на целевую базу lse.
-- ============================================= */
CREATE PROCEDURE [pp].[usp_ExecProcessor]
AS
	SET NOCOUNT ON;
	DECLARE @DlgHandle UNIQUEIDENTIFIER, @Msg VARBINARY(MAX), @MsgType sysname, @StrErr NVARCHAR(3000),@RunningBackupCount smallint;
	WHILE (1=1)
	BEGIN
		 DECLARE @DB NVARCHAR(300);
		 
		 WAITFOR
			(	RECEIVE TOP(1)
					@DlgHandle = conversation_handle,
					@MsgType   = message_type_name,
					@Msg	   = message_body
				FROM [pp].ProcessorQueue
		), TIMEOUT 1000;		--делаем небольшое ожидание 1 сек. нового сообщения.
		IF (@@ROWCOUNT = 0)
		BEGIN
			IF EXISTS(SELECT conversation_id FROM sys.conversation_endpoints WHERE conversation_handle=@DlgHandle AND state<>'CD')
				END CONVERSATION @DlgHandle;
			BREAK;
		END
		--Запуск модуля lse в многопоточном режиме!
		IF @MsgType='pp_lse_Request'
		BEGIN
			begin try
				--В самом сообщении должна быть База данных для обработки (в формате XML).
				SET	@DB = CAST(@Msg as XML).value('(/DB)[1]', 'NVARCHAR(300)');
				--Теперь запускаем процедуру [lse].[usp_RollForwardRecovery]
				--Для этой процедуры должен быть новый параметр @pp=1 (который определяет запуск в многопоточном режиме)
				--А также специальный флаг @execute=1
				EXEC [sputnik].[lse].[usp_RollForwardRecovery] @DBName=@DB, @pp=1, @execute=1;
			end try
			begin catch
				SET @StrErr=N'Ошибка при запуске [lse].[usp_RollForwardRecovery] в потоке [pp].usp_ExecProcessor. Текст ошибки: '+ERROR_MESSAGE();
				END CONVERSATION @DlgHandle WITH ERROR = 10 DESCRIPTION=@StrErr;
			end catch
		END
		--Запуск модуля backups в многопоточном режиме!
		IF @MsgType='pp_back_Request'
		BEGIN
			begin try
				DECLARE @TypeBack VARCHAR(4); --тип бэкапа!
				--В самом сообщении должна быть имя БД и Тип Бэкапа для обработки (в формате XML).
				SET	@DB = CAST(@Msg as XML).value('(/backups/db)[1]', 'NVARCHAR(300)');
				SET	@TypeBack = CAST(@Msg as XML).value('(/backups/type)[1]', 'VARCHAR(4)');
				--Теперь запускаем процедуру выполнения бэкапов [usp_StartBackup] для конкретной БД
				--с параметром @pp=1 - указывает что работа идёт в многопоточном режиме! 
				EXEC [sputnik].[backups].[usp_StartBackup] @DBFilter=@DB, @type=@TypeBack, @pp=1;
			end try
			begin catch
				SET @StrErr=N'Ошибка при запуске [backups].[usp_StartBackup] в потоке [pp].usp_ExecProcessor. Имя БД: ['+@DB+']; Тип бэкапа: ['+@TypeBack+']. Текст ошибки: '+ERROR_MESSAGE();
				--В этом случае не будем заканчивать Диалог принудительно, чтобы другие бэкапы были выполнены до конца!
				--Просто пишем ошибку с подробностями в журнал SQL Server (через print) и заканчиваем выполнения (break):
				PRINT(@StrErr);
				BREAK;
				--END CONVERSATION @DlgHandle WITH ERROR = 10 DESCRIPTION=@StrErr;
			end catch
		END
		--Если в сообщении КонецДиалога или Ошибка, тогда закрыть диалог!
		ELSE IF @MsgType=N'http://schemas.microsoft.com/SQL/ServiceBroker/EndDialog'
			END CONVERSATION @DlgHandle;
		ELSE IF @MsgType=N'http://schemas.microsoft.com/SQL/ServiceBroker/Error'
			END CONVERSATION @DlgHandle;
	END
GO
PRINT N'Creating Procedure [pp].[usp_CheckCommander]...';


GO

/* =============================================
-- Author:		Андрей Иванов (sqland1c)
-- Create date: 07.08.2014 (1.0)
-- Description: 
-- Update:		Эта процедура используется как процедура активации для очереди инициатора!
				Здесь должны обрабатываться ответы (Тип сообщения pp_модуль_Reply) от целевой очереди (Processor)!
				...
				
-- ============================================= */
CREATE PROCEDURE [pp].[usp_CheckCommander]
AS
	SET NOCOUNT ON;
	DECLARE @DlgHandle UNIQUEIDENTIFIER, @Msg VARBINARY(MAX), @MsgType sysname, @StrErr NVARCHAR(3000);
	WHILE (1=1)
	BEGIN
		 WAITFOR
			(	RECEIVE TOP(1)
					@DlgHandle = conversation_handle,
					@MsgType   = message_type_name,
					@Msg	   = message_body
				FROM [pp].[CommanderQueue]
		), TIMEOUT 1000;		--делаем небольшое ожидание 1 сек. нового сообщения.
		IF (@@ROWCOUNT = 0)
		BEGIN
			IF EXISTS(SELECT conversation_id FROM sys.conversation_endpoints WHERE conversation_handle=@DlgHandle AND state<>'CD')
				END CONVERSATION @DlgHandle;
			BREAK;
		END
		--Если в сообщении КонецДиалога или Ошибка, тогда нужно закрыть диалог!
		IF @MsgType=N'http://schemas.microsoft.com/SQL/ServiceBroker/EndDialog'
			END CONVERSATION @DlgHandle;
		ELSE IF @MsgType=N'http://schemas.microsoft.com/SQL/ServiceBroker/Error'
			END CONVERSATION @DlgHandle;
	END
GO
PRINT N'Creating Queue [adt].[event_notification_q]...';


GO
CREATE QUEUE [adt].[event_notification_q]
    WITH ACTIVATION (STATUS = ON, PROCEDURE_NAME = [adt].[usp_eventnots_processor], MAX_QUEUE_READERS = 1, EXECUTE AS OWNER);


GO
PRINT N'Creating Queue [pp].[ProcessorQueue]...';


GO
CREATE QUEUE [pp].[ProcessorQueue]
    WITH ACTIVATION (STATUS = ON, PROCEDURE_NAME = [pp].[usp_ExecProcessor], MAX_QUEUE_READERS = 8, EXECUTE AS OWNER);


GO
PRINT N'Creating Queue [pp].[CommanderQueue]...';


GO
CREATE QUEUE [pp].[CommanderQueue]
    WITH ACTIVATION (STATUS = ON, PROCEDURE_NAME = [pp].[usp_CheckCommander], MAX_QUEUE_READERS = 1, EXECUTE AS OWNER);


GO
PRINT N'Creating Queue [pp].[ProcessorQueueHard]...';


GO
CREATE QUEUE [pp].[ProcessorQueueHard]
    WITH ACTIVATION (STATUS = ON, PROCEDURE_NAME = [pp].[usp_ExecProcessorHard], MAX_QUEUE_READERS = 2, EXECUTE AS OWNER);


GO
PRINT N'Creating Service [pp_Commander]...';


GO
CREATE SERVICE [pp_Commander]
    AUTHORIZATION [dbo]
    ON QUEUE [pp].[CommanderQueue]
    ([pp_lse_Contract], [pp_back_Contract]);


GO
PRINT N'Creating Service [pp_Processor]...';


GO
CREATE SERVICE [pp_Processor]
    AUTHORIZATION [dbo]
    ON QUEUE [pp].[ProcessorQueue]
    ([pp_lse_Contract], [pp_back_Contract]);


GO
PRINT N'Creating Service [pp_ProcessorHard]...';


GO
CREATE SERVICE [pp_ProcessorHard]
    AUTHORIZATION [dbo]
    ON QUEUE [pp].[ProcessorQueueHard]
    ([pp_lse_Contract], [pp_back_Contract]);


GO
PRINT N'Creating Service [service_adt_db_events]...';


GO
CREATE SERVICE [service_adt_db_events]
    AUTHORIZATION [dbo]
    ON QUEUE [adt].[event_notification_q]
    ([http://schemas.microsoft.com/SQL/Notifications/PostEventNotification]);


GO
PRINT N'Creating Broker Priority [pp_lse_PriorityFromCommander]...';


GO
CREATE BROKER PRIORITY [pp_lse_PriorityFromCommander] FOR CONVERSATION
    SET  (
            CONTRACT_NAME = [pp_lse_Contract],
            LOCAL_SERVICE_NAME = [pp_Commander],
            REMOTE_SERVICE_NAME = N'pp_Processor',
            PRIORITY_LEVEL = 3
         );


GO
PRINT N'Creating Broker Priority [pp_lse_PriorityFromProcessor]...';


GO
CREATE BROKER PRIORITY [pp_lse_PriorityFromProcessor] FOR CONVERSATION
    SET  (
            CONTRACT_NAME = [pp_lse_Contract],
            LOCAL_SERVICE_NAME = [pp_Processor],
            REMOTE_SERVICE_NAME = N'pp_Commander',
            PRIORITY_LEVEL = 3
         );


GO
PRINT N'Creating Permission Permission...';


GO
GRANT INSERT
    ON OBJECT::[adt].[jlogon] TO [audit_writer]
    AS [dbo];


GO
PRINT N'Creating Permission Permission...';


GO
GRANT INSERT
    ON OBJECT::[adt].[jconfigure] TO [audit_writer]
    AS [dbo];


GO
PRINT N'Creating Permission Permission...';


GO
GRANT INSERT
    ON OBJECT::[adt].[jsecurity] TO [audit_writer]
    AS [dbo];


GO
PRINT N'Creating Permission Permission...';


GO
GRANT SELECT
    ON OBJECT::[awr].[sql_handle_collect] TO [zabbix]
    AS [dbo];


GO
PRINT N'Creating Permission Permission...';


GO
GRANT SELECT
    ON OBJECT::[awr].[sql_text_collect] TO [zabbix]
    AS [dbo];


GO
PRINT N'Creating Permission Permission...';


GO
GRANT SELECT
    ON OBJECT::[info].[vtempusing] TO [zabbix]
    AS [dbo];


GO
PRINT N'Creating Permission Permission...';


GO
GRANT EXECUTE
    ON OBJECT::[info].[usp_tempusing_total] TO [zabbix]
    AS [dbo];


GO
PRINT N'Creating Permission Permission...';


GO
GRANT EXECUTE
    ON OBJECT::[info].[usp_tempusing_user] TO [zabbix]
    AS [dbo];


GO
PRINT N'Creating Permission Permission...';


GO
GRANT EXECUTE
    ON OBJECT::[info].[usp_tempusing_internal] TO [zabbix]
    AS [dbo];


GO
PRINT N'Creating Permission Permission...';


GO
GRANT EXECUTE
    ON OBJECT::[info].[usp_tempusing_rowver] TO [zabbix]
    AS [dbo];


GO
PRINT N'Creating Permission Permission...';


GO
GRANT EXECUTE
    ON OBJECT::[info].[usp_SQLMon] TO [zabbix]
    AS [dbo];


GO
PRINT N'Creating Permission Permission...';


GO
GRANT EXECUTE
    ON OBJECT::[info].[usp_DBSizeReport] TO [zabbix]
    AS [dbo];


GO
PRINT N'Creating Permission Permission...';


GO
GRANT EXECUTE
    ON OBJECT::[info].[usp_CheckMirror] TO [zabbix]
    AS [dbo];


GO
PRINT N'Creating Permission Permission...';


GO
GRANT EXECUTE
    ON OBJECT::[info].[sp_who3] TO [zabbix]
    AS [dbo];


GO
DECLARE @VarDecimalSupported AS BIT;

SELECT @VarDecimalSupported = 0;

IF ((ServerProperty(N'EngineEdition') = 3)
    AND (((@@microsoftversion / power(2, 24) = 9)
          AND (@@microsoftversion & 0xffff >= 3024))
         OR ((@@microsoftversion / power(2, 24) = 10)
             AND (@@microsoftversion & 0xffff >= 1600))))
    SELECT @VarDecimalSupported = 1;

IF (@VarDecimalSupported > 0)
    BEGIN
        EXECUTE sp_db_vardecimal_storage_format N'$(DatabaseName)', 'ON';
    END


GO
PRINT N'Update complete.';


GO
